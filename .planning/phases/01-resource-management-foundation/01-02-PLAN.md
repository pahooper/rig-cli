---
phase: 01-resource-management-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - codex-adapter/Cargo.toml
  - codex-adapter/src/error.rs
  - codex-adapter/src/process.rs
  - codex-adapter/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "codex-adapter subprocess spawning never panics on missing stdout/stderr"
    - "codex-adapter uses bounded channels for internal stream communication"
    - "codex-adapter tracks spawned tasks via JoinSet and aborts on timeout/drop"
    - "codex-adapter sends SIGTERM before SIGKILL on timeout with grace period"
    - "codex-adapter drains remaining buffered output before cleanup"
    - "codex-adapter enforces hard memory limit on accumulated output"
    - "codex-adapter error types carry subprocess PID, elapsed time, and pipeline stage"
  artifacts:
    - path: "codex-adapter/src/error.rs"
      provides: "Rich CodexError enum with subprocess context variants"
      contains: "Timeout.*pid.*elapsed|SpawnFailed.*stage|StreamFailed|SignalFailed|OutputTruncated"
    - path: "codex-adapter/src/process.rs"
      provides: "Subprocess execution with bounded channels, JoinSet, graceful shutdown"
      contains: "mpsc::channel|JoinSet|SIGTERM|GRACE_PERIOD|MAX_OUTPUT_BYTES"
    - path: "codex-adapter/src/lib.rs"
      provides: "Public API with bounded Sender for streaming"
      contains: "mpsc::Sender"
  key_links:
    - from: "codex-adapter/src/process.rs"
      to: "codex-adapter/src/error.rs"
      via: "Error propagation from all fallible operations"
      pattern: "CodexError::"
    - from: "codex-adapter/src/process.rs"
      to: "tokio::task::JoinSet"
      via: "Task tracking for stdout/stderr reader tasks"
      pattern: "JoinSet::new|tasks\\.spawn"
    - from: "codex-adapter/src/process.rs"
      to: "nix::sys::signal"
      via: "SIGTERM for graceful subprocess shutdown"
      pattern: "kill.*Signal::SIGTERM"
---

<objective>
Rewrite codex-adapter subprocess execution with bounded resources and zero panics.

Purpose: The codex-adapter has the same resource management problems as claudecode-adapter: unbounded channels, .expect() calls, Arc<Mutex<String>> accumulation, no JoinSet, SIGKILL-only timeout. This plan applies the same bounded-resource pattern to codex-adapter, adapted for its simpler type system (no stream_events Vec, no OutputFormat check, simpler RunResult).

Output: A fully rewritten error.rs, process.rs, and updated lib.rs in codex-adapter satisfying RSRC-01 through RSRC-05 for this crate.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-resource-management-foundation/01-CONTEXT.md
@.planning/phases/01-resource-management-foundation/01-RESEARCH.md
@codex-adapter/src/error.rs
@codex-adapter/src/process.rs
@codex-adapter/src/lib.rs
@codex-adapter/src/types.rs
@codex-adapter/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nix dependency and rewrite CodexError with rich subprocess context</name>
  <files>codex-adapter/Cargo.toml, codex-adapter/src/error.rs</files>
  <action>
  1. In Cargo.toml, add `nix = { version = "0.29", features = ["signal"] }` to dependencies.

  2. Rewrite error.rs to replace the current CodexError enum with rich subprocess context variants. Keep existing non-subprocess variants (ExecutableNotFound, WhichError) but replace/enhance the subprocess-related ones:

  **Remove:**
  - `SpawnFailed(#[from] std::io::Error)` — replace with richer version
  - `Timeout(std::time::Duration)` — replace with version carrying partial output
  - `NonZeroExit { exit_code, stdout, stderr }` — add PID and elapsed time
  - `AnyhowError(#[from] anyhow::Error)` — keep if needed by other code, but audit usage
  - `Other(String)` — replace with specific variants

  **Add these subprocess-specific variants (same pattern as claudecode-adapter):**
  - `SpawnFailed { stage: String, source: std::io::Error }` — with #[source]
  - `Timeout { elapsed: std::time::Duration, pid: u32, partial_stdout: String, partial_stderr: String }`
  - `NonZeroExit { exit_code: i32, pid: u32, elapsed: std::time::Duration, stdout: String, stderr: String }`
  - `StreamFailed { stage: String, source: tokio::task::JoinError }` — with #[source]
  - `SignalFailed { signal: String, pid: u32, source: nix::errno::Errno }` — with #[source]
  - `NoStdout`
  - `NoStderr`
  - `NoPid`
  - `OutputTruncated { captured_bytes: usize, limit_bytes: usize }`
  - `ChannelClosed { stage: String }`

  Keep `ExecutableNotFound(String)` and `WhichError(#[from] which::Error)`.
  Keep `AnyhowError(#[from] anyhow::Error)` only if grep confirms it's used outside process.rs.

  Add `impl From<std::io::Error> for CodexError` mapping to SpawnFailed with default stage "io".

  IMPORTANT: Do NOT use #[source] on String fields — only on actual Error types.
  </action>
  <verify>
  Verify error.rs is syntactically valid. Full compilation may require Task 2 since process.rs references old error variants.
  </verify>
  <done>codex-adapter/src/error.rs has rich context error variants with PID, elapsed time, partial output, pipeline stage. nix dependency added to Cargo.toml.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite process.rs with bounded channels, JoinSet, graceful shutdown, and update lib.rs API</name>
  <files>codex-adapter/src/process.rs, codex-adapter/src/lib.rs</files>
  <action>
  **Rewrite process.rs completely** following the same architecture as the 01-RESEARCH.md patterns.

  **Constants (top of file):**
  ```
  const CHANNEL_CAPACITY: usize = 100;
  const MAX_OUTPUT_BYTES: usize = 10 * 1024 * 1024; // 10 MB
  const GRACE_PERIOD: Duration = Duration::from_secs(5);
  ```

  **Function signature change:**
  Change `sender: Option<tokio::sync::mpsc::UnboundedSender<crate::types::StreamEvent>>` to `sender: Option<tokio::sync::mpsc::Sender<crate::types::StreamEvent>>` (bounded).

  **Implementation flow (same pattern as claudecode-adapter but simpler):**
  1. Spawn subprocess, take stdout/stderr with `?` (no .expect()), get PID
  2. Create bounded internal channels for stdout and stderr lines
  3. JoinSet with two reader tasks:
     - stdout reader: reads lines, tracks bytes, sends on internal channel. If sender is Some, attempt JSONL parse for StreamEvent forwarding to caller. Truncate at MAX_OUTPUT_BYTES.
     - stderr reader: reads lines, tracks bytes, sends on internal channel. Truncate at limit.
  4. Main loop with tokio::select! receiving from both channels into Vec<String>
  5. Timeout wrapper around main loop + child.wait()
  6. Graceful shutdown on timeout: SIGTERM -> GRACE_PERIOD -> SIGKILL
  7. Return RunResult (codex RunResult is simpler: stdout, stderr, exit_code, duration_ms — no json field, no stream_events)

  **Codex-specific differences from claudecode:**
  - No OutputFormat check (codex doesn't have StreamJson mode in the same way)
  - Simpler RunResult (no json, no stream_events, no structured_output fields)
  - No env setting from config (codex uses `cd` not `cwd`)
  - Config uses `config.cd` for current_dir, not `config.cwd`

  **Helper functions:** Same `drain_stream_bounded` and `graceful_shutdown` pattern.

  **Remove:**
  - All Arc<Mutex<String>> usage
  - All .expect() calls
  - Bare child.kill() without SIGTERM
  - Untracked tokio::spawn calls

  **Update lib.rs:**
  Change `CodexCli::stream()` signature from `UnboundedSender` to `Sender` (bounded).
  </action>
  <verify>
  Run `cargo check -p codex-adapter`. Should compile with zero errors.
  Run `cargo clippy -p codex-adapter -- -W clippy::unwrap_used -W clippy::expect_used -W clippy::panic` and verify zero violations in process.rs.
  </verify>
  <done>
  codex-adapter/src/process.rs uses bounded channels, JoinSet, SIGTERM->SIGKILL, bounded accumulation, zero .expect()/.unwrap(). lib.rs stream() uses bounded Sender. `cargo check -p codex-adapter` passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p codex-adapter` compiles without errors
2. `grep -n "\.expect\(\|\.unwrap\(\|panic!" codex-adapter/src/process.rs` returns zero matches
3. `grep -n "unbounded" codex-adapter/src/process.rs codex-adapter/src/lib.rs` returns zero matches
4. `grep -n "JoinSet" codex-adapter/src/process.rs` returns at least one match
5. `grep -n "SIGTERM\|Signal::SIGTERM" codex-adapter/src/process.rs` returns at least one match
6. `grep -n "mpsc::channel" codex-adapter/src/process.rs` returns at least one match
7. `grep -n "MAX_OUTPUT_BYTES" codex-adapter/src/process.rs` returns at least one match
</verification>

<success_criteria>
- codex-adapter compiles with `cargo check`
- process.rs contains zero .expect(), .unwrap(), or panic! calls
- Internal channels are bounded with explicit capacity
- Tasks tracked via JoinSet
- Graceful SIGTERM/SIGKILL shutdown with 5s grace period
- Output capped at 10MB
- Error types carry PID, elapsed time, partial output
- lib.rs stream() uses bounded Sender
</success_criteria>

<output>
After completion, create `.planning/phases/01-resource-management-foundation/01-02-SUMMARY.md`
</output>
