---
phase: 01-resource-management-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - claudecode-adapter/Cargo.toml
  - claudecode-adapter/src/error.rs
  - claudecode-adapter/src/process.rs
  - claudecode-adapter/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "claudecode-adapter subprocess spawning never panics on missing stdout/stderr"
    - "claudecode-adapter uses bounded channels for internal stream communication"
    - "claudecode-adapter tracks spawned tasks via JoinSet and aborts on timeout/drop"
    - "claudecode-adapter sends SIGTERM before SIGKILL on timeout with grace period"
    - "claudecode-adapter drains remaining buffered output before cleanup"
    - "claudecode-adapter enforces hard memory limit on accumulated output"
    - "claudecode-adapter error types carry subprocess PID, elapsed time, and pipeline stage"
  artifacts:
    - path: "claudecode-adapter/src/error.rs"
      provides: "Rich ClaudeError enum with subprocess context variants"
      contains: "Timeout.*pid.*elapsed|SpawnFailed.*stage|StreamFailed|SignalFailed|OutputTruncated"
    - path: "claudecode-adapter/src/process.rs"
      provides: "Subprocess execution with bounded channels, JoinSet, graceful shutdown"
      contains: "mpsc::channel|JoinSet|SIGTERM|GRACE_PERIOD|MAX_OUTPUT_BYTES"
    - path: "claudecode-adapter/src/lib.rs"
      provides: "Public API with bounded Sender for streaming"
      contains: "mpsc::Sender"
  key_links:
    - from: "claudecode-adapter/src/process.rs"
      to: "claudecode-adapter/src/error.rs"
      via: "Error propagation from all fallible operations"
      pattern: "ClaudeError::"
    - from: "claudecode-adapter/src/process.rs"
      to: "tokio::task::JoinSet"
      via: "Task tracking for stdout/stderr reader tasks"
      pattern: "JoinSet::new|tasks\\.spawn"
    - from: "claudecode-adapter/src/process.rs"
      to: "nix::sys::signal"
      via: "SIGTERM for graceful subprocess shutdown"
      pattern: "kill.*Signal::SIGTERM"
---

<objective>
Rewrite claudecode-adapter subprocess execution with bounded resources and zero panics.

Purpose: The claudecode-adapter is the primary adapter. Its process.rs currently uses unbounded channels, .expect() calls, Arc<Mutex<String>> for output accumulation (holds mutex across await), no JoinSet tracking, and only SIGKILL on timeout. This plan replaces all of that with bounded channels, JoinSet-tracked tasks, SIGTERM/SIGKILL graceful shutdown, bounded output accumulation, and rich error propagation.

Output: A fully rewritten error.rs, process.rs, and updated lib.rs in claudecode-adapter that satisfy RSRC-01 through RSRC-05 for this crate.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-resource-management-foundation/01-CONTEXT.md
@.planning/phases/01-resource-management-foundation/01-RESEARCH.md
@claudecode-adapter/src/error.rs
@claudecode-adapter/src/process.rs
@claudecode-adapter/src/lib.rs
@claudecode-adapter/src/types.rs
@claudecode-adapter/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nix dependency and rewrite ClaudeError with rich subprocess context</name>
  <files>claudecode-adapter/Cargo.toml, claudecode-adapter/src/error.rs</files>
  <action>
  1. In Cargo.toml, add `nix = { version = "0.29", features = ["signal"] }` to dependencies.

  2. Rewrite error.rs to replace the current ClaudeError enum with rich subprocess context variants. Keep existing non-subprocess variants (ExecutableNotFound, VersionCheckFailed, DoctorFailed, InvalidConfig, JsonParseError) but replace/enhance the subprocess-related ones:

  **Remove:**
  - `SpawnFailed(#[from] std::io::Error)` — replace with richer version
  - `Timeout(std::time::Duration)` — replace with version that carries partial output
  - `NonZeroExit { exit_code, stdout, stderr }` — add PID and elapsed time
  - `Other(String)` — replace with specific variants

  **Add these subprocess-specific variants:**
  - `SpawnFailed { stage: String, source: std::io::Error }` — with #[source] on source, stage describes what was being attempted (e.g., "subprocess spawn", "pipe setup")
  - `Timeout { elapsed: std::time::Duration, pid: u32, partial_stdout: String, partial_stderr: String }` — carries partial output for debugging
  - `NonZeroExit { exit_code: i32, pid: u32, elapsed: std::time::Duration, stdout: String, stderr: String }` — richer context
  - `StreamFailed { stage: String, source: tokio::task::JoinError }` — with #[source], for reader task failures
  - `SignalFailed { signal: String, pid: u32, source: nix::errno::Errno }` — with #[source], for SIGTERM send failure
  - `NoStdout` — for when stdout pipe is None (replaces .expect())
  - `NoStderr` — for when stderr pipe is None (replaces .expect())
  - `NoPid` — for when child.id() returns None
  - `OutputTruncated { captured_bytes: usize, limit_bytes: usize }` — informational, not fatal (used as warning data, not necessarily returned as error)
  - `ChannelClosed { stage: String }` — when mpsc sender/receiver drops unexpectedly

  Keep these existing variants unchanged:
  - `ExecutableNotFound(String)`
  - `VersionCheckFailed(String)`
  - `DoctorFailed { stdout, stderr, status }`
  - `JsonParseError(String)`
  - `InvalidConfig(String)`

  Add `impl From<std::io::Error> for ClaudeError` that maps to SpawnFailed with a default stage of "io", since the #[from] automatic derive won't work with the multi-field SpawnFailed variant. Keep the existing #[from] behavior for io::Error by implementing From manually.

  Use thiserror #[error(...)] display formatting with the context fields embedded in messages.

  IMPORTANT: Do NOT use #[source] on String fields (partial_stdout etc.) — #[source] only works on Error types. Use it only on `source: std::io::Error`, `source: tokio::task::JoinError`, and `source: nix::errno::Errno`.
  </action>
  <verify>
  Run `cargo check -p claudecode-adapter` — it should compile (process.rs will have warnings since it still uses old error variants, but error.rs itself should be valid).
  Actually, process.rs references old error variants, so this may fail to compile until Task 2. That is acceptable — verify error.rs is syntactically correct by checking the file structure.
  </verify>
  <done>claudecode-adapter/src/error.rs has rich context error variants with PID, elapsed time, partial output, pipeline stage. nix dependency added to Cargo.toml. No .expect() or .unwrap() in error.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite process.rs with bounded channels, JoinSet, graceful shutdown, and update lib.rs API</name>
  <files>claudecode-adapter/src/process.rs, claudecode-adapter/src/lib.rs</files>
  <action>
  **Rewrite process.rs completely.** The current implementation has: unbounded sender parameter, .expect() on stdout/stderr take, Arc<Mutex<String>> for accumulation (anti-pattern), no JoinSet, SIGKILL-only timeout, no stream draining on timeout, no memory limits.

  Replace with this architecture (following 01-RESEARCH.md patterns):

  **Constants (top of file):**
  ```
  const CHANNEL_CAPACITY: usize = 100;
  const MAX_OUTPUT_BYTES: usize = 10 * 1024 * 1024; // 10 MB
  const GRACE_PERIOD: Duration = Duration::from_secs(5);
  ```

  **Function signature change:**
  Change `sender: Option<tokio::sync::mpsc::UnboundedSender<crate::types::StreamEvent>>` to `sender: Option<tokio::sync::mpsc::Sender<crate::types::StreamEvent>>` (bounded).

  **Implementation flow:**
  1. Spawn subprocess with piped stdout/stderr (same as before but use `?` with ClaudeError::SpawnFailed instead of .expect())
  2. Take stdout/stderr with `.ok_or(ClaudeError::NoStdout)?` and `.ok_or(ClaudeError::NoStderr)?`
  3. Get PID with `child.id().ok_or(ClaudeError::NoPid)?`
  4. Create two bounded internal channels: `mpsc::channel::<String>(CHANNEL_CAPACITY)` for stdout lines and stderr lines
  5. Create a `JoinSet` and spawn two reader tasks:
     - stdout reader: reads lines from BufReader, tracks total bytes, sends on internal stdout_tx. If sender (caller channel) is Some, also parse JSONL and forward StreamEvents. Stops if total_bytes exceeds MAX_OUTPUT_BYTES (sends "[TRUNCATED]" marker and breaks). If internal channel send fails (receiver dropped), breaks.
     - stderr reader: same pattern but simpler (no JSONL parsing, just lines on internal stderr_tx)
  6. Main execution loop (wrapped in tokio::time::timeout with config.timeout):
     - Use `tokio::select!` to recv from both internal channels, accumulating into Vec<String> (NOT Arc<Mutex<String>>)
     - Track stdout_done/stderr_done flags, break when both channels close (recv returns None)
     - After channels close, call `child.wait().await` to get exit status
     - Await all tasks in JoinSet (they should already be done since channels closed means readers hit EOF)
     - Return RunResult with accumulated output
  7. Timeout path:
     - Call graceful_shutdown: send SIGTERM via nix::sys::signal::kill, wait GRACE_PERIOD for child.wait(), if still alive send SIGKILL via child.kill().await + child.wait().await
     - Abort all tasks in JoinSet (tasks.abort_all())
     - Return ClaudeError::Timeout with elapsed time, PID, and partial stdout/stderr accumulated so far
  8. Error handling: every fallible operation returns Result via `?` — no .expect(), no .unwrap()

  **Helper function: `drain_stream_bounded`**
  Extract the reader task logic into a helper:
  ```rust
  async fn drain_stream_bounded(
      reader: BufReader<impl tokio::io::AsyncRead + Unpin>,
      tx: mpsc::Sender<String>,
      max_bytes: usize,
  ) -> Result<(), ClaudeError>
  ```
  Reads lines, tracks total bytes, sends on channel. Returns Ok on EOF or when limit hit. Returns Err only on I/O error (channel closed is Ok — means receiver dropped, which is fine).

  **Helper function: `graceful_shutdown`**
  ```rust
  async fn graceful_shutdown(child: &mut tokio::process::Child, pid: u32) -> Result<std::process::ExitStatus, ClaudeError>
  ```
  Sends SIGTERM, waits GRACE_PERIOD, falls back to SIGKILL. On nix signal errors (e.g., process already dead), logs warning but continues to child.kill(). Always calls child.wait() to prevent zombies.

  **IMPORTANT behavioral notes from CONTEXT.md (locked decisions):**
  - Stdout carries JSONL protocol messages; keep the existing serde_json parsing for StreamEvent forwarding
  - Stderr is captured and surfaced to callers (in error results and RunResult), not just logged
  - Non-zero exit code does NOT automatically mean error — return RunResult with the exit code, let caller decide
  - Channel capacity is hardcoded (100), not configurable
  - Timeout is read from config.timeout (already hardcoded in RunConfig::default as 300s)
  - On normal exit: wait until streams are fully drained (no timeout on drain)
  - On kill: still attempt to drain remaining buffered output (the partial output in channels)

  **Keep existing behavior:**
  - The JSONL stream event parsing and forwarding to caller's sender
  - The stream_events Vec<serde_json::Value> accumulation for claude-specific RunResult
  - The OutputFormat::StreamJson check
  - The cwd and env configuration from RunConfig

  **Remove:**
  - All Arc<Mutex<String>> usage (replace with Vec<String> accumulation in main task)
  - All .expect() calls
  - The bare `child.kill()` without SIGTERM
  - The untracked tokio::spawn calls

  **Update lib.rs:**
  Change the `stream()` method signature on `ClaudeCli` from:
  ```rust
  pub async fn stream(&self, prompt: &str, config: &types::RunConfig, sender: tokio::sync::mpsc::UnboundedSender<types::StreamEvent>)
  ```
  to:
  ```rust
  pub async fn stream(&self, prompt: &str, config: &types::RunConfig, sender: tokio::sync::mpsc::Sender<types::StreamEvent>)
  ```
  (Change UnboundedSender to Sender — bounded channel sender.)
  </action>
  <verify>
  Run `cargo check -p claudecode-adapter`. It should compile with zero errors. There may be clippy warnings — that is acceptable for now (Plan 04 handles clippy cleanup).

  Then run `cargo clippy -p claudecode-adapter -- -W clippy::unwrap_used -W clippy::expect_used -W clippy::panic` and verify zero violations of unwrap/expect/panic in process.rs.
  </verify>
  <done>
  claudecode-adapter/src/process.rs uses bounded mpsc::channel(100) for internal communication, JoinSet for task tracking, SIGTERM->SIGKILL graceful shutdown with 5s grace period, bounded output accumulation with 10MB limit, and zero .expect()/.unwrap() calls. lib.rs stream() signature uses bounded Sender. `cargo check -p claudecode-adapter` passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p claudecode-adapter` compiles without errors
2. `grep -n "\.expect\(\|\.unwrap\(\|panic!" claudecode-adapter/src/process.rs` returns zero matches
3. `grep -n "unbounded" claudecode-adapter/src/process.rs claudecode-adapter/src/lib.rs` returns zero matches
4. `grep -n "JoinSet" claudecode-adapter/src/process.rs` returns at least one match
5. `grep -n "SIGTERM\|Signal::SIGTERM" claudecode-adapter/src/process.rs` returns at least one match
6. `grep -n "mpsc::channel" claudecode-adapter/src/process.rs` returns at least one match (bounded, not unbounded)
7. `grep -n "MAX_OUTPUT_BYTES" claudecode-adapter/src/process.rs` returns at least one match
</verification>

<success_criteria>
- claudecode-adapter compiles with `cargo check`
- process.rs contains zero .expect(), .unwrap(), or panic! calls
- Internal channels are bounded (mpsc::channel with explicit capacity)
- Tasks tracked via JoinSet with abort_all on timeout
- Graceful shutdown sends SIGTERM before SIGKILL with 5s grace period
- Output accumulation capped at 10MB with truncation warning
- Error types carry PID, elapsed time, partial output, pipeline stage
- lib.rs stream() method uses bounded Sender
</success_criteria>

<output>
After completion, create `.planning/phases/01-resource-management-foundation/01-01-SUMMARY.md`
</output>
