---
phase: 05-observability-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - rig-provider/Cargo.toml
  - rig-provider/src/version.rs
  - rig-provider/src/lib.rs
  - rig-provider/src/mcp_agent.rs
autonomous: true

must_haves:
  truths:
    - "CLI version is detected from --version output for Claude Code, Codex, and OpenCode during agent execution"
    - "Parsed version is compared against hardcoded minimum supported version per adapter"
    - "When CLI version is below minimum, a tracing::warn event is emitted with detected and required versions"
    - "When CLI version cannot be parsed, a tracing::warn event is emitted with the raw version string"
    - "Version validation does not block execution (warn-only, graceful degradation)"
    - "When CLI version is supported, a tracing::info event confirms version is valid"
  artifacts:
    - path: "rig-provider/src/version.rs"
      provides: "Version parsing, comparison, and requirement types"
      contains: "VersionStatus"
      min_lines: 40
    - path: "rig-provider/Cargo.toml"
      provides: "semver dependency"
      contains: "semver"
    - path: "rig-provider/src/mcp_agent.rs"
      provides: "Version validation wired into adapter execution paths"
      contains: "validate_version"
  key_links:
    - from: "rig-provider/src/version.rs"
      to: "semver"
      via: "semver::Version parsing and comparison"
      pattern: "semver::Version"
    - from: "rig-provider/src/mcp_agent.rs"
      to: "rig-provider/src/version.rs"
      via: "version validation calls in run_claude_code, run_codex, run_opencode"
      pattern: "validate_version|version::"
---

<objective>
Add CLI version detection and validation with structured warnings for all three adapters.

Purpose: OBSV-02 requires CLI tool versions to be detected and validated at startup with clear warnings on unsupported versions. When a developer runs an extraction against an untested or unsupported CLI version, they should see a clear tracing warning -- not a mysterious failure later.

Output: A version module in rig-provider with parse/validate logic, wired into the three adapter execution paths in mcp_agent.rs. Version validation is warn-only (never blocks execution).
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-observability-infrastructure/05-RESEARCH.md

@rig-provider/Cargo.toml
@rig-provider/src/lib.rs
@rig-provider/src/mcp_agent.rs
@claudecode-adapter/src/init.rs
@claudecode-adapter/src/types.rs
@codex-adapter/src/lib.rs
@opencode-adapter/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add semver dependency and create version module</name>
  <files>
    rig-provider/Cargo.toml
    rig-provider/src/version.rs
    rig-provider/src/lib.rs
  </files>
  <action>
**1. Add semver to rig-provider/Cargo.toml:**

Add under [dependencies]:
```toml
semver = "1.0"
```

**2. Create rig-provider/src/version.rs:**

This module provides version parsing, requirement definitions, and validation with tracing.

```rust
//! CLI tool version detection and validation.
//!
//! Parses version strings from CLI `--version` output, compares against
//! per-adapter minimum requirements, and emits structured tracing warnings
//! when versions are unsupported or untested.
```

**Types to define:**

`VersionRequirement` struct with:
- `min_supported: semver::Version` -- minimum version known to work
- `max_tested: Option<semver::Version>` -- highest version we've tested against
- `cli_name: &'static str` -- for log messages ("Claude Code", "Codex", "OpenCode")

`VersionStatus` enum with variants:
- `Supported { version: semver::Version }` -- within tested range
- `Unsupported { version: semver::Version, min_required: semver::Version }` -- below minimum
- `Untested { version: semver::Version, max_tested: semver::Version }` -- above max tested
- `ParseFailed { raw: String }` -- could not parse version string

**Constants for version requirements** (hardcoded per research recommendation):

```rust
/// Version requirements for Claude Code CLI.
/// Based on E2E testing during Phase 4 (2026-02-02).
pub fn claude_code_requirement() -> VersionRequirement {
    VersionRequirement {
        min_supported: semver::Version::new(1, 0, 0),
        max_tested: Some(semver::Version::new(1, 99, 99)),
        cli_name: "Claude Code",
    }
}

/// Version requirements for Codex CLI.
/// v0.91.0 is known minimum (dropped --ask-for-approval flag).
pub fn codex_requirement() -> VersionRequirement {
    VersionRequirement {
        min_supported: semver::Version::new(0, 91, 0),
        max_tested: Some(semver::Version::new(0, 99, 99)),
        cli_name: "Codex",
    }
}

/// Version requirements for OpenCode CLI.
pub fn opencode_requirement() -> VersionRequirement {
    VersionRequirement {
        min_supported: semver::Version::new(0, 1, 0),
        max_tested: None,  // Not actively tested
        cli_name: "OpenCode",
    }
}
```

Note: Use generous max_tested ranges. The exact numbers are placeholders -- the point is the infrastructure exists. Users will see "untested" warnings when CLIs update past these ranges, which is the desired behavior.

**Functions:**

`parse_cli_version(version_output: &str) -> Result<semver::Version, semver::Error>`:
- Take the last whitespace-separated token (handles "claude v1.2.3", "codex version 0.5.1")
- Strip leading 'v' prefix
- Parse with `semver::Version::parse()`
- This is a pure function, no tracing here

`validate_version(version_output: &str, requirement: &VersionRequirement) -> VersionStatus`:
- Call `parse_cli_version` first
- If parse fails, return `VersionStatus::ParseFailed`
- If version < min_supported, return `VersionStatus::Unsupported`
- If max_tested is Some and version > max_tested, return `VersionStatus::Untested`
- Otherwise return `VersionStatus::Supported`

`log_version_status(status: &VersionStatus, requirement: &VersionRequirement)`:
- This function emits the tracing events based on status:
  - `Supported`: `tracing::info!(cli = requirement.cli_name, version = %v, "cli_version_validated")`
  - `Unsupported`: `tracing::warn!(cli = requirement.cli_name, detected = %v, required = %min, "cli_version_unsupported")`
  - `Untested`: `tracing::warn!(cli = requirement.cli_name, detected = %v, max_tested = %max, "cli_version_untested")`
  - `ParseFailed`: `tracing::warn!(cli = requirement.cli_name, raw_version = %raw, "cli_version_parse_failed")`

**Add unit tests:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_claude_version() {
        // Claude outputs "claude-code v1.2.3" or similar
        let v = parse_cli_version("claude-code v1.2.3").unwrap();
        assert_eq!(v, semver::Version::new(1, 2, 3));
    }

    #[test]
    fn test_parse_codex_version() {
        // Codex outputs "codex/0.91.0" or "0.91.0" or similar
        let v = parse_cli_version("0.91.0").unwrap();
        assert_eq!(v, semver::Version::new(0, 91, 0));
    }

    #[test]
    fn test_parse_bare_version() {
        let v = parse_cli_version("1.0.0").unwrap();
        assert_eq!(v, semver::Version::new(1, 0, 0));
    }

    #[test]
    fn test_parse_with_v_prefix() {
        let v = parse_cli_version("v2.3.4").unwrap();
        assert_eq!(v, semver::Version::new(2, 3, 4));
    }

    #[test]
    fn test_parse_multiword() {
        let v = parse_cli_version("some tool version v0.5.1").unwrap();
        assert_eq!(v, semver::Version::new(0, 5, 1));
    }

    #[test]
    fn test_validate_supported() {
        let req = VersionRequirement {
            min_supported: semver::Version::new(1, 0, 0),
            max_tested: Some(semver::Version::new(2, 0, 0)),
            cli_name: "Test",
        };
        let status = validate_version("v1.5.0", &req);
        assert!(matches!(status, VersionStatus::Supported { .. }));
    }

    #[test]
    fn test_validate_unsupported() {
        let req = VersionRequirement {
            min_supported: semver::Version::new(1, 0, 0),
            max_tested: Some(semver::Version::new(2, 0, 0)),
            cli_name: "Test",
        };
        let status = validate_version("v0.9.0", &req);
        assert!(matches!(status, VersionStatus::Unsupported { .. }));
    }

    #[test]
    fn test_validate_untested() {
        let req = VersionRequirement {
            min_supported: semver::Version::new(1, 0, 0),
            max_tested: Some(semver::Version::new(2, 0, 0)),
            cli_name: "Test",
        };
        let status = validate_version("v3.0.0", &req);
        assert!(matches!(status, VersionStatus::Untested { .. }));
    }

    #[test]
    fn test_validate_parse_failed() {
        let req = VersionRequirement {
            min_supported: semver::Version::new(1, 0, 0),
            max_tested: None,
            cli_name: "Test",
        };
        let status = validate_version("not-a-version", &req);
        assert!(matches!(status, VersionStatus::ParseFailed { .. }));
    }
}
```

**3. Register the module in rig-provider/src/lib.rs:**

Add `pub mod version;` to lib.rs. Read lib.rs first to find the right location among existing module declarations.
  </action>
  <verify>
1. `cargo check -p rig-provider` compiles without errors.
2. `cargo test -p rig-provider -- version` runs and passes all version tests.
3. `cargo clippy -p rig-provider` produces no new warnings.
4. Grep version.rs for `VersionStatus`, `VersionRequirement`, `parse_cli_version`, `validate_version`, `log_version_status` to confirm all types and functions exist.
  </verify>
  <done>
version.rs exists with VersionRequirement, VersionStatus, parse_cli_version(), validate_version(), log_version_status(), and per-adapter requirement constants. All unit tests pass. semver dependency added to Cargo.toml. Module registered in lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire version validation into McpToolAgent adapter execution paths</name>
  <files>rig-provider/src/mcp_agent.rs</files>
  <action>
Wire version validation into the three adapter execution functions in mcp_agent.rs. Version checks happen at the start of each adapter's run function, after CLI discovery/init but before execution.

**For `run_claude_code()`:**

After `claudecode_adapter::init(None).await` succeeds and before `cli.run()`:
```rust
// Version validation (OBSV-02)
let version_status = crate::version::validate_version(
    &report.version,
    &crate::version::claude_code_requirement(),
);
crate::version::log_version_status(&version_status, &crate::version::claude_code_requirement());
```

The claude adapter's `init()` already captures the version string in `report.version`. No additional subprocess call needed.

**For `run_codex()`:**

After `codex_adapter::discover_codex()` and `CodexCli::new()`, add a version detection step before `cli.run()`:

```rust
// Detect version for validation (OBSV-02)
let version_output = tokio::process::Command::new(&path)
    .arg("--version")
    .output()
    .await
    .ok()
    .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
    .unwrap_or_default();

if !version_output.is_empty() {
    let version_status = crate::version::validate_version(
        &version_output,
        &crate::version::codex_requirement(),
    );
    crate::version::log_version_status(&version_status, &crate::version::codex_requirement());
}
```

Note: `discover_codex()` returns a PathBuf. We need to run `--version` ourselves since Codex doesn't have an init() that captures version. Use `tokio::process::Command` directly. If the version command fails, skip validation gracefully (don't block execution).

**For `run_opencode()`:**

Same pattern as Codex -- after `opencode_adapter::discover_opencode()`:

```rust
// Detect version for validation (OBSV-02)
let version_output = tokio::process::Command::new(&path)
    .arg("--version")
    .output()
    .await
    .ok()
    .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
    .unwrap_or_default();

if !version_output.is_empty() {
    let version_status = crate::version::validate_version(
        &version_output,
        &crate::version::opencode_requirement(),
    );
    crate::version::log_version_status(&version_status, &crate::version::opencode_requirement());
}
```

**Important design constraints:**
- Version validation is WARN-ONLY. It MUST NOT return an error or block execution. Even if the version is unsupported, the agent should still attempt to run. The developer sees the warning and can act on it.
- The `--version` calls for Codex and OpenCode add a small latency hit (subprocess spawn). This is acceptable because these happen once per agent execution, not per retry attempt.
- If `--version` fails to execute (CLI binary exists but doesn't support --version), skip validation silently. Do not propagate the error.
- Ensure `tokio::process::Command` is imported or fully qualified (it should already be available since tokio is a dependency).
  </action>
  <verify>
1. `cargo check -p rig-provider` compiles without errors.
2. `cargo test -p rig-provider` passes all tests (existing + new version tests).
3. `cargo clippy -p rig-provider` produces no new warnings.
4. Grep mcp_agent.rs for "validate_version" -- should appear 3 times (once per adapter).
5. Grep mcp_agent.rs for "log_version_status" -- should appear 3 times.
6. Verify no `?` or `.unwrap()` on version validation results (warn-only, no error propagation).
  </verify>
  <done>
Version validation wired into all three adapter paths: run_claude_code uses InitReport.version, run_codex and run_opencode run --version subprocess. All three call validate_version() + log_version_status(). Version check is warn-only, never blocks execution.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` -- full workspace compiles
2. `cargo test --workspace` -- all tests pass
3. `cargo clippy --workspace` -- no new warnings
4. Grep for "validate_version" in mcp_agent.rs (3 occurrences)
5. Grep for "VersionStatus" in version.rs (enum with 4 variants)
6. Grep for "cli_version_validated" in version.rs (info-level success event)
7. Grep for "cli_version_unsupported" in version.rs (warn-level unsupported event)
8. Run `cargo test -p rig-provider -- version` (all version unit tests pass)
</verification>

<success_criteria>
- CLI version is detected for all three adapters during McpToolAgent execution
- Version parsed via semver with graceful fallback on parse failure
- Unsupported versions emit tracing::warn with detected vs required version
- Untested versions emit tracing::warn with detected vs max tested version
- Supported versions emit tracing::info confirming validation
- Unparseable versions emit tracing::warn with raw version string
- Version validation never blocks execution (warn-only)
- All unit tests for version parsing and validation pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-observability-infrastructure/05-02-SUMMARY.md`
</output>
