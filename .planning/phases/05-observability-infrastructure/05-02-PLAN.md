---
phase: 05-observability-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - rig-provider/src/mcp_agent.rs
  - rig-provider/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "CLI tool version is detected via --version at the start of each agent execution"
    - "Version detection warns and continues on unsupported versions (never blocks execution)"
    - "Distinct warning messages for unsupported (below minimum) vs untested (above max_tested) versions"
    - "Version requirements are hardcoded constants per adapter, not developer-configurable"
    - "Version detection is stateless (no caching, runs once per execution)"
  artifacts:
    - path: "rig-provider/src/mcp_agent.rs"
      provides: "Version detection and validation with tracing warnings"
      contains: "semver::Version"
    - path: "rig-provider/Cargo.toml"
      provides: "semver dependency"
      contains: "semver"
  key_links:
    - from: "rig-provider/src/mcp_agent.rs"
      to: "semver crate"
      via: "Version::parse for CLI version strings"
      pattern: "semver::Version::parse"
    - from: "rig-provider/src/mcp_agent.rs"
      to: "tracing crate"
      via: "tracing::warn! for version mismatch warnings"
      pattern: "tracing::warn!"
---

<objective>
Add CLI version detection and validation with semver parsing and structured warnings to the McpToolAgent execution path.

Purpose: Enable CLI tool version awareness (OBSV-02). When a developer runs an MCP tool agent, the system detects the CLI version, validates it against known-good ranges, and emits structured warnings for unsupported or untested versions. This prevents silent failures from CLI version incompatibilities.

Output: Version detection module in mcp_agent.rs, semver dependency in rig-provider, hardcoded version requirements per adapter, tracing warnings on mismatch.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@rig-provider/src/mcp_agent.rs
@rig-provider/Cargo.toml
@claudecode-adapter/src/init.rs
@claudecode-adapter/src/discovery.rs
@codex-adapter/src/discovery.rs
@opencode-adapter/src/discovery.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add semver dependency and implement version detection</name>
  <files>rig-provider/Cargo.toml, rig-provider/src/mcp_agent.rs</files>
  <action>
  **Step 1: Add semver to rig-provider/Cargo.toml**

  Add `semver = "1.0"` to the `[dependencies]` section.

  **Step 2: Define version requirement constants in mcp_agent.rs**

  Near the top of the file (after the existing imports), add a version requirements section. Each adapter has a `VersionRequirement` with min_version (below this = unsupported), max_tested (above this = untested). Use hardcoded constants:

  ```rust
  /// Version requirements for CLI adapters. Hardcoded per adapter, not configurable.
  struct VersionRequirement {
      /// Minimum supported version (below this = unsupported, warn).
      min_version: semver::Version,
      /// Maximum tested version (above this = untested, warn with different message).
      max_tested: semver::Version,
      /// CLI name for log messages.
      cli_name: &'static str,
  }

  /// Version requirement for Claude Code CLI.
  fn claude_code_version_req() -> VersionRequirement {
      VersionRequirement {
          min_version: semver::Version::new(1, 0, 0),
          max_tested: semver::Version::new(1, 99, 0),
          cli_name: "Claude Code",
      }
  }

  /// Version requirement for Codex CLI.
  fn codex_version_req() -> VersionRequirement {
      VersionRequirement {
          min_version: semver::Version::new(0, 1, 0),
          max_tested: semver::Version::new(0, 99, 0),
          cli_name: "Codex",
      }
  }

  /// Version requirement for OpenCode CLI.
  fn opencode_version_req() -> VersionRequirement {
      VersionRequirement {
          min_version: semver::Version::new(0, 1, 0),
          max_tested: semver::Version::new(0, 99, 0),
          cli_name: "OpenCode",
      }
  }
  ```

  Note: The version ranges are intentionally broad for now. As the project hardens adapters in Phases 8-10, these will be tightened to specific tested ranges.

  **Step 3: Implement detect_and_validate_version function**

  Add an async function that runs `<cli_binary> --version`, parses the output with semver, and emits tracing warnings:

  ```rust
  /// Detects CLI version and validates against requirements.
  ///
  /// Runs `<binary> --version`, parses the version string with semver,
  /// and emits structured tracing warnings for unsupported or untested versions.
  /// Always returns Ok — version issues are warnings, never blockers.
  async fn detect_and_validate_version(
      binary_path: &std::path::Path,
      requirement: &VersionRequirement,
  ) {
      let output = match tokio::process::Command::new(binary_path)
          .arg("--version")
          .output()
          .await
      {
          Ok(output) => output,
          Err(e) => {
              tracing::warn!(
                  event = "version_detection_failed",
                  cli = requirement.cli_name,
                  error = %e,
                  "version_detection_failed"
              );
              return;
          }
      };

      let version_str = String::from_utf8_lossy(&output.stdout).trim().to_string();

      // Extract version substring: strip common prefixes like "v", split on whitespace
      // to handle formats like "claude 1.2.3" or "codex v0.91.0"
      let cleaned = extract_version_string(&version_str);

      let version = match semver::Version::parse(&cleaned) {
          Ok(v) => v,
          Err(e) => {
              tracing::warn!(
                  event = "version_parse_failed",
                  cli = requirement.cli_name,
                  raw_version = %version_str,
                  error = %e,
                  "version_parse_failed"
              );
              return;
          }
      };

      tracing::debug!(
          event = "version_detected",
          cli = requirement.cli_name,
          version = %version,
          "version_detected"
      );

      if version < requirement.min_version {
          tracing::warn!(
              event = "version_unsupported",
              cli = requirement.cli_name,
              detected = %version,
              minimum = %requirement.min_version,
              "version_unsupported: {} {} is below minimum supported version {}",
              requirement.cli_name,
              version,
              requirement.min_version,
          );
      } else if version > requirement.max_tested {
          tracing::warn!(
              event = "version_untested",
              cli = requirement.cli_name,
              detected = %version,
              max_tested = %requirement.max_tested,
              "version_untested: {} {} is newer than maximum tested version {}",
              requirement.cli_name,
              version,
              requirement.max_tested,
          );
      }
  }

  /// Extracts a semver-parseable version string from CLI version output.
  ///
  /// Handles common formats:
  /// - "1.2.3" -> "1.2.3"
  /// - "v1.2.3" -> "1.2.3"
  /// - "claude 1.2.3" -> "1.2.3"
  /// - "codex v0.91.0-beta" -> "0.91.0-beta"
  fn extract_version_string(raw: &str) -> String {
      // Split on whitespace and find the token that looks like a version
      for token in raw.split_whitespace() {
          let stripped = token.strip_prefix('v').unwrap_or(token);
          if semver::Version::parse(stripped).is_ok() {
              return stripped.to_string();
          }
      }
      // Fallback: try stripping 'v' from the whole string
      raw.strip_prefix('v').unwrap_or(raw).to_string()
  }
  ```

  **Step 4: Call version detection from each run_* function**

  At the start of each `run_claude_code`, `run_codex`, and `run_opencode` function, add a version detection call. The binary path is already discovered at that point.

  For `run_claude_code`: After `let report = claudecode_adapter::init(None).await...`, add:
  ```rust
  detect_and_validate_version(&report.claude_path, &claude_code_version_req()).await;
  ```

  For `run_codex`: After `let path = codex_adapter::discover_codex()...`, add:
  ```rust
  detect_and_validate_version(&path, &codex_version_req()).await;
  ```

  For `run_opencode`: After `let path = opencode_adapter::discover_opencode()...`, add:
  ```rust
  detect_and_validate_version(&path, &opencode_version_req()).await;
  ```

  **Important constraints:**
  - Version detection happens once per agent execution (stateless, no caching).
  - Version issues WARN and CONTINUE. Never block execution on version mismatch.
  - Version requirements are hardcoded constants, not developer-configurable.
  - Distinct messages: "version_unsupported" (below min) vs "version_untested" (above max_tested).
  - Use tracing::warn! for issues, tracing::debug! for successful detection.
  </action>
  <verify>
  Run `cargo check -p rig-provider` to verify compilation.
  Run `cargo clippy -p rig-provider` to verify no new warnings.
  Grep for `detect_and_validate_version` in mcp_agent.rs to confirm it's called in all 3 run_* functions.
  Grep for `version_unsupported` and `version_untested` to confirm distinct warning messages.
  Grep for `VersionRequirement` to confirm hardcoded constants exist for all 3 adapters.
  </verify>
  <done>
  Version detection runs at the start of each McpToolAgent execution.
  semver crate parses CLI version strings reliably.
  Distinct tracing warnings for unsupported vs untested versions.
  Version requirements are hardcoded per adapter.
  Compilation succeeds with no new clippy warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for version detection</name>
  <files>rig-provider/src/mcp_agent.rs</files>
  <action>
  Add a `#[cfg(test)]` module at the bottom of mcp_agent.rs with tests for the version extraction and validation logic.

  **Test 1: `test_extract_version_string_simple`**
  ```rust
  assert_eq!(extract_version_string("1.2.3"), "1.2.3");
  ```

  **Test 2: `test_extract_version_string_with_v_prefix`**
  ```rust
  assert_eq!(extract_version_string("v1.2.3"), "1.2.3");
  ```

  **Test 3: `test_extract_version_string_with_cli_name`**
  ```rust
  assert_eq!(extract_version_string("claude 1.2.3"), "1.2.3");
  assert_eq!(extract_version_string("codex v0.91.0"), "0.91.0");
  ```

  **Test 4: `test_extract_version_string_with_prerelease`**
  ```rust
  assert_eq!(extract_version_string("v0.91.0-beta.1"), "0.91.0-beta.1");
  ```

  **Test 5: `test_extract_version_string_unparseable_fallback`**
  Test that unparseable strings fall through gracefully:
  ```rust
  // Returns best-effort string even if not valid semver
  let result = extract_version_string("not-a-version");
  assert_eq!(result, "not-a-version");
  ```

  **Test 6: `test_version_requirement_constants`**
  Verify the version requirement functions return sensible values:
  ```rust
  let claude_req = claude_code_version_req();
  assert!(claude_req.min_version < claude_req.max_tested);
  assert_eq!(claude_req.cli_name, "Claude Code");

  let codex_req = codex_version_req();
  assert!(codex_req.min_version < codex_req.max_tested);
  assert_eq!(codex_req.cli_name, "Codex");

  let opencode_req = opencode_version_req();
  assert!(opencode_req.min_version < opencode_req.max_tested);
  assert_eq!(opencode_req.cli_name, "OpenCode");
  ```

  **Test 7: `test_version_comparison_logic`**
  Verify the comparison semantics directly (without tracing):
  ```rust
  let req = claude_code_version_req();
  let below_min = semver::Version::new(0, 0, 1);
  let in_range = semver::Version::new(1, 5, 0);
  let above_max = semver::Version::new(2, 0, 0);

  assert!(below_min < req.min_version);
  assert!(in_range >= req.min_version && in_range <= req.max_tested);
  assert!(above_max > req.max_tested);
  ```
  </action>
  <verify>
  Run `cargo test -p rig-provider` to verify all 7 new tests pass.
  Run `cargo clippy -p rig-provider` to verify no new warnings.
  </verify>
  <done>
  Seven unit tests cover version string extraction and requirement validation.
  Tests pass for: simple versions, v-prefix, CLI name prefix, prerelease, unparseable fallback, requirement constants, comparison logic.
  No new clippy warnings.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p rig-provider` compiles cleanly
2. `cargo test -p rig-provider` — all tests pass (existing + 7 new)
3. `cargo clippy -p rig-provider` — no new warnings
4. `grep "detect_and_validate_version" rig-provider/src/mcp_agent.rs | wc -l` shows 3+ calls (one per adapter)
5. `grep "version_unsupported\|version_untested" rig-provider/src/mcp_agent.rs` shows distinct warning messages
6. `semver` appears in rig-provider/Cargo.toml
7. Version requirements are const functions, not configurable fields
</verification>

<success_criteria>
- CLI version detected via --version at start of each McpToolAgent execution
- semver parsing handles "v" prefix, CLI name prefix, and prerelease tags
- Distinct warnings for unsupported (below min) and untested (above max_tested)
- Never blocks execution on version mismatch
- 7 unit tests pass for version extraction and validation
</success_criteria>

<output>
After completion, create `.planning/phases/05-observability-infrastructure/05-02-SUMMARY.md`
</output>
