---
phase: 05-observability-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp/src/extraction/orchestrator.rs
  - mcp/src/extraction/mod.rs
  - mcp/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Every extraction attempt emits structured tracing events at each stage (prompt_sent, agent_response, validation_result, retry_decision, extraction_outcome)"
    - "Events contain character counts (prompt_chars, output_chars) but never log prompt or response content"
    - "Top-level extract() has #[instrument] span; events use flat attempt=N field, no nested attempt spans"
    - "Elapsed timing (elapsed_ms) appears on completion events and total_duration_ms on extraction_outcome"
    - "Default tracing level is warn-only; happy path produces no output without developer-configured subscriber"
  artifacts:
    - path: "mcp/src/extraction/orchestrator.rs"
      provides: "Instrumented ExtractionOrchestrator with tracing events at all 5 stages"
      contains: "#[instrument]"
    - path: "mcp/Cargo.toml"
      provides: "tracing-subscriber with json and env-filter features"
      contains: "env-filter"
  key_links:
    - from: "mcp/src/extraction/orchestrator.rs"
      to: "tracing crate"
      via: "#[instrument] and tracing::warn!/debug!/trace! macros"
      pattern: "tracing::(warn|debug|trace)!"
---

<objective>
Instrument the ExtractionOrchestrator with structured tracing spans and events at every extraction stage (prompt_sent_to_agent, agent_response_received, validation_result, retry_decision, extraction_outcome).

Purpose: Enable full extraction workflow traceability (OBSV-01). Developers can debug retry loops, track timing, and understand agent behavior through standard RUST_LOG filtering without any prompt/response content leaking into logs.

Output: Instrumented orchestrator.rs with 5-stage event emission, updated Cargo.toml with tracing-subscriber features for downstream consumers.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@mcp/src/extraction/orchestrator.rs
@mcp/src/extraction/mod.rs
@mcp/src/extraction/config.rs
@mcp/src/extraction/error.rs
@mcp/src/extraction/metrics.rs
@mcp/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Cargo.toml and instrument ExtractionOrchestrator</name>
  <files>mcp/Cargo.toml, mcp/src/extraction/orchestrator.rs</files>
  <action>
  **Step 1: Update mcp/Cargo.toml**

  Change the tracing-subscriber dependency to include `json` and `env-filter` features:
  ```toml
  tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
  ```
  This enables downstream consumers (examples, tests) to use JSON-formatted logs and RUST_LOG env filtering.

  **Step 2: Instrument orchestrator.rs**

  Add `#[tracing::instrument]` to the `extract()` method. Use `skip_all` to avoid logging the agent_fn closure and prompts (security-first). Add structured fields for `max_attempts`:

  ```rust
  #[tracing::instrument(
      name = "extraction_orchestrator_extract",
      skip_all,
      fields(max_attempts = self.config.max_attempts)
  )]
  pub async fn extract<F, Fut>(...)
  ```

  Also add `#[tracing::instrument]` to `extract_typed()` with `skip_all`:
  ```rust
  #[tracing::instrument(
      name = "extraction_orchestrator_extract_typed",
      skip_all,
      fields(max_attempts = self.config.max_attempts)
  )]
  pub async fn extract_typed<T, F, Fut>(...)
  ```

  **Step 3: Add 5 tracing events inside extract()**

  All events use snake_case identifiers. Use `tracing::debug!` for per-attempt events and `tracing::warn!` for failure outcomes. Use `tracing::info!` for extraction_outcome on success.

  1. **prompt_sent_to_agent** — After computing current_prompt, before calling agent_fn:
     ```rust
     tracing::debug!(
         event = "prompt_sent_to_agent",
         attempt = attempt,
         prompt_chars = current_prompt.chars().count(),
         "prompt_sent_to_agent"
     );
     ```

  2. **agent_response_received** — After agent_fn returns successfully:
     ```rust
     tracing::debug!(
         event = "agent_response_received",
         attempt = attempt,
         output_chars = agent_output.chars().count(),
         "agent_response_received"
     );
     ```

  3. **validation_result** — After validation check (both success and failure). On success:
     ```rust
     tracing::debug!(
         event = "validation_result",
         attempt = attempt,
         valid = true,
         error_count = 0,
         "validation_result"
     );
     ```
     On failure (after collecting errors):
     ```rust
     tracing::debug!(
         event = "validation_result",
         attempt = attempt,
         valid = false,
         error_count = errors.len(),
         "validation_result"
     );
     ```
     On parse failure:
     ```rust
     tracing::debug!(
         event = "validation_result",
         attempt = attempt,
         valid = false,
         parse_failure = true,
         error_count = 1,
         "validation_result"
     );
     ```

  4. **retry_decision** — When deciding to retry (after recording attempt, before building feedback):
     ```rust
     tracing::debug!(
         event = "retry_decision",
         attempt = attempt,
         remaining_attempts = self.config.max_attempts - attempt,
         will_retry = attempt < self.config.max_attempts,
         "retry_decision"
     );
     ```

  5. **extraction_outcome** — At each return point. On success:
     ```rust
     tracing::info!(
         event = "extraction_outcome",
         success = true,
         total_attempts = attempt,
         total_duration_ms = start.elapsed().as_millis() as u64,
         "extraction_outcome"
     );
     ```
     On MaxRetriesExceeded:
     ```rust
     tracing::warn!(
         event = "extraction_outcome",
         success = false,
         total_attempts = self.config.max_attempts,
         total_duration_ms = start.elapsed().as_millis() as u64,
         "extraction_outcome"
     );
     ```
     On AgentError (in the map_err closure, emit event before the error):
     ```rust
     // Before the map_err, handle agent error with tracing
     let agent_output = match agent_fn(current_prompt.clone()).await {
         Ok(output) => output,
         Err(e) => {
             tracing::warn!(
                 event = "extraction_outcome",
                 success = false,
                 total_attempts = attempt,
                 total_duration_ms = start.elapsed().as_millis() as u64,
                 error_kind = "agent_error",
                 "extraction_outcome"
             );
             return Err(ExtractionError::AgentError(e));
         }
     };
     ```

  **Important constraints:**
  - NEVER log prompt content or response content at any level, not even TRACE. Only log character counts.
  - Use flat events with `attempt=N` field. Do NOT create nested per-attempt spans (avoids async Span::enter() pitfall).
  - Event messages must be snake_case identifiers matching the `event` field value for machine-parseable grep/filter.
  - The `event` field is a string constant for structured log filtering.
  </action>
  <verify>
  Run `cargo check -p rig-mcp-server` to verify compilation.
  Run `cargo test -p rig-mcp-server` to verify existing tests still pass.
  Grep for `tracing::debug!` and `tracing::warn!` and `tracing::info!` in orchestrator.rs to confirm all 5 event types are present.
  Grep to confirm no prompt content or response content appears in tracing calls (only `*_chars` fields should reference content size).
  Verify `#[instrument]` is on both `extract()` and `extract_typed()`.
  </verify>
  <done>
  ExtractionOrchestrator emits structured tracing events at all 5 extraction stages.
  Events contain only character counts, never prompt/response content.
  Top-level spans use #[instrument] with skip_all.
  Existing tests pass unchanged (tracing events are no-ops without subscriber).
  mcp/Cargo.toml includes tracing-subscriber with env-filter and json features.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tracing integration tests</name>
  <files>mcp/src/extraction/orchestrator.rs</files>
  <action>
  Add a `#[cfg(test)]` module at the bottom of orchestrator.rs with tests that verify tracing events are emitted correctly. Use `tracing_subscriber::fmt::TestWriter` or simply verify the orchestrator works with a subscriber attached.

  **Test 1: `test_extract_emits_tracing_events`**
  - Create a simple schema `{"type": "object", "properties": {"name": {"type": "string"}}, "required": ["name"]}`
  - Create an orchestrator with max_attempts=1
  - Use an agent_fn that returns `Ok(r#"{"name": "test"}"#.to_string())`
  - Call extract() and assert it succeeds
  - This test verifies that tracing instrumentation does not break the happy path

  **Test 2: `test_extract_retry_emits_tracing_events`**
  - Create a schema as above
  - Create an orchestrator with max_attempts=2
  - Use a counter (AtomicUsize or similar) in agent_fn:
    - First call returns `Ok(r#"{"name": 123}"#.to_string())` (invalid)
    - Second call returns `Ok(r#"{"name": "fixed"}"#.to_string())` (valid)
  - Call extract() and assert it succeeds with metrics.total_attempts == 2
  - This test verifies retry path with tracing doesn't break

  **Test 3: `test_extract_agent_error_emits_tracing`**
  - Create an orchestrator with max_attempts=1
  - Use an agent_fn that returns `Err("agent failed".to_string())`
  - Call extract() and assert it returns AgentError
  - This test verifies the agent error tracing path

  Use `std::sync::atomic::AtomicUsize` for the counter pattern in Test 2, incrementing with `Ordering::SeqCst`.

  These tests verify the extraction pipeline works correctly with tracing instrumentation attached. They don't assert specific tracing output (that requires test subscriber setup which is out of scope for Phase 5), but they verify no regressions from the instrumentation changes.
  </action>
  <verify>
  Run `cargo test -p rig-mcp-server` and verify all 3 new tests pass.
  Run `cargo test -p rig-mcp-server -- --nocapture` to visually confirm no panics or unexpected output.
  Run `cargo clippy -p rig-mcp-server` to verify no new warnings.
  </verify>
  <done>
  Three tracing integration tests exist and pass in orchestrator.rs.
  Tests cover: happy path with tracing, retry path with tracing, agent error path with tracing.
  No regressions in existing test suite.
  cargo clippy passes without new warnings.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p rig-mcp-server` compiles cleanly
2. `cargo test -p rig-mcp-server` — all tests pass (existing + 3 new)
3. `cargo clippy -p rig-mcp-server` — no new warnings
4. `grep -c "tracing::" mcp/src/extraction/orchestrator.rs` shows multiple tracing calls
5. `grep "event =" mcp/src/extraction/orchestrator.rs` shows all 5 event identifiers: prompt_sent_to_agent, agent_response_received, validation_result, retry_decision, extraction_outcome
6. No prompt content or response content logged (only *_chars fields)
7. `#[instrument]` present on both extract() and extract_typed()
</verification>

<success_criteria>
- ExtractionOrchestrator emits structured tracing at all 5 extraction stages
- Events use snake_case identifiers with structured fields (attempt, *_chars, elapsed_ms, etc.)
- No prompt or response content is ever logged
- tracing-subscriber has json + env-filter features in mcp/Cargo.toml
- All existing and new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-observability-infrastructure/05-01-SUMMARY.md`
</output>
