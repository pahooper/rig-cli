---
phase: 05-observability-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp/Cargo.toml
  - mcp/src/extraction/orchestrator.rs
autonomous: true

must_haves:
  truths:
    - "Extraction orchestrator logs prompt_sent event with prompt length and estimated tokens for each attempt"
    - "Extraction orchestrator logs agent_response_received event with output length for each attempt"
    - "Extraction orchestrator logs validation_passed or validation_failed event with error details"
    - "Extraction orchestrator logs retry_decision event indicating will_retry or max_attempts_reached"
    - "Each extraction session has a top-level span, each attempt has a nested span with attempt number"
    - "RUST_LOG=rig_mcp_server=debug enables all extraction tracing output"
  artifacts:
    - path: "mcp/Cargo.toml"
      provides: "tracing-subscriber with env-filter and json features"
      contains: "env-filter"
    - path: "mcp/src/extraction/orchestrator.rs"
      provides: "Instrumented extraction orchestrator with spans and events"
      contains: "tracing::info_span"
  key_links:
    - from: "mcp/src/extraction/orchestrator.rs"
      to: "tracing"
      via: "#[instrument] macro and explicit span/event calls"
      pattern: "instrument|info_span|tracing::(info|warn|error)"
---

<objective>
Instrument the ExtractionOrchestrator with structured tracing spans and events at every extraction stage.

Purpose: OBSV-01 requires structured tracing logs at every extraction stage (prompt sent, agent response, validation result, retry decisions). The extraction orchestrator is the central retry loop -- instrumenting it makes the entire extraction workflow debuggable via RUST_LOG.

Output: Instrumented orchestrator with hierarchical spans (session > attempt) and structured events at each decision point.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-observability-infrastructure/05-RESEARCH.md

@mcp/Cargo.toml
@mcp/src/extraction/orchestrator.rs
@mcp/src/extraction/metrics.rs
@mcp/src/extraction/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update mcp Cargo.toml tracing-subscriber features</name>
  <files>mcp/Cargo.toml</files>
  <action>
Update the `tracing-subscriber` dependency in mcp/Cargo.toml to include the `env-filter` and `json` features:

```toml
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
```

This enables:
- `env-filter`: RUST_LOG environment variable filtering (e.g., RUST_LOG=rig_mcp_server::extraction=debug)
- `json`: Structured JSON log output for production use

Do NOT add any new crate dependencies. `tracing` 0.1 is already present.
  </action>
  <verify>
Run `cargo check -p rig-mcp-server` -- should compile without errors.
  </verify>
  <done>tracing-subscriber has env-filter and json features enabled in mcp/Cargo.toml</done>
</task>

<task type="auto">
  <name>Task 2: Instrument ExtractionOrchestrator with spans and events</name>
  <files>mcp/src/extraction/orchestrator.rs</files>
  <action>
Add structured tracing instrumentation to the ExtractionOrchestrator. The key patterns from the research:

**CRITICAL: Do NOT use `Span::enter()` across `.await` points.** Use `#[instrument]` on async methods and the `Instrument` trait from `tracing::Instrument` for manual spans in async code. The research explicitly warns about this anti-pattern.

**1. Add imports at the top:**
```rust
use tracing::{info, warn, error, info_span, Instrument};
```

**2. Add `#[instrument]` to `extract()` method:**
```rust
#[tracing::instrument(
    name = "extraction_session",
    skip(self, agent_fn, initial_prompt),
    fields(
        max_attempts = self.config.max_attempts,
        schema_type = "extraction"
    )
)]
```
Skip `agent_fn` (not Debug), `initial_prompt` (potentially large/sensitive), and `self` (internal state).

**3. Inside the `extract()` for loop, create a span per attempt:**
Instead of using `span.enter()` (which is WRONG for async), wrap the attempt body using the `Instrument` trait or restructure so that `.await` calls happen inside an `async` block instrumented with the attempt span.

The correct async pattern is:
```rust
let attempt_span = info_span!(
    "extraction_attempt",
    attempt = attempt,
    max_attempts = self.config.max_attempts,
    is_retry = (attempt > 1)
);
```
Then use `.instrument(attempt_span)` on any async blocks within the attempt, OR since the loop body has `.await` calls, restructure the attempt logic into an async block and instrument it.

**Simpler correct approach:** Since the for loop body has awaits, do NOT use span.enter(). Instead, emit events with the attempt number as a structured field on each event. The top-level `#[instrument]` span on `extract()` provides the session context. Each event includes `attempt = attempt` as a field for correlation.

**4. Add structured events at these points:**

After computing `current_prompt` length, before calling agent_fn:
```rust
info!(
    attempt = attempt,
    prompt_chars = current_prompt.chars().count(),
    estimated_tokens = estimate_tokens(&current_prompt),
    "prompt_sent_to_agent"
);
```

After receiving agent output:
```rust
info!(
    attempt = attempt,
    output_chars = agent_output.chars().count(),
    estimated_tokens = estimate_tokens(&agent_output),
    "agent_response_received"
);
```

On JSON parse failure:
```rust
warn!(
    attempt = attempt,
    error = %e,
    output_preview = %&agent_output[..agent_output.len().min(200)],
    "json_parse_failed"
);
```

On validation success:
```rust
info!(
    attempt = attempt,
    elapsed_ms = start.elapsed().as_millis() as u64,
    total_attempts = attempt,
    "validation_passed"
);
```

On validation failure:
```rust
warn!(
    attempt = attempt,
    error_count = errors.len(),
    errors = ?errors,
    "validation_failed"
);
```

On retry decision (after parse failure or validation failure, when attempt < max):
```rust
info!(
    attempt = attempt,
    attempts_remaining = self.config.max_attempts - attempt,
    "retry_decision: will_retry_with_feedback"
);
```

On max attempts exhausted (final break/return):
```rust
error!(
    total_attempts = self.config.max_attempts,
    elapsed_ms = start.elapsed().as_millis() as u64,
    "extraction_failed: max_attempts_exhausted"
);
```

**5. Add `#[instrument]` to `extract_typed()` as well:**
```rust
#[tracing::instrument(
    name = "extraction_typed",
    skip(self, agent_fn, initial_prompt),
    fields(target_type = std::any::type_name::<T>())
)]
```
And add a `warn!` event on deserialization failure.

**Important notes:**
- Use structured fields (key = value), not string interpolation in messages
- Message strings should be snake_case identifiers (e.g., "prompt_sent_to_agent") for easy grepping
- Do NOT log the full prompt or full agent output (potentially large/sensitive). Log lengths and previews only.
- Do NOT add `use tracing_subscriber` -- that's only needed at initialization time, not in library code.
- The `output_preview` truncation must handle the case where `agent_output` is shorter than 200 chars. Use `agent_output.get(..200).unwrap_or(&agent_output)` or equivalent safe slicing. Be careful: indexing by bytes on a String can panic at non-UTF-8 boundaries. Use `.chars().take(200).collect::<String>()` for safety, or simply use `&agent_output[..agent_output.len().min(200)]` only if you verify the boundary is valid. Safest: just log the length, not a preview. OR use `.chars().take(50).collect::<String>()` as a safe preview.
  </action>
  <verify>
1. `cargo check -p rig-mcp-server` compiles without errors or warnings.
2. `cargo test -p rig-mcp-server` passes all existing tests.
3. `cargo clippy -p rig-mcp-server` produces no new warnings.
4. Grep for "prompt_sent_to_agent", "agent_response_received", "validation_passed", "validation_failed", "retry_decision" in orchestrator.rs to confirm all 5 event types are present.
5. Grep for `Span::enter` or `.enter()` to confirm it is NOT used (async-unsafe pattern).
  </verify>
  <done>
ExtractionOrchestrator::extract() has #[instrument] span, emits structured events at all 5 extraction stages (prompt_sent, agent_response, validation_result, retry_decision, extraction_complete). ExtractionOrchestrator::extract_typed() also instrumented. No Span::enter() used in async context.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p rig-mcp-server` -- compiles clean
2. `cargo test -p rig-mcp-server` -- all tests pass
3. `cargo clippy -p rig-mcp-server` -- no new warnings
4. Grep orchestrator.rs for all 5 event types (prompt_sent_to_agent, agent_response_received, validation_passed, validation_failed, retry_decision)
5. Verify no `Span::enter()` in async context
6. Verify #[instrument] on both extract() and extract_typed()
</verification>

<success_criteria>
- ExtractionOrchestrator::extract() logs structured events at every extraction stage
- Events use structured fields (not string interpolation)
- Span hierarchy: extraction_session (top) contains all attempt events
- RUST_LOG=rig_mcp_server::extraction=debug would show full extraction flow
- No async-unsafe Span::enter() patterns
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-observability-infrastructure/05-01-SUMMARY.md`
</output>
