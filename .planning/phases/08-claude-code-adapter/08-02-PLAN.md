---
phase: 08-claude-code-adapter
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - claudecode-adapter/src/cmd.rs
autonomous: true

must_haves:
  truths:
    - "CLI flag combinations are documented at module level"
    - "Valid and invalid flag combinations are tested"
    - "Version requirements noted for containment flags"
    - "Known limitations documented inline (--strict-mcp-config issue)"
  artifacts:
    - path: "claudecode-adapter/src/cmd.rs"
      provides: "Module-level flag documentation and combination tests"
      contains: "## Flag Combinations"
  key_links:
    - from: "claudecode-adapter/src/cmd.rs"
      to: "Claude CLI --help"
      via: "documented flag reference"
      pattern: "//! ## Flag Combinations"
---

<objective>
Document CLI flag combinations and add tests for valid/invalid combinations.

Purpose: Developers need to understand which flag combinations work together and which conflict. This prevents production issues from untested flag interactions.

Output: Comprehensive module-level documentation and unit tests for flag combinations.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-claude-code-adapter/08-CONTEXT.md
@.planning/phases/08-claude-code-adapter/08-RESEARCH.md
@claudecode-adapter/src/cmd.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add module-level CLI flag documentation</name>
  <files>claudecode-adapter/src/cmd.rs</files>
  <action>
Add comprehensive module-level documentation at the top of cmd.rs:

```rust
//! Command-line argument builder for Claude CLI invocations.
//!
//! ## Flag Reference
//!
//! ### Output Flags
//! - `--print`: Non-interactive mode, returns output directly
//! - `--output-format <format>`: text | json | stream-json
//! - `--model <model>`: Model selection (e.g., claude-sonnet-4)
//!
//! ### System Prompt Flags
//! - `--system-prompt <prompt>`: Replace default system prompt entirely
//! - `--append-system-prompt <prompt>`: Append to default system prompt
//!
//! ### Tool Control Flags (Containment)
//! - `--tools <list>`: Builtin tool set. `""` disables all, `"Bash,Read"` explicit list
//! - `--allowed-tools <list>`: Allowlist of tool names (MCP format: `mcp__server__tool`)
//! - `--disallowed-tools <list>`: Denylist of tool names
//! - `--disable-slash-commands`: Disable interactive slash commands
//!
//! ### MCP Configuration Flags
//! - `--mcp-config <path>`: Load MCP servers from JSON file
//! - `--strict-mcp-config`: Only use MCP servers from --mcp-config (see Known Limitations)
//!
//! ### JSON Schema Flags
//! - `--json-schema <schema>`: Force JSON output matching schema
//!
//! ## Flag Combinations and Compatibility
//!
//! ### Valid Containment Combinations
//! | Combination | Effect |
//! |-------------|--------|
//! | `--tools ""` | Disable all builtin tools |
//! | `--tools "" --allowed-tools mcp__x__y` | MCP-only mode |
//! | `--tools "" --allowed-tools x --strict-mcp-config` | Full containment |
//! | `--tools "" --disable-slash-commands` | No builtins, no slash commands |
//!
//! ### Invalid/Undefined Combinations
//! | Combination | Issue |
//! |-------------|-------|
//! | Multiple `--tools` flags | Last wins (undefined which) |
//! | `--allowed-tools` without MCP | Empty tool set (no tools available) |
//! | `--tools "X"` + `--tools ""` | Conflict, behavior undefined |
//!
//! ## Version Notes
//! - `--strict-mcp-config`: Added ~v0.45.0
//! - `--disable-slash-commands`: Available in current versions
//! - Flag availability varies by CLI version; check `claude --help`
//!
//! ## Known Limitations
//! - `--strict-mcp-config` does not override `disabledMcpServers` in ~/.claude.json
//!   ([GitHub #14490](https://github.com/anthropics/claude-code/issues/14490))
//! - No CLI flag for sandbox/filesystem restriction (containment is tool-based only)
//!
//! ## External References
//! - [Claude CLI Reference](https://docs.anthropic.com/en/docs/claude-code/cli-reference)
```
  </action>
  <verify>
Run: `grep -c "## Flag Combinations" claudecode-adapter/src/cmd.rs` returns 1
  </verify>
  <done>Module-level documentation covers all flags, combinations, and limitations</done>
</task>

<task type="auto">
  <name>Task 2: Add flag combination unit tests</name>
  <files>claudecode-adapter/src/cmd.rs</files>
  <action>
Add new unit tests to the existing `#[cfg(test)] mod tests` section in cmd.rs:

```rust
#[test]
fn test_mcp_only_containment_combination() {
    // Most common containment pattern: MCP tools only, no builtins
    let config = RunConfig {
        tools: ToolPolicy {
            builtin: BuiltinToolSet::None,
            allowed: Some(vec![
                "mcp__rig__submit".to_string(),
                "mcp__rig__validate".to_string(),
            ]),
            disallowed: None,
            disable_slash_commands: true,
        },
        mcp: Some(McpPolicy {
            configs: vec!["mcp.json".to_string()],
            strict: true,
        }),
        ..RunConfig::default()
    };
    let args = build_args("test", &config);
    let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

    // Verify all containment flags present in correct order
    assert!(args_str.windows(2).any(|w| w[0] == "--tools" && w[1] == ""));
    assert!(args_str.windows(2).any(|w| w[0] == "--allowed-tools"
        && w[1] == "mcp__rig__submit,mcp__rig__validate"));
    assert!(args_str.contains(&"--disable-slash-commands"));
    assert!(args_str.contains(&"--strict-mcp-config"));
    assert!(args_str.windows(2).any(|w| w[0] == "--mcp-config" && w[1] == "mcp.json"));
}

#[test]
fn test_explicit_builtin_with_mcp_combination() {
    // Hybrid mode: specific builtins + MCP tools
    let config = RunConfig {
        tools: ToolPolicy {
            builtin: BuiltinToolSet::Explicit(vec!["Read".to_string()]),
            allowed: Some(vec!["mcp__rig__submit".to_string()]),
            disallowed: None,
            disable_slash_commands: false,
        },
        mcp: Some(McpPolicy {
            configs: vec!["mcp.json".to_string()],
            strict: false,
        }),
        ..RunConfig::default()
    };
    let args = build_args("test", &config);
    let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

    // Verify hybrid configuration
    assert!(args_str.windows(2).any(|w| w[0] == "--tools" && w[1] == "Read"));
    assert!(args_str.windows(2).any(|w| w[0] == "--allowed-tools" && w[1] == "mcp__rig__submit"));
    assert!(!args_str.contains(&"--disable-slash-commands")); // Not set
    assert!(!args_str.contains(&"--strict-mcp-config")); // Not strict
}

#[test]
fn test_system_prompt_modes_exclusive() {
    // Replace mode
    let config_replace = RunConfig {
        system_prompt: SystemPromptMode::Replace("Custom system".to_string()),
        ..RunConfig::default()
    };
    let args_replace = build_args("test", &config_replace);
    let args_str: Vec<&str> = args_replace.iter().filter_map(|s| s.to_str()).collect();
    assert!(args_str.windows(2).any(|w| w[0] == "--system-prompt" && w[1] == "Custom system"));
    assert!(!args_str.contains(&"--append-system-prompt"));

    // Append mode
    let config_append = RunConfig {
        system_prompt: SystemPromptMode::Append("Extra context".to_string()),
        ..RunConfig::default()
    };
    let args_append = build_args("test", &config_append);
    let args_str: Vec<&str> = args_append.iter().filter_map(|s| s.to_str()).collect();
    assert!(args_str.windows(2).any(|w| w[0] == "--append-system-prompt" && w[1] == "Extra context"));
    assert!(!args_str.contains(&"--system-prompt"));
}

#[test]
fn test_multiple_mcp_configs() {
    // Multiple MCP config files
    let config = RunConfig {
        mcp: Some(McpPolicy {
            configs: vec!["primary.json".to_string(), "secondary.json".to_string()],
            strict: true,
        }),
        ..RunConfig::default()
    };
    let args = build_args("test", &config);
    let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

    // Both configs should be present with separate --mcp-config flags
    let mcp_configs: Vec<_> = args_str.windows(2)
        .filter(|w| w[0] == "--mcp-config")
        .map(|w| w[1])
        .collect();
    assert_eq!(mcp_configs.len(), 2);
    assert!(mcp_configs.contains(&"primary.json"));
    assert!(mcp_configs.contains(&"secondary.json"));
}

#[test]
fn test_json_schema_inline() {
    let config = RunConfig {
        json_schema: JsonSchema::Inline(r#"{"type":"object"}"#.to_string()),
        ..RunConfig::default()
    };
    let args = build_args("test", &config);
    let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

    assert!(args_str.windows(2).any(|w| w[0] == "--json-schema" && w[1] == r#"{"type":"object"}"#));
}

#[test]
fn test_disallowed_tools_flag() {
    let config = RunConfig {
        tools: ToolPolicy {
            builtin: BuiltinToolSet::Default,
            allowed: None,
            disallowed: Some(vec!["Bash".to_string(), "Write".to_string()]),
            disable_slash_commands: false,
        },
        ..RunConfig::default()
    };
    let args = build_args("test", &config);
    let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

    assert!(args_str.windows(2).any(|w| w[0] == "--disallowed-tools" && w[1] == "Bash,Write"));
}

#[test]
fn test_default_config_minimal_args() {
    // Default config should generate minimal args (just --print and prompt)
    let config = RunConfig::default();
    let args = build_args("test prompt", &config);
    let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

    assert_eq!(args_str.len(), 2); // --print, prompt
    assert_eq!(args_str[0], "--print");
    assert_eq!(args_str[1], "test prompt");
}
```
  </action>
  <verify>
Run: `cargo test -p claudecode-adapter` passes with all new tests
  </verify>
  <done>8 new unit tests covering flag combinations, 14 total tests in cmd.rs</done>
</task>

</tasks>

<verification>
Run all claudecode-adapter tests:
```bash
cargo test -p claudecode-adapter -- --nocapture
```

Verify documentation rendered:
```bash
cargo doc -p claudecode-adapter --open
```
Navigate to cmd module and verify Flag Combinations section renders correctly.
</verification>

<success_criteria>
- [ ] Module-level documentation covers all CLI flags
- [ ] Valid and invalid flag combinations documented in table format
- [ ] Version notes and known limitations documented
- [ ] External reference links included
- [ ] 8 new flag combination unit tests pass
- [ ] Tests cover: MCP-only, hybrid, system prompt modes, multiple configs, disallowed tools, minimal args
</success_criteria>

<output>
After completion, create `.planning/phases/08-claude-code-adapter/08-02-SUMMARY.md`
</output>
