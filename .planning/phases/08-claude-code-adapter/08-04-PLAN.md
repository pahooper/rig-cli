---
phase: 08-claude-code-adapter
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - mcp/src/extraction/orchestrator.rs
autonomous: true

must_haves:
  truths:
    - "Extraction failure tests cover all error modes"
    - "MaxRetriesExceeded includes complete attempt history"
    - "Parse failures count against retry budget"
    - "Tests validate error types and content, not just failure"
  artifacts:
    - path: "mcp/src/extraction/orchestrator.rs"
      provides: "Comprehensive extraction failure tests"
      contains: "test_extraction_max_retries_complete_history"
  key_links:
    - from: "mcp/src/extraction/orchestrator.rs"
      to: "ExtractionError variants"
      via: "test assertions"
      pattern: "ExtractionError::"
---

<objective>
Add comprehensive extraction failure tests covering all error modes.

Purpose: The extraction retry loop is critical infrastructure. Tests must verify all failure paths return correct error types with complete diagnostic information.

Output: 5 new extraction failure tests covering max retries, parse errors, schema violations, and attempt history.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-claude-code-adapter/08-CONTEXT.md
@.planning/phases/08-claude-code-adapter/08-RESEARCH.md
@mcp/src/extraction/orchestrator.rs
@mcp/src/extraction/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add max retries exhaustion tests</name>
  <files>mcp/src/extraction/orchestrator.rs</files>
  <action>
Add new tests to the `#[cfg(test)] mod tests` section in orchestrator.rs:

```rust
#[tokio::test]
async fn test_extraction_max_retries_complete_history() {
    // Test that MaxRetriesExceeded contains complete attempt history
    let schema = json!({
        "type": "object",
        "properties": {
            "name": {"type": "string"},
            "age": {"type": "integer", "minimum": 0}
        },
        "required": ["name", "age"]
    });

    let orchestrator = ExtractionOrchestrator::new(schema).max_attempts(3);

    let counter = Arc::new(AtomicUsize::new(0));
    let counter_clone = counter.clone();

    let agent_fn = move |_prompt: String| {
        let counter = counter_clone.clone();
        async move {
            let count = counter.fetch_add(1, Ordering::SeqCst);
            // Return different invalid JSONs each attempt for history verification
            match count {
                0 => Ok(r#"{"name": "test"}"#.to_string()), // Missing age
                1 => Ok(r#"{"name": 123, "age": 25}"#.to_string()), // Wrong name type
                _ => Ok(r#"{"name": "test", "age": -5}"#.to_string()), // Negative age
            }
        }
    };

    let result = orchestrator.extract(agent_fn, "initial".to_string()).await;

    match result {
        Err(ExtractionError::MaxRetriesExceeded {
            attempts,
            max_attempts,
            history,
            metrics,
            ..
        }) => {
            assert_eq!(attempts, 3, "Should report 3 attempts");
            assert_eq!(max_attempts, 3, "Should report max_attempts=3");
            assert_eq!(history.len(), 3, "History should contain all 3 attempts");

            // Verify each attempt record
            for (i, record) in history.iter().enumerate() {
                assert_eq!(record.attempt_number, i + 1, "Attempt number mismatch");
                assert!(!record.validation_errors.is_empty(), "Should have validation errors");
                assert!(!record.raw_agent_output.is_empty(), "Should capture raw output");
            }

            // Verify metrics
            assert_eq!(metrics.total_attempts, 3);
            assert!(metrics.wall_time.as_millis() > 0);
        }
        Ok(_) => panic!("Expected MaxRetriesExceeded error"),
        Err(e) => panic!("Unexpected error: {e:?}"),
    }
}

#[tokio::test]
async fn test_extraction_parse_failure_counts_against_budget() {
    // Test that JSON parse failures count against retry budget
    let schema = json!({"type": "object", "properties": {"x": {"type": "number"}}});

    let orchestrator = ExtractionOrchestrator::new(schema).max_attempts(2);

    let counter = Arc::new(AtomicUsize::new(0));
    let counter_clone = counter.clone();

    let agent_fn = move |_prompt: String| {
        let counter = counter_clone.clone();
        async move {
            let count = counter.fetch_add(1, Ordering::SeqCst);
            match count {
                0 => Ok("not valid json at all".to_string()), // Parse failure
                _ => Ok(r#"{"x": "string"}"#.to_string()), // Valid JSON but wrong type
            }
        }
    };

    let result = orchestrator.extract(agent_fn, "initial".to_string()).await;

    match result {
        Err(ExtractionError::MaxRetriesExceeded { history, .. }) => {
            assert_eq!(history.len(), 2, "Both attempts should be recorded");

            // First attempt: parse failure
            assert!(
                history[0].validation_errors[0].contains("JSON parse error"),
                "First attempt should be parse error: {:?}",
                history[0].validation_errors
            );
            assert_eq!(history[0].submitted_json, serde_json::Value::Null);

            // Second attempt: validation failure
            assert!(
                !history[1].validation_errors[0].contains("JSON parse error"),
                "Second attempt should be validation error"
            );
        }
        Ok(_) => panic!("Expected MaxRetriesExceeded"),
        Err(e) => panic!("Unexpected error: {e:?}"),
    }
}
```
  </action>
  <verify>
Run: `cargo test -p rig-mcp-server test_extraction_max_retries` passes
  </verify>
  <done>2 tests added: max_retries_complete_history, parse_failure_counts_against_budget</done>
</task>

<task type="auto">
  <name>Task 2: Add schema violation and edge case tests</name>
  <files>mcp/src/extraction/orchestrator.rs</files>
  <action>
Add more tests to orchestrator.rs tests module:

```rust
#[tokio::test]
async fn test_extraction_schema_violation_detailed_errors() {
    // Test that schema violations produce detailed error messages
    let schema = json!({
        "type": "object",
        "properties": {
            "email": {
                "type": "string",
                "format": "email"
            },
            "count": {
                "type": "integer",
                "minimum": 1,
                "maximum": 100
            }
        },
        "required": ["email", "count"]
    });

    let orchestrator = ExtractionOrchestrator::new(schema).max_attempts(1);

    let agent_fn = |_prompt: String| async {
        // Multiple violations: missing email, count out of range
        Ok(r#"{"count": 999}"#.to_string())
    };

    let result = orchestrator.extract(agent_fn, "initial".to_string()).await;

    match result {
        Err(ExtractionError::MaxRetriesExceeded { history, .. }) => {
            let errors = &history[0].validation_errors;

            // Should have at least 2 errors (missing email, count > 100)
            assert!(
                errors.len() >= 2,
                "Should have multiple validation errors: {errors:?}"
            );

            // Check error messages mention the failing properties
            let combined = errors.join(" ");
            assert!(
                combined.contains("email") || combined.contains("required"),
                "Should mention missing email"
            );
            assert!(
                combined.contains("count") || combined.contains("maximum"),
                "Should mention count violation"
            );
        }
        Ok(_) => panic!("Expected validation failure"),
        Err(e) => panic!("Unexpected error: {e:?}"),
    }
}

#[tokio::test]
async fn test_extraction_first_attempt_success() {
    // Test happy path: first attempt succeeds
    let schema = json!({
        "type": "object",
        "properties": {"value": {"type": "string"}},
        "required": ["value"]
    });

    let orchestrator = ExtractionOrchestrator::new(schema).max_attempts(3);

    let agent_fn = |_prompt: String| async {
        Ok(r#"{"value": "success"}"#.to_string())
    };

    let result = orchestrator.extract(agent_fn, "initial".to_string()).await;

    match result {
        Ok((value, metrics)) => {
            assert_eq!(value["value"], "success");
            assert_eq!(metrics.total_attempts, 1, "Should succeed on first attempt");
        }
        Err(e) => panic!("Expected success: {e:?}"),
    }
}

#[tokio::test]
async fn test_extraction_invalid_schema_early_error() {
    // Test that invalid schema fails immediately (not after attempts)
    let invalid_schema = json!({
        "type": "invalid_type_that_doesnt_exist"
    });

    let orchestrator = ExtractionOrchestrator::new(invalid_schema).max_attempts(3);

    let call_count = Arc::new(AtomicUsize::new(0));
    let call_count_clone = call_count.clone();

    let agent_fn = move |_prompt: String| {
        let count = call_count_clone.clone();
        async move {
            count.fetch_add(1, Ordering::SeqCst);
            Ok(r#"{"anything": true}"#.to_string())
        }
    };

    let result = orchestrator.extract(agent_fn, "initial".to_string()).await;

    // Note: jsonschema may or may not reject invalid types depending on version
    // This test validates the schema validation path exists
    match result {
        Err(ExtractionError::SchemaError(msg)) => {
            assert!(msg.len() > 0, "Should have error message");
            assert_eq!(call_count.load(Ordering::SeqCst), 0, "Agent should not be called");
        }
        Ok((_, metrics)) => {
            // If jsonschema accepts invalid type, that's fine - schema is permissive
            eprintln!("Note: jsonschema accepted invalid type (permissive mode)");
            assert!(metrics.total_attempts >= 1);
        }
        Err(e) => {
            eprintln!("Different error type: {e:?}");
        }
    }
}

#[tokio::test]
async fn test_extraction_agent_error_immediate_failure() {
    // Test that agent errors fail immediately without retry
    let schema = json!({"type": "object"});

    let orchestrator = ExtractionOrchestrator::new(schema).max_attempts(3);

    let call_count = Arc::new(AtomicUsize::new(0));
    let call_count_clone = call_count.clone();

    let agent_fn = move |_prompt: String| {
        let count = call_count_clone.clone();
        async move {
            count.fetch_add(1, Ordering::SeqCst);
            Err("Agent connection failed".to_string())
        }
    };

    let result = orchestrator.extract(agent_fn, "initial".to_string()).await;

    match result {
        Err(ExtractionError::AgentError(msg)) => {
            assert_eq!(msg, "Agent connection failed");
            assert_eq!(
                call_count.load(Ordering::SeqCst),
                1,
                "Agent errors should fail immediately without retry"
            );
        }
        Ok(_) => panic!("Expected AgentError"),
        Err(e) => panic!("Unexpected error type: {e:?}"),
    }
}
```
  </action>
  <verify>
Run: `cargo test -p rig-mcp-server orchestrator` passes all tests
  </verify>
  <done>4 more tests added: schema_violation_detailed_errors, first_attempt_success, invalid_schema_early_error, agent_error_immediate_failure</done>
</task>

<task type="auto">
  <name>Task 3: Verify all extraction tests pass</name>
  <files>mcp/src/extraction/orchestrator.rs</files>
  <action>
Run all extraction orchestrator tests to verify they pass:

```bash
cargo test -p rig-mcp-server -- orchestrator --nocapture
```

Expected tests (8 total):
1. test_extract_emits_tracing_events (existing)
2. test_extract_retry_emits_tracing_events (existing)
3. test_extract_agent_error_emits_tracing (existing)
4. test_extraction_max_retries_complete_history (new)
5. test_extraction_parse_failure_counts_against_budget (new)
6. test_extraction_schema_violation_detailed_errors (new)
7. test_extraction_first_attempt_success (new)
8. test_extraction_invalid_schema_early_error (new)
9. test_extraction_agent_error_immediate_failure (new)

Verify test output shows correct behavior for each failure mode.
  </action>
  <verify>
Run: `cargo test -p rig-mcp-server -- orchestrator 2>&1 | grep -E "test.*ok|test.*FAILED" | wc -l` returns 9 (all tests run)
Run: `cargo test -p rig-mcp-server -- orchestrator` all tests pass
  </verify>
  <done>All 9 extraction orchestrator tests pass</done>
</task>

</tasks>

<verification>
Run all extraction tests:
```bash
cargo test -p rig-mcp-server -- orchestrator --nocapture
```

Verify test coverage of error modes:
- MaxRetriesExceeded with full history
- Parse failures counting against budget
- Schema validation with detailed errors
- Happy path (first attempt success)
- Invalid schema early failure
- Agent error immediate failure
</verification>

<success_criteria>
- [ ] 6 new tests added to orchestrator.rs (9 total)
- [ ] MaxRetriesExceeded includes complete attempt history in tests
- [ ] Parse failures verified to count against retry budget
- [ ] Schema violations produce detailed error messages
- [ ] Agent errors fail immediately without retry
- [ ] All tests pass with `cargo test -p rig-mcp-server`
</success_criteria>

<output>
After completion, create `.planning/phases/08-claude-code-adapter/08-04-SUMMARY.md`
</output>
