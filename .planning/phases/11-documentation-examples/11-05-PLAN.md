---
phase: 11-documentation-examples
plan: 05
type: execute
wave: 3
depends_on: ["11-02", "11-03", "11-04"]
files_modified:
  - rig-cli/examples/error_handling.rs
autonomous: true

must_haves:
  truths:
    - "Developer can run error_handling example to see error recovery patterns"
    - "All doc tests pass across workspace"
    - "All examples compile without warnings"
    - "README links to all 9 examples"
  artifacts:
    - path: "rig-cli/examples/error_handling.rs"
      provides: "Error handling patterns"
      contains: "retry exhaustion"
    - path: "README.md"
      provides: "Updated example links"
      contains: "error_handling.rs"
  key_links:
    - from: "README.md"
      to: "rig-cli/examples/"
      via: "example links"
      pattern: "examples/.*\\.rs"
---

<objective>
Create error handling example and perform final documentation verification across the workspace.

Purpose: Complete the example suite with an error handling example showing retry exhaustion, parse failures, and timeout scenarios. Verify all documentation is consistent and all examples compile.

Output: error_handling.rs example + verified documentation suite.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-documentation-examples/11-CONTEXT.md
@.planning/phases/11-documentation-examples/11-RESEARCH.md
@rig-cli/src/lib.rs
@README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error_handling.rs example</name>
  <files>rig-cli/examples/error_handling.rs</files>
  <action>
Create dedicated error handling example showing:
1. Retry exhaustion handling
2. Parse failure handling
3. Timeout handling

```rust
//! Example: Error handling
//!
//! Demonstrates error handling patterns for common failure scenarios:
//! - Retry exhaustion (max attempts exceeded)
//! - Parse failures (malformed agent responses)
//! - Timeout handling (agent takes too long)
//!
//! These patterns ensure graceful degradation in production.
//!
//! Run: `cargo run -p rig-cli --example error_handling`

use rig::tool::ToolSet;
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::time::Duration;

/// Simple response for testing
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct SimpleResponse {
    message: String,
}

fn build_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<SimpleResponse>::builder()
        .example(SimpleResponse {
            message: "Hello".to_string(),
        })
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    // --- KEY CODE: Error handling patterns ---

    // 1. Timeout handling
    println!("=== Pattern 1: Timeout Handling ===");
    demonstrate_timeout().await;

    // 2. Client initialization failure
    println!("\n=== Pattern 2: CLI Not Found ===");
    demonstrate_cli_not_found().await;

    // 3. Graceful error recovery
    println!("\n=== Pattern 3: Graceful Recovery ===");
    demonstrate_graceful_recovery().await?;

    // --- END KEY CODE ---

    Ok(())
}

/// Demonstrates handling timeout errors
async fn demonstrate_timeout() {
    // Create client with very short timeout to trigger timeout error
    let config = rig_cli::config::ClientConfig {
        timeout: Duration::from_millis(1), // Unrealistically short
        ..Default::default()
    };

    match rig_cli::claude::Client::from_config(config).await {
        Ok(client) => {
            let agent = client.mcp_agent("sonnet")
                .toolset(build_toolset())
                .build();

            match agent {
                Ok(agent) => {
                    match agent.prompt("Hello").await {
                        Ok(result) => println!("Success: {}", result.raw_output),
                        Err(e) => {
                            // --- KEY CODE: Timeout error handling ---
                            println!("Expected timeout error: {}", e);
                            // In production: log, retry with backoff, or return fallback
                            // --- END KEY CODE ---
                        }
                    }
                }
                Err(e) => println!("Agent build error: {}", e),
            }
        }
        Err(e) => println!("Client error: {}", e),
    }
}

/// Demonstrates handling CLI not found errors
async fn demonstrate_cli_not_found() {
    // Create config pointing to non-existent binary
    let config = rig_cli::config::ClientConfig {
        binary_path: Some("/nonexistent/claude".into()),
        ..Default::default()
    };

    match rig_cli::claude::Client::from_config(config).await {
        Ok(_) => println!("Unexpected success"),
        Err(e) => {
            // --- KEY CODE: CLI not found handling ---
            match &e {
                rig_cli::errors::Error::ClaudeNotFound => {
                    println!("Claude CLI not found. Install with:");
                    println!("  npm install -g @anthropic-ai/claude-code");
                }
                other => println!("Other error: {}", other),
            }
            // --- END KEY CODE ---
        }
    }
}

/// Demonstrates graceful error recovery
async fn demonstrate_graceful_recovery() -> Result<(), Box<dyn std::error::Error>> {
    let client = rig_cli::claude::Client::new().await?;

    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .build()?;

    // --- KEY CODE: Graceful recovery pattern ---
    let result = match agent.prompt("Say hello").await {
        Ok(result) => {
            println!("Success: {}", result.raw_output);
            result.raw_output
        }
        Err(e) => {
            // Log the error
            eprintln!("Agent error: {}. Using fallback.", e);

            // Return fallback value
            r#"{"message": "Service temporarily unavailable"}"#.to_string()
        }
    };

    // Parse with fallback
    let response: SimpleResponse = serde_json::from_str(&result)
        .unwrap_or(SimpleResponse {
            message: "Parse error fallback".to_string(),
        });

    println!("Final response: {:?}", response);
    // --- END KEY CODE ---

    Ok(())
}
```
  </action>
  <verify>
- `cargo build -p rig-cli --example error_handling` succeeds
- Example contains all three error patterns
- Example has "KEY CODE" sections
  </verify>
  <done>error_handling.rs example compiles and demonstrates all error handling patterns</done>
</task>

<task type="auto">
  <name>Task 2: Update README with complete example links</name>
  <files>README.md</files>
  <action>
Update the Examples section in README.md to include all 9 examples with descriptions:

```markdown
## Examples

See the `rig-cli/examples/` directory for complete working examples:

| Example | Description |
|---------|-------------|
| [chat_mcp.rs](rig-cli/examples/chat_mcp.rs) | Multi-turn conversation with MCP tools |
| [one_shot_mcp.rs](rig-cli/examples/one_shot_mcp.rs) | Single prompt with structured response |
| [agent_mcp.rs](rig-cli/examples/agent_mcp.rs) | Standard 3-tool pattern (example/validate/submit) |
| [agent_extra_tools.rs](rig-cli/examples/agent_extra_tools.rs) | 3-tool pattern with custom tools |
| [multiagent.rs](rig-cli/examples/multiagent.rs) | Multiple agents coordinating |
| [extraction.rs](rig-cli/examples/extraction.rs) | Structured data extraction from text |
| [payload_chat.rs](rig-cli/examples/payload_chat.rs) | File content analysis via payload |
| [mcp_deterministic.rs](rig-cli/examples/mcp_deterministic.rs) | MCP + deterministic date tool |
| [error_handling.rs](rig-cli/examples/error_handling.rs) | Error recovery patterns |

Run any example with:
\`\`\`bash
cargo run -p rig-cli --example <example_name>
\`\`\`
```

Ensure:
- All 9 examples are listed
- Each has accurate one-line description
- Paths use `rig-cli/examples/` format
- Run command is included
  </action>
  <verify>
- `grep -c "examples/" README.md` returns at least 9
- All 9 example filenames appear in README.md
  </verify>
  <done>README.md contains links to all 9 examples with descriptions</done>
</task>

<task type="auto">
  <name>Task 3: Final documentation verification</name>
  <files>None (verification only)</files>
  <action>
Run comprehensive verification checks:

1. **Build all examples:**
   ```bash
   cargo build -p rig-cli --examples
   ```
   Should complete with zero errors.

2. **Run all doc tests:**
   ```bash
   cargo test --workspace --doc
   ```
   Should pass all doc tests.

3. **Build docs:**
   ```bash
   cargo doc --workspace --no-deps
   ```
   Should complete with zero warnings.

4. **Verify missing_docs lint coverage:**
   ```bash
   grep -r "warn(missing_docs)\|deny(missing_docs)" --include="*.rs" */src/lib.rs
   ```
   Should list all 6 crate lib.rs files.

5. **Verify README structure:**
   - Has "What are CLI Agents?" section
   - Has "Quick Start" section
   - Has "Adapter Comparison" table
   - Has "Examples" section with 9 links

6. **Verify no obsolete references:**
   ```bash
   grep -c "rig-provider" README.md
   ```
   Should return 0 (no references to internal crate).

Create verification checklist:
- [ ] All 9 examples compile
- [ ] All doc tests pass
- [ ] Zero doc warnings
- [ ] All crates have missing_docs lint
- [ ] README has all required sections
- [ ] No obsolete references
  </action>
  <verify>
- `cargo build -p rig-cli --examples` succeeds
- `cargo test --workspace --doc` passes
- `cargo doc --workspace --no-deps 2>&1 | grep -c warning` returns 0
  </verify>
  <done>All documentation verification checks pass</done>
</task>

</tasks>

<verification>
1. All 9 examples compile without warnings
2. All doc tests pass
3. Zero documentation warnings across workspace
4. README contains all required sections and example links
5. No obsolete architecture references remain
</verification>

<success_criteria>
- error_handling.rs example created and compiles
- README updated with all 9 example links
- `cargo test --workspace --doc` passes
- `cargo doc --workspace --no-deps` has zero warnings
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-documentation-examples/11-05-SUMMARY.md`
</output>
