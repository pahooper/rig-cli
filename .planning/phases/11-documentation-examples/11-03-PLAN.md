---
phase: 11-documentation-examples
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - rig-cli/examples/chat_mcp.rs
  - rig-cli/examples/one_shot_mcp.rs
  - rig-cli/examples/agent_mcp.rs
  - rig-cli/examples/agent_extra_tools.rs
  - rig-cli/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Developer can run chat_mcp example for multi-turn conversation"
    - "Developer can run one_shot_mcp example for single prompt"
    - "Developer can run agent_mcp example for 3-tool pattern"
    - "Developer can run agent_extra_tools example with custom tools"
  artifacts:
    - path: "rig-cli/examples/chat_mcp.rs"
      provides: "Multi-turn conversation with MCP"
      contains: "multi-turn"
    - path: "rig-cli/examples/one_shot_mcp.rs"
      provides: "Single prompt MCP example"
      contains: "one-shot"
    - path: "rig-cli/examples/agent_mcp.rs"
      provides: "3-tool pattern example"
      contains: "submit"
    - path: "rig-cli/examples/agent_extra_tools.rs"
      provides: "Custom tools example"
      contains: "DateExtractor"
  key_links:
    - from: "rig-cli/examples/*.rs"
      to: "rig_cli::claude::Client"
      via: "use statement"
      pattern: "use rig_cli::claude::Client"
---

<objective>
Create the first four user story examples demonstrating core MCP agent workflows: chat with sessions, one-shot prompts, standard 3-tool pattern, and custom tools integration.

Purpose: These examples represent real developer workflows (per CONTEXT.md). Each is self-contained, copy-paste friendly, with full main() and highlighted "key code" sections.

Output: Four new example files in rig-cli/examples/ directory, each demonstrating a distinct MCP agent pattern.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-documentation-examples/11-CONTEXT.md
@.planning/phases/11-documentation-examples/11-RESEARCH.md
@rig-cli/src/lib.rs
@rig-cli/src/claude.rs
@rig-provider/examples/mcp_tool_agent_e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat_mcp.rs and one_shot_mcp.rs examples</name>
  <files>
rig-cli/examples/chat_mcp.rs
rig-cli/examples/one_shot_mcp.rs
rig-cli/Cargo.toml
  </files>
  <action>
First, ensure rig-cli/Cargo.toml has [[example]] entries (add if missing).

**chat_mcp.rs** - Multi-turn conversation with MCP tool responses:

```rust
//! Example: Chat with MCP and sessions
//!
//! Demonstrates multi-turn conversation where the agent uses MCP tools
//! to respond, maintaining context across turns.
//!
//! Run: `cargo run -p rig-cli --example chat_mcp`

use rig::tool::ToolSet;
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

// Define the structured response type
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct ChatResponse {
    message: String,
    sentiment: String,  // "positive", "neutral", "negative"
}

fn build_toolset() -> ToolSet {
    // --- KEY CODE: Build extraction toolkit ---
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<ChatResponse>::builder()
        .example(ChatResponse {
            message: "Hello! How can I help?".to_string(),
            sentiment: "positive".to_string(),
        })
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
    // --- END KEY CODE ---
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // MCP server mode (env var detection)
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    // --- KEY CODE: Multi-turn chat ---
    let client = rig_cli::claude::Client::new().await?;

    // First turn
    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble("Respond with structured sentiment analysis")
        .build()?;

    println!("Turn 1: Greeting");
    let response1 = agent.prompt("Hello, I'm excited to try this!").await?;
    println!("Response: {}", response1.raw_output);

    // Second turn (new agent instance, demonstrating pattern)
    let agent2 = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble("Respond with structured sentiment analysis")
        .build()?;

    println!("\nTurn 2: Follow-up");
    let response2 = agent2.prompt("This is frustrating, it's not working").await?;
    println!("Response: {}", response2.raw_output);
    // --- END KEY CODE ---

    Ok(())
}
```

**one_shot_mcp.rs** - Single prompt with structured MCP response:

```rust
//! Example: One-shot with MCP
//!
//! Demonstrates single prompt that returns structured data via MCP.
//! The simplest MCP pattern - one question, one structured answer.
//!
//! Run: `cargo run -p rig-cli --example one_shot_mcp`

use rig::tool::ToolSet;
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct WeatherInfo {
    location: String,
    temperature_f: i32,
    conditions: String,
}

fn build_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<WeatherInfo>::builder()
        .example(WeatherInfo {
            location: "San Francisco, CA".to_string(),
            temperature_f: 65,
            conditions: "Partly cloudy".to_string(),
        })
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    // --- KEY CODE: One-shot MCP extraction ---
    let client = rig_cli::claude::Client::new().await?;

    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .build()?;

    let result = agent.prompt(
        "What's the weather like in Seattle today? Make up realistic data."
    ).await?;

    println!("Extracted weather info:\n{}", result.raw_output);
    // --- END KEY CODE ---

    Ok(())
}
```

Add [[example]] entries to rig-cli/Cargo.toml if not present.
  </action>
  <verify>
- `cargo build -p rig-cli --example chat_mcp` succeeds
- `cargo build -p rig-cli --example one_shot_mcp` succeeds
- Both files contain "KEY CODE" markers
  </verify>
  <done>chat_mcp.rs and one_shot_mcp.rs examples compile and demonstrate multi-turn and one-shot patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create agent_mcp.rs and agent_extra_tools.rs examples</name>
  <files>
rig-cli/examples/agent_mcp.rs
rig-cli/examples/agent_extra_tools.rs
  </files>
  <action>
**agent_mcp.rs** - Standard 3-tool pattern (example/validate/submit):

```rust
//! Example: Agent with MCP
//!
//! Demonstrates the standard 3-tool pattern for structured extraction:
//! 1. `json_example` - Shows expected output format
//! 2. `validate_json` - Validates submission before final
//! 3. `submit` - Submits the final validated result
//!
//! This is the recommended pattern for reliable structured extraction.
//!
//! Run: `cargo run -p rig-cli --example agent_mcp`

use rig::tool::ToolSet;
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Movie review structure for extraction
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct MovieReview {
    /// Title of the movie
    title: String,
    /// Rating from 1 to 10
    rating: u8,
    /// Brief summary in 1-2 sentences
    summary: String,
    /// List of genres
    genres: Vec<String>,
}

fn build_toolset() -> ToolSet {
    // --- KEY CODE: 3-tool pattern setup ---
    let mut toolset = ToolSet::default();

    // JsonSchemaToolkit creates all three tools from a single type
    let (submit, validate, example) = JsonSchemaToolkit::<MovieReview>::builder()
        .example(MovieReview {
            title: "The Matrix".to_string(),
            rating: 9,
            summary: "A hacker discovers reality is a simulation.".to_string(),
            genres: vec!["Sci-Fi".to_string(), "Action".to_string()],
        })
        .success_message("Review submitted successfully!")
        .build()
        .build_tools();

    // Add all three tools to the toolset
    toolset.add_tool(submit);   // Final submission
    toolset.add_tool(validate); // Pre-submission validation
    toolset.add_tool(example);  // Format reference
    toolset
    // --- END KEY CODE ---
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    let client = rig_cli::claude::Client::new().await?;

    // --- KEY CODE: Agent with workflow guidance ---
    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble(
            "You are a movie review extractor. \
             Use json_example to see the format, validate_json to check, \
             then submit your final review."
        )
        .build()?;

    let result = agent.prompt(
        "Create a review for Inception (2010) by Christopher Nolan"
    ).await?;
    // --- END KEY CODE ---

    println!("Extraction result:\n{}", result.raw_output);
    Ok(())
}
```

**agent_extra_tools.rs** - 3-tool pattern plus custom tools:

```rust
//! Example: Agent with MCP and extra tools
//!
//! Demonstrates combining the standard 3-tool extraction pattern with
//! additional custom tools. The custom DateExtractor tool shows how
//! to define a full tool with input/output types.
//!
//! Run: `cargo run -p rig-cli --example agent_extra_tools`

use rig::tool::{Tool, ToolSet};
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::future::Future;
use std::pin::Pin;

// --- CUSTOM TOOL DEFINITION ---

/// Input for the date extractor tool
#[derive(Debug, Deserialize, JsonSchema)]
struct DateExtractorInput {
    /// Text to extract dates from
    text: String,
}

/// Output from the date extractor tool
#[derive(Debug, Serialize, JsonSchema)]
struct DateExtractorOutput {
    /// Extracted date strings
    dates: Vec<String>,
}

/// Custom tool that extracts date-like patterns from text
struct DateExtractor;

impl Tool for DateExtractor {
    const NAME: &'static str = "extract_dates";

    type Input = DateExtractorInput;
    type Output = DateExtractorOutput;
    type Error = String;

    fn definition(&self) -> rig::completion::ToolDefinition {
        rig::completion::ToolDefinition {
            name: Self::NAME.to_string(),
            description: "Extracts date patterns from text (YYYY-MM-DD, Month Day Year, etc.)".to_string(),
            parameters: serde_json::json!({
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Text to extract dates from"
                    }
                },
                "required": ["text"]
            }),
        }
    }

    fn call(
        &self,
        input: Self::Input,
    ) -> Pin<Box<dyn Future<Output = Result<Self::Output, Self::Error>> + Send + '_>> {
        Box::pin(async move {
            // Simple regex-like extraction (for demo purposes)
            let dates: Vec<String> = input.text
                .split_whitespace()
                .filter(|word| {
                    word.contains('-') ||
                    word.parse::<u32>().is_ok() ||
                    ["jan", "feb", "mar", "apr", "may", "jun",
                     "jul", "aug", "sep", "oct", "nov", "dec"]
                        .iter()
                        .any(|m| word.to_lowercase().starts_with(m))
                })
                .map(String::from)
                .collect();

            Ok(DateExtractorOutput { dates })
        })
    }
}

// --- END CUSTOM TOOL DEFINITION ---

/// Event data with dates to extract
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct EventInfo {
    event_name: String,
    dates_mentioned: Vec<String>,
    summary: String,
}

fn build_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();

    // Standard 3-tool pattern
    let (submit, validate, example) = JsonSchemaToolkit::<EventInfo>::builder()
        .example(EventInfo {
            event_name: "Product Launch".to_string(),
            dates_mentioned: vec!["2026-03-15".to_string()],
            summary: "New product launching in March".to_string(),
        })
        .build()
        .build_tools();

    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);

    // --- KEY CODE: Add custom tool ---
    toolset.add_tool(DateExtractor);
    // --- END KEY CODE ---

    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    let client = rig_cli::claude::Client::new().await?;

    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble(
            "You are an event information extractor. \
             Use extract_dates to find dates in text, then use the \
             extraction tools to submit structured event info."
        )
        .build()?;

    let result = agent.prompt(
        "Extract event info: The conference runs from March 15-17, 2026 \
         in San Francisco. Early bird registration ends February 1st."
    ).await?;

    println!("Extraction result:\n{}", result.raw_output);
    Ok(())
}
```
  </action>
  <verify>
- `cargo build -p rig-cli --example agent_mcp` succeeds
- `cargo build -p rig-cli --example agent_extra_tools` succeeds
- agent_extra_tools.rs contains DateExtractor struct definition
  </verify>
  <done>agent_mcp.rs and agent_extra_tools.rs examples compile and demonstrate 3-tool and custom tool patterns</done>
</task>

</tasks>

<verification>
1. All four examples compile: `cargo build -p rig-cli --examples`
2. Each example has module-level doc comment explaining purpose
3. Each example has "KEY CODE" sections for copy-paste
4. Examples follow Rust API guidelines (? operator, no unwrap)
</verification>

<success_criteria>
- Four new examples in rig-cli/examples/
- All examples compile without warnings
- Each example is self-contained and copy-paste friendly
- Examples demonstrate: chat, one-shot, 3-tool, custom tools
</success_criteria>

<output>
After completion, create `.planning/phases/11-documentation-examples/11-03-SUMMARY.md`
</output>
