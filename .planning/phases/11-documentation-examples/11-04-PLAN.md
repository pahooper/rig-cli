---
phase: 11-documentation-examples
plan: 04
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - rig-cli/examples/multiagent.rs
  - rig-cli/examples/extraction.rs
  - rig-cli/examples/payload_chat.rs
  - rig-cli/examples/mcp_deterministic.rs
autonomous: true

must_haves:
  truths:
    - "Developer can run multiagent example with coordinating agents"
    - "Developer can run extraction example for structured data extraction"
    - "Developer can run payload_chat example for file content analysis"
    - "Developer can run mcp_deterministic example with custom date tool"
  artifacts:
    - path: "rig-cli/examples/multiagent.rs"
      provides: "Multiple agents coordinating"
      contains: "multiagent"
    - path: "rig-cli/examples/extraction.rs"
      provides: "Structured data extraction via MCP"
      contains: "PersonInfo"
    - path: "rig-cli/examples/payload_chat.rs"
      provides: "File content injection"
      contains: "with_payload"
    - path: "rig-cli/examples/mcp_deterministic.rs"
      provides: "MCP + deterministic tool"
      contains: "CurrentDateTool"
  key_links:
    - from: "rig-cli/examples/payload_chat.rs"
      to: "Client::with_payload"
      via: "payload injection"
      pattern: "with_payload"
---

<objective>
Create the remaining four user story examples: multiagent coordination, extraction workflow, payload-based chat, and MCP with deterministic tools.

Purpose: Complete the set of 8 user story examples from CONTEXT.md. These cover advanced patterns: multi-agent workflows, extraction, payload injection, and deterministic tools.

Output: Four new example files completing the example suite.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-documentation-examples/11-CONTEXT.md
@.planning/phases/11-documentation-examples/11-RESEARCH.md
@rig-cli/src/lib.rs
@rig-cli/src/claude.rs
@rig-provider/examples/payload_extraction_e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multiagent.rs and extraction.rs examples</name>
  <files>
rig-cli/examples/multiagent.rs
rig-cli/examples/extraction.rs
  </files>
  <action>
**multiagent.rs** - Multiple agents coordinating with tools:

```rust
//! Example: Multiagent with extra tools and MCP
//!
//! Demonstrates multiple agents working together:
//! 1. Researcher agent extracts information
//! 2. Summarizer agent condenses the extraction
//!
//! Each agent uses MCP tools for structured output.
//!
//! Run: `cargo run -p rig-cli --example multiagent`

use rig::tool::ToolSet;
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Research findings from first agent
#[derive(Debug, Clone, Deserialize, Serialize, JsonSchema)]
struct ResearchFindings {
    topic: String,
    key_points: Vec<String>,
    sources_count: u32,
}

/// Summary from second agent
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct Summary {
    one_liner: String,
    confidence: f32,  // 0.0 to 1.0
}

fn research_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<ResearchFindings>::builder()
        .example(ResearchFindings {
            topic: "Rust async".to_string(),
            key_points: vec!["Zero-cost abstractions".to_string()],
            sources_count: 5,
        })
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
}

fn summary_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<Summary>::builder()
        .example(Summary {
            one_liner: "Topic summary here".to_string(),
            confidence: 0.85,
        })
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Dual-mode: check which toolset based on env
    let mode = std::env::var("RIG_MCP_MODE").ok();
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return match mode.as_deref() {
            Some("summary") => Ok(summary_toolset().into_handler().await?.serve_stdio().await?),
            _ => Ok(research_toolset().into_handler().await?.serve_stdio().await?),
        };
    }

    let client = rig_cli::claude::Client::new().await?;

    // --- KEY CODE: Agent 1 - Researcher ---
    println!("=== Agent 1: Researcher ===");
    let researcher = client.mcp_agent("sonnet")
        .toolset(research_toolset())
        .preamble("You are a research assistant. Extract key findings.")
        .build()?;

    let research = researcher.prompt(
        "Research: What are the benefits of Rust's ownership system?"
    ).await?;
    println!("Research output:\n{}\n", research.raw_output);
    // --- END KEY CODE ---

    // --- KEY CODE: Agent 2 - Summarizer ---
    println!("=== Agent 2: Summarizer ===");
    let summarizer = client.mcp_agent("sonnet")
        .toolset(summary_toolset())
        .preamble("You are a summarizer. Create a one-line summary.")
        .build()?;

    // Pass research output to summarizer
    let summary = summarizer.prompt(&format!(
        "Summarize this research into one line:\n{}",
        research.raw_output
    )).await?;
    println!("Summary:\n{}", summary.raw_output);
    // --- END KEY CODE ---

    Ok(())
}
```

**extraction.rs** - Extraction agent with MCP validation:

```rust
//! Example: Extraction agent with MCP
//!
//! Demonstrates structured data extraction from unstructured text.
//! The agent is forced to submit via MCP tools, ensuring schema compliance.
//!
//! This is the primary use case for rig-cli: reliable structured extraction.
//!
//! Run: `cargo run -p rig-cli --example extraction`

use rig::tool::ToolSet;
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Person information to extract
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct PersonInfo {
    /// Full name of the person
    name: String,
    /// Age in years
    age: u32,
    /// Email address if mentioned
    email: Option<String>,
    /// List of skills or expertise
    skills: Vec<String>,
}

fn build_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<PersonInfo>::builder()
        .example(PersonInfo {
            name: "Jane Doe".to_string(),
            age: 28,
            email: Some("jane@example.com".to_string()),
            skills: vec!["Python".to_string(), "Machine Learning".to_string()],
        })
        .success_message("Person info extracted successfully!")
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    let client = rig_cli::claude::Client::new().await?;

    // --- KEY CODE: Extraction workflow ---
    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble(
            "You are a data extraction agent. \
             Extract person information from the provided text. \
             Use json_example to see the format, validate_json to check, \
             then submit."
        )
        .build()?;

    let unstructured_text = r#"
        Meet Sarah Chen, a 32-year-old software engineer from Seattle.
        She specializes in Rust, distributed systems, and cloud architecture.
        You can reach her at sarah.chen@techcorp.io for consulting work.
    "#;

    let result = agent.prompt(&format!(
        "Extract person information from this text:\n{}",
        unstructured_text
    )).await?;
    // --- END KEY CODE ---

    println!("Extracted:\n{}", result.raw_output);

    // Optionally parse the result
    if let Ok(person) = serde_json::from_str::<PersonInfo>(&result.raw_output) {
        println!("\nParsed PersonInfo:");
        println!("  Name: {}", person.name);
        println!("  Age: {}", person.age);
        println!("  Email: {:?}", person.email);
        println!("  Skills: {:?}", person.skills);
    }

    Ok(())
}
```
  </action>
  <verify>
- `cargo build -p rig-cli --example multiagent` succeeds
- `cargo build -p rig-cli --example extraction` succeeds
  </verify>
  <done>multiagent.rs and extraction.rs examples compile and demonstrate multi-agent and extraction patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create payload_chat.rs and mcp_deterministic.rs examples</name>
  <files>
rig-cli/examples/payload_chat.rs
rig-cli/examples/mcp_deterministic.rs
  </files>
  <action>
**payload_chat.rs** - Chat about file via payload injection:

```rust
//! Example: Chat about file via payload
//!
//! Demonstrates payload injection for file content analysis.
//! Shows both single Q&A and multi-turn patterns for payload-based chat.
//!
//! The payload is wrapped in XML <context> tags, separating data from instructions.
//!
//! Run: `cargo run -p rig-cli --example payload_chat`

use rig::tool::ToolSet;
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Analysis result for the file content
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct FileAnalysis {
    file_type: String,
    summary: String,
    key_findings: Vec<String>,
}

fn build_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<FileAnalysis>::builder()
        .example(FileAnalysis {
            file_type: "configuration".to_string(),
            summary: "Database configuration file".to_string(),
            key_findings: vec!["Uses PostgreSQL".to_string()],
        })
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    // Simulated file content (in practice, use std::fs::read_to_string)
    let file_content = r#"
[database]
host = "localhost"
port = 5432
name = "myapp_production"
max_connections = 100

[cache]
redis_url = "redis://localhost:6379"
ttl_seconds = 3600

[logging]
level = "info"
format = "json"
    "#;

    // --- KEY CODE: Single Q&A with payload ---
    println!("=== Single Q&A Pattern ===");
    let client = rig_cli::claude::Client::new().await?
        .with_payload(file_content);  // Inject file content

    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble("Analyze the configuration file in <context>")
        .build()?;

    let analysis = agent.prompt("What is this configuration file for?").await?;
    println!("Analysis:\n{}\n", analysis.raw_output);
    // --- END KEY CODE ---

    // --- KEY CODE: Multi-turn pattern with payload ---
    println!("=== Multi-turn Pattern ===");

    // Follow-up question (new agent with same payload)
    let client2 = rig_cli::claude::Client::new().await?
        .with_payload(file_content);

    let agent2 = client2.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble("Analyze the configuration file in <context>")
        .build()?;

    let followup = agent2.prompt(
        "Are there any security concerns with this configuration?"
    ).await?;
    println!("Follow-up:\n{}", followup.raw_output);
    // --- END KEY CODE ---

    Ok(())
}
```

**mcp_deterministic.rs** - MCP Agent + deterministic tool (custom date extraction):

```rust
//! Example: MCP Agent + deterministic tool
//!
//! Demonstrates combining MCP extraction with a deterministic (non-LLM) tool.
//! The CurrentDateTool returns the actual system date, showing how to mix
//! AI and deterministic operations.
//!
//! This example shows FULL tool definition, not assuming the tool exists.
//!
//! Run: `cargo run -p rig-cli --example mcp_deterministic`

use chrono::{DateTime, Utc};
use rig::completion::ToolDefinition;
use rig::tool::{Tool, ToolSet};
use rig_cli::prelude::*;
use rig_cli::tools::{JsonSchemaToolkit, ToolSetExt};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::future::Future;
use std::pin::Pin;

// --- DETERMINISTIC TOOL: Current Date ---

/// Input for the current date tool (no parameters needed)
#[derive(Debug, Deserialize, JsonSchema)]
struct CurrentDateInput {}

/// Output from the current date tool
#[derive(Debug, Serialize, JsonSchema)]
struct CurrentDateOutput {
    /// ISO 8601 formatted date-time
    iso8601: String,
    /// Human-readable date
    human_readable: String,
    /// Unix timestamp
    unix_timestamp: i64,
}

/// Deterministic tool that returns the current system date/time
struct CurrentDateTool;

impl Tool for CurrentDateTool {
    const NAME: &'static str = "get_current_date";

    type Input = CurrentDateInput;
    type Output = CurrentDateOutput;
    type Error = String;

    fn definition(&self) -> ToolDefinition {
        ToolDefinition {
            name: Self::NAME.to_string(),
            description: "Returns the current system date and time. Use this for any date-related queries.".to_string(),
            parameters: serde_json::json!({
                "type": "object",
                "properties": {},
                "required": []
            }),
        }
    }

    fn call(
        &self,
        _input: Self::Input,
    ) -> Pin<Box<dyn Future<Output = Result<Self::Output, Self::Error>> + Send + '_>> {
        Box::pin(async move {
            let now: DateTime<Utc> = Utc::now();
            Ok(CurrentDateOutput {
                iso8601: now.to_rfc3339(),
                human_readable: now.format("%B %d, %Y at %H:%M UTC").to_string(),
                unix_timestamp: now.timestamp(),
            })
        })
    }
}

// --- END DETERMINISTIC TOOL ---

/// Scheduled event with computed dates
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct ScheduledEvent {
    event_name: String,
    scheduled_date: String,
    days_until: i32,
    is_past: bool,
}

fn build_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();

    // Standard 3-tool pattern
    let (submit, validate, example) = JsonSchemaToolkit::<ScheduledEvent>::builder()
        .example(ScheduledEvent {
            event_name: "Team Meeting".to_string(),
            scheduled_date: "2026-02-10".to_string(),
            days_until: 7,
            is_past: false,
        })
        .build()
        .build_tools();

    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);

    // --- KEY CODE: Add deterministic date tool ---
    toolset.add_tool(CurrentDateTool);
    // --- END KEY CODE ---

    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    let client = rig_cli::claude::Client::new().await?;

    // --- KEY CODE: Agent with deterministic + extraction tools ---
    let agent = client.mcp_agent("sonnet")
        .toolset(build_toolset())
        .preamble(
            "You are an event scheduler. \
             Use get_current_date to get today's date, then calculate \
             days until the scheduled event."
        )
        .build()?;

    let result = agent.prompt(
        "How many days until the product launch on March 15, 2026?"
    ).await?;
    // --- END KEY CODE ---

    println!("Scheduled event info:\n{}", result.raw_output);

    Ok(())
}
```

Note: Add `chrono` dependency to rig-cli/Cargo.toml for the date tool example:
```toml
[dev-dependencies]
chrono = "0.4"
```
  </action>
  <verify>
- `cargo build -p rig-cli --example payload_chat` succeeds
- `cargo build -p rig-cli --example mcp_deterministic` succeeds
- mcp_deterministic.rs contains full CurrentDateTool definition
  </verify>
  <done>payload_chat.rs and mcp_deterministic.rs examples compile and demonstrate payload injection and deterministic tools</done>
</task>

</tasks>

<verification>
1. All four examples compile: `cargo build -p rig-cli --examples`
2. Each example has module-level doc comment
3. Each example has "KEY CODE" sections
4. payload_chat demonstrates both single Q&A and multi-turn patterns
5. mcp_deterministic shows full tool definition (not assumed to exist)
</verification>

<success_criteria>
- Four new examples added (multiagent, extraction, payload_chat, mcp_deterministic)
- All examples compile without warnings
- Each example is self-contained and copy-paste friendly
- chrono dev-dependency added for date tool example
</success_criteria>

<output>
After completion, create `.planning/phases/11-documentation-examples/11-04-SUMMARY.md`
</output>
