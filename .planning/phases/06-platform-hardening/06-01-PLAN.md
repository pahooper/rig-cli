---
phase: 06-platform-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - claudecode-adapter/src/process.rs
  - claudecode-adapter/src/error.rs
  - claudecode-adapter/Cargo.toml
  - codex-adapter/src/process.rs
  - codex-adapter/src/error.rs
  - codex-adapter/Cargo.toml
  - opencode-adapter/src/process.rs
  - opencode-adapter/src/error.rs
  - opencode-adapter/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "All three adapters compile on both Unix and Windows targets (cross-compilation check)"
    - "On Unix, graceful shutdown sends SIGTERM, waits grace period, then SIGKILL (existing behavior preserved)"
    - "On Windows, graceful shutdown uses Child::kill() immediately (documented limitation)"
    - "nix crate import is gated behind cfg(unix) — no unconditional nix usage"
    - "SignalFailed error variant works on both platforms (no nix::errno::Errno in platform-neutral code)"
  artifacts:
    - path: "claudecode-adapter/src/process.rs"
      provides: "Cross-platform graceful_shutdown with cfg(unix)/cfg(windows)"
      contains: "cfg(unix)"
    - path: "codex-adapter/src/process.rs"
      provides: "Cross-platform graceful_shutdown with cfg(unix)/cfg(windows)"
      contains: "cfg(unix)"
    - path: "opencode-adapter/src/process.rs"
      provides: "Cross-platform graceful_shutdown with cfg(unix)/cfg(windows)"
      contains: "cfg(unix)"
    - path: "claudecode-adapter/src/error.rs"
      provides: "Platform-neutral SignalFailed variant (no nix::errno::Errno)"
      contains: "SignalFailed"
    - path: "codex-adapter/src/error.rs"
      provides: "Platform-neutral SignalFailed variant (no nix::errno::Errno)"
      contains: "SignalFailed"
    - path: "opencode-adapter/src/error.rs"
      provides: "Platform-neutral SignalFailed variant (no nix::errno::Errno)"
      contains: "SignalFailed"
  key_links:
    - from: "claudecode-adapter/src/process.rs"
      to: "claudecode-adapter/src/error.rs"
      via: "SignalFailed error variant used in graceful_shutdown"
      pattern: "SignalFailed"
    - from: "codex-adapter/src/process.rs"
      to: "codex-adapter/src/error.rs"
      via: "SignalFailed error variant used in graceful_shutdown"
      pattern: "SignalFailed"
    - from: "opencode-adapter/src/process.rs"
      to: "opencode-adapter/src/error.rs"
      via: "SignalFailed error variant used in graceful_shutdown"
      pattern: "SignalFailed"
---

<objective>
Make all three adapter subprocess modules compile and work on both Unix and Windows by replacing unconditional `nix` crate usage with `cfg(target_os)` conditional compilation.

Purpose: The `nix` crate is Unix-only and will fail to compile on Windows. All three adapters currently use `nix::sys::signal` in `process.rs` and `nix::errno::Errno` in `error.rs`. This plan gates all nix usage behind `cfg(unix)` and provides Windows-native alternatives using `Child::kill()` (which calls `TerminateProcess` on Windows).

Output: All three adapters' process.rs and error.rs files are cross-platform. The `nix` dependency becomes `[target.'cfg(unix)'.dependencies]` in each adapter's Cargo.toml.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-platform-hardening/06-RESEARCH.md

@claudecode-adapter/src/process.rs
@claudecode-adapter/src/error.rs
@claudecode-adapter/Cargo.toml
@codex-adapter/src/process.rs
@codex-adapter/src/error.rs
@codex-adapter/Cargo.toml
@opencode-adapter/src/process.rs
@opencode-adapter/src/error.rs
@opencode-adapter/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make error types platform-neutral across all three adapters</name>
  <files>claudecode-adapter/src/error.rs, codex-adapter/src/error.rs, opencode-adapter/src/error.rs</files>
  <action>
  In all three error.rs files, the `SignalFailed` variant currently has `source: nix::errno::Errno` which is Unix-only. Replace with a platform-neutral error representation.

  **For each of claudecode-adapter/src/error.rs, codex-adapter/src/error.rs, opencode-adapter/src/error.rs:**

  1. Change the `SignalFailed` variant from:
     ```rust
     SignalFailed {
         signal: String,
         pid: u32,
         #[source]
         source: nix::errno::Errno,
     }
     ```
     To:
     ```rust
     SignalFailed {
         signal: String,
         pid: u32,
         /// Platform-specific error description.
         reason: String,
     }
     ```
     Update the `#[error(...)]` attribute to use `reason` instead of `source`:
     ```rust
     #[error("Failed to send {signal} signal to PID {pid}: {reason}")]
     SignalFailed {
         signal: String,
         pid: u32,
         reason: String,
     }
     ```
     Note: Remove the `#[source]` attribute since `reason` is now a `String`, not an error type.

  2. Verify there are no other direct references to `nix::errno::Errno` remaining in each error.rs file.

  This makes the error types fully platform-neutral — they carry a string description of the signal failure without depending on any Unix-specific type.
  </action>
  <verify>
  Run `cargo check -p claudecode-adapter -p codex-adapter -p opencode-adapter` to verify all three crates compile.
  Grep all three error.rs files for `nix::` — should find zero matches.
  Grep all three error.rs files for `SignalFailed` — should find exactly one variant definition per file with `reason: String`.
  </verify>
  <done>
  All three adapters' error.rs files have platform-neutral SignalFailed variants using `reason: String` instead of `nix::errno::Errno`.
  No nix crate types appear in any error.rs file.
  All three crates compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cfg(unix)/cfg(windows) to process.rs in all three adapters and gate nix dependency</name>
  <files>
  claudecode-adapter/src/process.rs, claudecode-adapter/Cargo.toml,
  codex-adapter/src/process.rs, codex-adapter/Cargo.toml,
  opencode-adapter/src/process.rs, opencode-adapter/Cargo.toml
  </files>
  <action>
  **Step 1: Gate nix dependency in all three Cargo.toml files**

  In each adapter's Cargo.toml, change:
  ```toml
  nix = { version = "0.29", features = ["signal"] }
  ```
  To a target-specific dependency:
  ```toml
  [target.'cfg(unix)'.dependencies]
  nix = { version = "0.29", features = ["signal"] }
  ```
  Move the nix line out of `[dependencies]` into the new target-specific section.

  **Step 2: Update claudecode-adapter/src/process.rs**

  Remove the top-level unconditional nix imports:
  ```rust
  use nix::sys::signal::{self, Signal};
  use nix::unistd::Pid;
  ```

  Replace the existing `graceful_shutdown` function with two cfg-gated versions:

  ```rust
  /// Sends SIGTERM, waits up to `GRACE_PERIOD`, then force-kills with SIGKILL.
  #[cfg(unix)]
  async fn graceful_shutdown(
      child: &mut tokio::process::Child,
      pid: u32,
  ) -> Result<std::process::ExitStatus, ClaudeError> {
      use nix::sys::signal::{self, Signal};
      use nix::unistd::Pid;

      let nix_pid = Pid::from_raw(pid.cast_signed());
      signal::kill(nix_pid, Signal::SIGTERM).map_err(|e| ClaudeError::SignalFailed {
          signal: "SIGTERM".to_string(),
          pid,
          reason: e.to_string(),
      })?;

      match timeout(GRACE_PERIOD, child.wait()).await {
          Ok(Ok(status)) => Ok(status),
          Ok(Err(e)) => Err(ClaudeError::SpawnFailed {
              stage: "graceful_shutdown wait".to_string(),
              source: e,
          }),
          Err(_) => {
              child.kill().await.map_err(|e| ClaudeError::SpawnFailed {
                  stage: "SIGKILL".to_string(),
                  source: e,
              })?;
              child.wait().await.map_err(|e| ClaudeError::SpawnFailed {
                  stage: "post-SIGKILL wait".to_string(),
                  source: e,
              })
          }
      }
  }

  /// Windows: no graceful shutdown mechanism for console processes.
  /// Uses immediate TerminateProcess via Child::kill().
  #[cfg(windows)]
  async fn graceful_shutdown(
      child: &mut tokio::process::Child,
      _pid: u32,
  ) -> Result<std::process::ExitStatus, ClaudeError> {
      child.kill().await.map_err(|e| ClaudeError::SpawnFailed {
          stage: "TerminateProcess".to_string(),
          source: e,
      })?;
      child.wait().await.map_err(|e| ClaudeError::SpawnFailed {
          stage: "post-kill wait".to_string(),
          source: e,
      })
  }
  ```

  **Step 3: Update codex-adapter/src/process.rs**

  Remove the top-level unconditional nix imports:
  ```rust
  use nix::sys::signal::{self, Signal};
  use nix::unistd::Pid;
  ```

  Replace the existing `graceful_shutdown` function with two cfg-gated versions:

  ```rust
  /// Graceful shutdown: `SIGTERM`, wait grace period, then `SIGKILL`.
  #[cfg(unix)]
  async fn graceful_shutdown(
      child: &mut tokio::process::Child,
      pid: u32,
      tasks: &mut JoinSet<StreamOutput>,
  ) -> Result<(), CodexError> {
      use nix::sys::signal::{self, Signal};
      use nix::unistd::Pid;

      let raw_pid = i32::try_from(pid).map_err(|_| CodexError::SignalFailed {
          signal: "SIGTERM".to_string(),
          pid,
          reason: "PID value exceeds i32::MAX".to_string(),
      })?;
      let nix_pid = Pid::from_raw(raw_pid);

      signal::kill(nix_pid, Signal::SIGTERM).map_err(|e| CodexError::SignalFailed {
          signal: "SIGTERM".to_string(),
          pid,
          reason: e.to_string(),
      })?;

      match timeout(GRACE_PERIOD, child.wait()).await {
          Ok(Ok(_status)) => {}
          Ok(Err(e)) => {
              return Err(CodexError::SpawnFailed {
                  stage: "graceful_shutdown wait".to_string(),
                  source: e,
              });
          }
          Err(_) => {
              child.kill().await.map_err(|e| CodexError::SpawnFailed {
                  stage: "SIGKILL".to_string(),
                  source: e,
              })?;
              child.wait().await.map_err(|e| CodexError::SpawnFailed {
                  stage: "post-SIGKILL wait".to_string(),
                  source: e,
              })?;
          }
      }

      tasks.abort_all();
      Ok(())
  }

  /// Windows: immediate termination, no graceful shutdown for console processes.
  #[cfg(windows)]
  async fn graceful_shutdown(
      child: &mut tokio::process::Child,
      _pid: u32,
      tasks: &mut JoinSet<StreamOutput>,
  ) -> Result<(), CodexError> {
      child.kill().await.map_err(|e| CodexError::SpawnFailed {
          stage: "TerminateProcess".to_string(),
          source: e,
      })?;
      child.wait().await.map_err(|e| CodexError::SpawnFailed {
          stage: "post-kill wait".to_string(),
          source: e,
      })?;
      tasks.abort_all();
      Ok(())
  }
  ```

  **Step 4: Update opencode-adapter/src/process.rs**

  Remove the top-level unconditional nix imports:
  ```rust
  use nix::sys::signal::{self, Signal};
  use nix::unistd::Pid;
  ```

  Remove the `pid_to_nix` helper function entirely (it was only used for nix conversion).

  Replace the existing `graceful_shutdown` function with two cfg-gated versions:

  ```rust
  /// Graceful shutdown: `SIGTERM`, wait grace period, then `SIGKILL`.
  #[cfg(unix)]
  async fn graceful_shutdown(
      child: &mut tokio::process::Child,
      pid: u32,
  ) -> Result<(), OpenCodeError> {
      use nix::sys::signal::{self, Signal};
      use nix::unistd::Pid;

      let raw = i32::try_from(pid).map_err(|_| OpenCodeError::SpawnFailed {
          stage: "PID conversion overflow".to_string(),
          source: std::io::Error::other("PID value exceeds i32::MAX"),
      })?;
      let nix_pid = Pid::from_raw(raw);

      signal::kill(nix_pid, Signal::SIGTERM).map_err(|e| OpenCodeError::SignalFailed {
          signal: "SIGTERM".to_string(),
          pid,
          reason: e.to_string(),
      })?;

      match timeout(GRACE_PERIOD, child.wait()).await {
          Ok(Ok(_status)) => Ok(()),
          Ok(Err(e)) => Err(OpenCodeError::SpawnFailed {
              stage: "graceful_shutdown wait".to_string(),
              source: e,
          }),
          Err(_) => {
              child.kill().await.map_err(|e| OpenCodeError::SpawnFailed {
                  stage: "SIGKILL".to_string(),
                  source: e,
              })?;
              child.wait().await.map_err(|e| OpenCodeError::SpawnFailed {
                  stage: "post-SIGKILL wait".to_string(),
                  source: e,
              })?;
              Ok(())
          }
      }
  }

  /// Windows: immediate termination, no graceful shutdown for console processes.
  #[cfg(windows)]
  async fn graceful_shutdown(
      child: &mut tokio::process::Child,
      _pid: u32,
  ) -> Result<(), OpenCodeError> {
      child.kill().await.map_err(|e| OpenCodeError::SpawnFailed {
          stage: "TerminateProcess".to_string(),
          source: e,
      })?;
      child.wait().await.map_err(|e| OpenCodeError::SpawnFailed {
          stage: "post-kill wait".to_string(),
          source: e,
      })?;
      Ok(())
  }
  ```

  **Important constraints:**
  - The nix imports MUST be inside the `#[cfg(unix)]` function bodies, not at the top of the file.
  - The `#[cfg(windows)]` implementations use `Child::kill()` which calls `TerminateProcess` on Windows — this is an immediate kill with no grace period. This is a known limitation documented in the research.
  - The `SignalFailed` error variant now uses `reason: String`, so all callsites must change from `source: e` to `reason: e.to_string()`.
  - Preserve all existing function signatures and public behavior — callers should not need to change.
  </action>
  <verify>
  Run `cargo check -p claudecode-adapter -p codex-adapter -p opencode-adapter` to verify compilation.
  Run `cargo test --all-features` to verify all existing tests pass.
  Run `cargo clippy --all-targets --all-features -- -D warnings` to verify no new clippy warnings (existing missing-docs warnings are pre-existing and acceptable).
  Grep all three process.rs files for `use nix::` at the top level — should find zero matches (all nix imports must be inside cfg(unix) function bodies).
  Grep all three process.rs files for `cfg(unix)` — should find at least one match per file.
  Grep all three process.rs files for `cfg(windows)` — should find at least one match per file.
  Grep all three Cargo.toml files for `cfg(unix)` — should find the target-specific dependency section.
  </verify>
  <done>
  All three adapters have cfg(unix)/cfg(windows) graceful_shutdown implementations.
  nix crate is gated behind [target.'cfg(unix)'.dependencies] in all three Cargo.toml files.
  No unconditional nix imports exist at file top-level in any process.rs.
  All existing tests pass unchanged.
  Unix behavior is preserved exactly (SIGTERM -> grace period -> SIGKILL).
  Windows behavior uses immediate Child::kill() (documented limitation).
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p claudecode-adapter -p codex-adapter -p opencode-adapter` compiles cleanly
2. `cargo test --all-features` — all existing tests pass
3. `cargo clippy --all-targets --all-features` — no new warnings from this change
4. No unconditional `use nix::` imports in any process.rs file (all inside cfg(unix) blocks)
5. All three error.rs files use `reason: String` instead of `nix::errno::Errno` in SignalFailed
6. All three Cargo.toml files have nix under `[target.'cfg(unix)'.dependencies]`
7. Both `#[cfg(unix)]` and `#[cfg(windows)]` graceful_shutdown exist in each process.rs
</verification>

<success_criteria>
- All three adapters compile on Linux (no regression) and would compile on Windows (nix gated)
- Signal handling behavior on Unix is preserved exactly
- Windows path uses immediate Child::kill() — documented limitation
- Error types are platform-neutral (no nix types in public API)
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/06-platform-hardening/06-01-SUMMARY.md`
</output>
