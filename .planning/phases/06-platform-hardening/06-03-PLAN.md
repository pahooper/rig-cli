---
phase: 06-platform-hardening
plan: 03
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - rig-provider/src/setup.rs
  - rig-provider/src/mcp_agent.rs
  - rig-provider/Cargo.toml
  - rig-provider/examples/claudecode_mcp.rs
  - rig-provider/examples/opencode_jsonl.rs
autonomous: true

must_haves:
  truths:
    - "setup.rs uses dirs::home_dir() instead of std::env::var('HOME')"
    - "setup_json_mcp accepts &Path for exe_path instead of &str (path stays as PathBuf as long as possible)"
    - "Config paths in setup.rs are constructed via PathBuf::join() not string concatenation"
    - "to_string_lossy() is only used for display/logging and JSON serialization (where strings are required by external formats), never for path operations"
    - "Example files use dirs::home_dir() instead of std::env::var('HOME') where applicable"
  artifacts:
    - path: "rig-provider/src/setup.rs"
      provides: "Cross-platform setup using dirs::home_dir() and PathBuf-based exe_path"
      contains: "dirs::home_dir"
    - path: "rig-provider/src/mcp_agent.rs"
      provides: "MCP agent config with documented to_string_lossy() usage"
      contains: "to_string_lossy"
    - path: "rig-provider/Cargo.toml"
      provides: "dirs dependency for cross-platform home directory resolution"
      contains: "dirs"
  key_links:
    - from: "rig-provider/src/setup.rs"
      to: "dirs crate"
      via: "dirs::home_dir() replaces std::env::var(HOME)"
      pattern: "dirs::home_dir"
    - from: "rig-provider/src/setup.rs"
      to: "std::path::Path"
      via: "exe_path parameter changed from &str to &Path"
      pattern: "exe_path.*Path"
---

<objective>
Migrate setup.rs from Unix-only `HOME` environment variable to cross-platform `dirs::home_dir()`, and improve path handling in setup.rs and mcp_agent.rs to use `PathBuf`/`&Path` instead of `&str` where possible.

Purpose: The current setup.rs uses `std::env::var("HOME")` which fails on Windows (where USERPROFILE or HOMEPATH is used). The `to_string_lossy()` calls in mcp_agent.rs convert paths to strings earlier than necessary, risking data loss on Windows with non-ASCII usernames. This plan makes path handling cross-platform.

Output: setup.rs using `dirs::home_dir()`, setup helper functions accepting `&Path` for exe_path, `to_string_lossy()` usage only where string output is required by external formats (JSON values, CLI arguments).
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-platform-hardening/06-RESEARCH.md

@rig-provider/src/setup.rs
@rig-provider/src/mcp_agent.rs
@rig-provider/Cargo.toml
@rig-provider/examples/claudecode_mcp.rs
@rig-provider/examples/opencode_jsonl.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate setup.rs to dirs::home_dir() and PathBuf-based exe_path</name>
  <files>rig-provider/src/setup.rs, rig-provider/Cargo.toml</files>
  <action>
  **Step 1: Add `dirs` to rig-provider/Cargo.toml**

  Add under `[dependencies]`:
  ```toml
  dirs = "5.0"
  ```

  **Step 2: Rewrite setup.rs path handling**

  Replace the `HOME` env var usage with `dirs::home_dir()`:

  Change:
  ```rust
  let home = std::env::var("HOME").context("HOME env var not set")?;
  ```
  To:
  ```rust
  let home = dirs::home_dir().context("Could not determine home directory")?;
  ```

  Change the `exe_path_str` line. Instead of eagerly converting to string at the top:
  ```rust
  let exe_path_str = exe_path.to_string_lossy().to_string();
  ```

  Keep `exe_path` as a `PathBuf` and only convert to string in the helper functions where JSON/TOML serialization requires it.

  Update `run_setup` to pass `&exe_path` (as `&Path`) to helper functions:
  ```rust
  pub fn run_setup(config: &SetupConfig) -> anyhow::Result<()> {
      tracing::info!("Starting Zero-Config self-registration...");

      let exe_path = std::env::current_exe()?;
      let home = dirs::home_dir().context("Could not determine home directory")?;

      // 1. JSON-based configurations (Claude Code, OpenCode)
      let claude_path = home.join(".claude.json");
      setup_json_mcp("Claude Code", &claude_path, &exe_path, "rig-provider", config)?;

      let opencode_path = home.join(".opencode.json");
      setup_json_mcp("OpenCode", &opencode_path, &exe_path, "rig-provider", config)?;

      // 2. TOML-based configurations (Codex)
      let codex_path = home.join(".codex/config.toml");
      setup_codex(&codex_path, &exe_path, "rig-provider", config)?;

      if config.dry_run {
          println!("\n[DRY RUN] Setup complete. No files were modified.");
      } else {
          println!("\n[SUCCESS] Rig Provider successfully registered for all supported CLIs.");
      }

      Ok(())
  }
  ```

  Update `setup_json_mcp` to accept `&Path` instead of `&str` for `exe_path`:
  ```rust
  fn setup_json_mcp(
      name: &str,
      path: &Path,
      exe_path: &Path,
      provider_name: &str,
      config: &SetupConfig,
  ) -> anyhow::Result<()> {
      // ... existing logic ...

      // Convert exe_path to string only for JSON serialization
      let exe_str = exe_path.display().to_string();

      servers.insert(
          provider_name.to_string(),
          serde_json::json!({
              "command": exe_str,
              "args": [],
              "env": {}
          }),
      );

      // ... rest unchanged ...
  }
  ```

  Update `setup_codex` similarly:
  ```rust
  fn setup_codex(
      path: &Path,
      exe_path: &Path,
      provider_name: &str,
      config: &SetupConfig,
  ) -> anyhow::Result<()> {
      // ... existing logic ...

      // Convert exe_path to string only for TOML serialization
      let exe_str = exe_path.display().to_string();
      let entry = format!("\n{section_header}\ncommand = \"{exe_str}\"\nargs = []\n");

      // ... rest unchanged ...
  }
  ```

  Remove the `PathBuf::from(&home)` calls — `home` is already a `PathBuf` from `dirs::home_dir()`.

  **Important constraints:**
  - `to_string_lossy()` / `display()` is acceptable ONLY at the point of serialization (JSON value, TOML value, user output). The path should stay as `PathBuf`/`&Path` as long as possible.
  - Use `display().to_string()` over `to_string_lossy().to_string()` for consistency — `display()` is the idiomatic Rust way to convert paths for display purposes.
  </action>
  <verify>
  Run `cargo check -p rig-provider` to verify compilation.
  Run `cargo test -p rig-provider` to verify tests pass.
  Grep setup.rs for `std::env::var("HOME")` — should find zero matches.
  Grep setup.rs for `dirs::home_dir` — should find exactly one match.
  Grep setup.rs for `exe_path: &Path` — should find in both helper function signatures.
  Verify no `PathBuf::from(&home)` remains (home is already PathBuf).
  </verify>
  <done>
  setup.rs uses dirs::home_dir() for cross-platform home directory resolution.
  Helper functions accept &Path for exe_path, converting to string only at serialization point.
  No direct HOME env var access remains in setup.rs.
  dirs crate added to rig-provider/Cargo.toml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit and document to_string_lossy usage in mcp_agent.rs and examples</name>
  <files>rig-provider/src/mcp_agent.rs, rig-provider/examples/claudecode_mcp.rs, rig-provider/examples/opencode_jsonl.rs</files>
  <action>
  **Step 1: Audit to_string_lossy() in mcp_agent.rs**

  There are two uses of `to_string_lossy()` in mcp_agent.rs:

  1. **Line 418** — `exe.to_string_lossy().to_string()` for `McpConfig.command` field:
     ```rust
     command: exe.to_string_lossy().to_string(),
     ```
     This is used to build the MCP config JSON which requires a String for the "command" field. This conversion is **necessary** because `McpConfig.command` is `String` and the JSON format requires a UTF-8 string. Keep it but add an inline comment:
     ```rust
     // Path-to-string for JSON serialization; lossy is acceptable since CLI commands
     // must be valid UTF-8 in JSON config format.
     command: exe.to_string_lossy().to_string(),
     ```

  2. **Line 524** — `config_path.to_string_lossy().to_string()` for Claude MCP config path:
     ```rust
     configs: vec![config_path.to_string_lossy().to_string()],
     ```
     This is used for `McpPolicy.configs` which is `Vec<String>`. The config path is a temp file path that `tempfile` creates with valid UTF-8 naming on all platforms, so lossy conversion is safe here. Add inline comment:
     ```rust
     // Temp file paths are always valid UTF-8 (created by tempfile crate).
     configs: vec![config_path.to_string_lossy().to_string()],
     ```

  Both uses are at serialization boundaries where String is required by external data structures. No change needed to the actual code — just add documentation comments explaining why the conversion is acceptable.

  **Step 2: Update example files to use dirs::home_dir()**

  In `rig-provider/examples/claudecode_mcp.rs`, find and replace:
  ```rust
  let home = std::env::var("HOME").map_err(|e| format!("HOME env var not set: {}", e))?;
  ```
  With:
  ```rust
  let home = dirs::home_dir()
      .ok_or_else(|| "Could not determine home directory".to_string())?;
  ```
  Then update the path construction — `home` is now a `PathBuf` not a `String`, so adjust any `format!("{home}/...")` usage to `home.join(...)`.

  In `rig-provider/examples/opencode_jsonl.rs`, same replacement:
  ```rust
  let home = std::env::var("HOME").map_err(|e| format!("HOME env var not set: {}", e))?;
  ```
  With:
  ```rust
  let home = dirs::home_dir()
      .ok_or_else(|| "Could not determine home directory".to_string())?;
  ```
  And adjust path construction similarly.

  For both examples, the `exe.to_string_lossy().to_string()` usage is for MCP config JSON generation — this stays as-is (serialization boundary, same as mcp_agent.rs).

  **Important:** Check that the examples compile after changes. The `home` variable type changes from `String` to `PathBuf`, so all format strings using `{home}` must be changed to `home.join(...)` or `home.display()`.

  Read each example file fully before making changes to understand how `home` is used downstream.
  </action>
  <verify>
  Run `cargo check --all-targets` to verify all examples compile.
  Run `cargo test --all-features` to verify all tests pass.
  Grep all .rs files (excluding target/) for `std::env::var("HOME")` — should find zero matches in src/ (examples may still have it if they use HOME for other purposes, but the path construction should use dirs).
  Verify inline comments exist in mcp_agent.rs at both to_string_lossy() call sites.
  </verify>
  <done>
  mcp_agent.rs to_string_lossy() usage documented with inline comments explaining why conversion is acceptable.
  Example files migrated from HOME env var to dirs::home_dir().
  All examples compile cleanly.
  No HOME env var access in main src/ code (setup.rs, mcp_agent.rs).
  to_string_lossy() only used at serialization boundaries (JSON config, TOML config).
  </done>
</task>

</tasks>

<verification>
1. `cargo check --all-targets` compiles everything cleanly
2. `cargo test --all-features` — all tests pass
3. `cargo clippy --all-targets --all-features` — no new warnings
4. No `std::env::var("HOME")` in src/ files (setup.rs, mcp_agent.rs)
5. `dirs::home_dir()` used in setup.rs and example files
6. setup_json_mcp and setup_codex accept `&Path` for exe_path
7. to_string_lossy() in mcp_agent.rs has inline documentation comments
8. Example files use dirs::home_dir() for path construction
</verification>

<success_criteria>
- Cross-platform home directory resolution via dirs crate in setup.rs
- Path stays as PathBuf as long as possible, converted to String only at serialization boundaries
- All to_string_lossy() usage is documented as intentional at serialization points
- Examples migrated from HOME env var to dirs::home_dir()
- Full workspace compiles and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-platform-hardening/06-03-SUMMARY.md`
</output>
