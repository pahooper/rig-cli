---
phase: 06-platform-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - claudecode-adapter/src/discovery.rs
  - claudecode-adapter/Cargo.toml
  - codex-adapter/src/discovery.rs
  - codex-adapter/src/error.rs
  - codex-adapter/Cargo.toml
  - opencode-adapter/src/discovery.rs
  - opencode-adapter/src/error.rs
  - opencode-adapter/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "All three adapters check common install locations when PATH lookup fails"
    - "Error messages include install hints when binary is not found"
    - "Codex and OpenCode discovery functions follow the same 3-tier pattern as Claude (explicit path -> env var -> PATH -> fallbacks -> helpful error)"
    - "Fallback locations are platform-specific (cfg(unix) / cfg(windows))"
    - "which crate handles .exe extensions automatically on Windows (no hardcoded .exe in fallback paths)"
  artifacts:
    - path: "claudecode-adapter/src/discovery.rs"
      provides: "4-tier discovery with fallback locations and install hints"
      contains: "fallback_locations"
    - path: "codex-adapter/src/discovery.rs"
      provides: "4-tier discovery matching Claude pattern (explicit path, env var, PATH, fallbacks)"
      contains: "discover_codex"
    - path: "opencode-adapter/src/discovery.rs"
      provides: "4-tier discovery matching Claude pattern (explicit path, env var, PATH, fallbacks)"
      contains: "discover_opencode"
  key_links:
    - from: "claudecode-adapter/src/discovery.rs"
      to: "dirs crate"
      via: "dirs::home_dir() for fallback path construction"
      pattern: "dirs::home_dir"
    - from: "codex-adapter/src/discovery.rs"
      to: "dirs crate"
      via: "dirs::home_dir() for fallback path construction"
      pattern: "dirs::home_dir"
    - from: "opencode-adapter/src/discovery.rs"
      to: "dirs crate"
      via: "dirs::home_dir() for fallback path construction"
      pattern: "dirs::home_dir"
---

<objective>
Standardize binary discovery across all three adapters with the 3-tier pattern (explicit path -> env var -> PATH -> common fallback locations -> helpful error message) and add the `dirs` crate for cross-platform home directory resolution.

Purpose: Current discovery is inconsistent — Claude has explicit path + env var + PATH, but Codex/OpenCode only have PATH lookup. None have fallback location checks or install hints in error messages. This plan standardizes all three to the same robust pattern.

Output: All three discovery.rs files with standardized 4-tier discovery, platform-specific fallback locations, and install hints. `dirs` crate added to all three adapter Cargo.toml files.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-platform-hardening/06-RESEARCH.md

@claudecode-adapter/src/discovery.rs
@claudecode-adapter/Cargo.toml
@codex-adapter/src/discovery.rs
@codex-adapter/src/error.rs
@codex-adapter/Cargo.toml
@opencode-adapter/src/discovery.rs
@opencode-adapter/src/error.rs
@opencode-adapter/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance Claude discovery with fallback locations and install hints</name>
  <files>claudecode-adapter/src/discovery.rs, claudecode-adapter/Cargo.toml</files>
  <action>
  **Step 1: Add `dirs` to claudecode-adapter/Cargo.toml**

  Add under `[dependencies]`:
  ```toml
  dirs = "5.0"
  ```

  **Step 2: Rewrite claudecode-adapter/src/discovery.rs**

  Keep the existing 3-tier pattern (explicit path -> env var -> PATH) but add fallback locations and a helpful error message. The full resolution order becomes:
  1. `explicit_path` if provided and exists
  2. `CC_ADAPTER_CLAUDE_BIN` environment variable
  3. `claude` via `$PATH` (which handles .exe on Windows)
  4. Common install location fallbacks (platform-specific)
  5. Helpful error with install instructions

  Add platform-specific fallback location functions:

  ```rust
  #[cfg(unix)]
  fn fallback_locations() -> Vec<PathBuf> {
      let mut locations = Vec::new();
      if let Some(home) = dirs::home_dir() {
          // npm global install locations on Unix
          locations.push(home.join(".npm/bin/claude"));
          locations.push(home.join(".local/bin/claude"));
      }
      // System-wide npm
      locations.push(PathBuf::from("/usr/local/bin/claude"));
      locations
  }

  #[cfg(windows)]
  fn fallback_locations() -> Vec<PathBuf> {
      let mut locations = Vec::new();
      if let Some(home) = dirs::home_dir() {
          // npm global install on Windows
          locations.push(home.join("AppData/Roaming/npm/claude.cmd"));
      }
      // Program Files npm
      locations.push(PathBuf::from(r"C:\Program Files\nodejs\claude.cmd"));
      locations
  }
  ```

  Note: On Windows, npm installs `.cmd` wrapper scripts, not `.exe` directly. The `which` crate handles this for PATH lookups, but fallback locations need the correct extension.

  Update the `discover_claude` function to check fallbacks before the final error:

  ```rust
  pub fn discover_claude(explicit_path: Option<PathBuf>) -> Result<PathBuf, ClaudeError> {
      // 1. Explicit path
      if let Some(path) = explicit_path {
          if path.exists() {
              return Ok(path);
          }
          return Err(ClaudeError::ExecutableNotFound(format!(
              "Explicit path does not exist: {}",
              path.display()
          )));
      }

      // 2. Environment variable
      if let Ok(path_str) = std::env::var(CC_BIN_ENV_VAR) {
          let path = PathBuf::from(path_str);
          if path.exists() {
              return Ok(path);
          }
      }

      // 3. PATH lookup (which handles .exe/.cmd on Windows automatically)
      if let Ok(path) = which("claude") {
          return Ok(path);
      }

      // 4. Common install locations
      for location in fallback_locations() {
          if location.exists() {
              return Ok(location);
          }
      }

      // 5. Helpful error with install instructions
      Err(ClaudeError::ExecutableNotFound(
          "claude not found. Install: npm install -g @anthropic-ai/claude-code\n\
           Searched: PATH, common npm install locations.".to_string()
      ))
  }
  ```
  </action>
  <verify>
  Run `cargo check -p claudecode-adapter` to verify compilation.
  Run `cargo test -p claudecode-adapter` to verify existing tests pass.
  Grep discovery.rs for `fallback_locations` — should find the function definition and its call.
  Grep discovery.rs for `dirs::home_dir` — should find usage in fallback locations.
  Grep discovery.rs for "Install:" — should find the install hint in the error message.
  </verify>
  <done>
  Claude discovery has 5-step resolution: explicit path, env var, PATH, fallback locations, helpful error.
  Fallback locations are platform-specific via cfg(unix)/cfg(windows).
  Install hint included in error message.
  dirs crate added to Cargo.toml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Standardize Codex and OpenCode discovery to match Claude pattern</name>
  <files>codex-adapter/src/discovery.rs, codex-adapter/src/error.rs, codex-adapter/Cargo.toml, opencode-adapter/src/discovery.rs, opencode-adapter/src/error.rs, opencode-adapter/Cargo.toml</files>
  <action>
  **Step 1: Add `dirs` to both Cargo.toml files**

  Add under `[dependencies]` in both codex-adapter/Cargo.toml and opencode-adapter/Cargo.toml:
  ```toml
  dirs = "5.0"
  ```

  **Step 2: Update codex-adapter/src/error.rs**

  The current Codex error type has `ExecutableNotFound(String)` which is good (same as Claude). Keep it. No changes needed to error.rs for codex — the `ExecutableNotFound` variant already accepts a string message.

  However, the existing `WhichError` variant converts from `which::Error` directly. Keep this for backward compatibility but the new discovery function will return `ExecutableNotFound` with a helpful message instead.

  **Step 3: Rewrite codex-adapter/src/discovery.rs**

  Replace the current 1-line discovery with a full 5-step resolution matching Claude's pattern:

  ```rust
  //! Locates the Codex CLI binary on the host system.

  use crate::error::CodexError;
  use std::path::PathBuf;
  use which::which;

  /// Environment variable that overrides the default Codex CLI binary path.
  pub const CODEX_BIN_ENV_VAR: &str = "CODEX_ADAPTER_BIN";

  /// Locates the Codex CLI executable.
  ///
  /// Resolution order:
  /// 1. `explicit_path` if provided and the file exists.
  /// 2. The path in the `CODEX_ADAPTER_BIN` environment variable.
  /// 3. `codex` resolved via `$PATH`.
  /// 4. Common install locations (platform-specific).
  /// 5. Helpful error with install instructions.
  ///
  /// # Errors
  ///
  /// Returns `CodexError::ExecutableNotFound` when no valid executable can be
  /// located.
  pub fn discover_codex(explicit_path: Option<PathBuf>) -> Result<PathBuf, CodexError> {
      // 1. Explicit path
      if let Some(path) = explicit_path {
          if path.exists() {
              return Ok(path);
          }
          return Err(CodexError::ExecutableNotFound(format!(
              "Explicit path does not exist: {}",
              path.display()
          )));
      }

      // 2. Environment variable
      if let Ok(path_str) = std::env::var(CODEX_BIN_ENV_VAR) {
          let path = PathBuf::from(path_str);
          if path.exists() {
              return Ok(path);
          }
      }

      // 3. PATH lookup
      if let Ok(path) = which("codex") {
          return Ok(path);
      }

      // 4. Common install locations
      for location in fallback_locations() {
          if location.exists() {
              return Ok(location);
          }
      }

      // 5. Helpful error
      Err(CodexError::ExecutableNotFound(
          "codex not found. Install: npm install -g @openai/codex\n\
           Searched: PATH, common npm install locations.".to_string()
      ))
  }

  #[cfg(unix)]
  fn fallback_locations() -> Vec<PathBuf> {
      let mut locations = Vec::new();
      if let Some(home) = dirs::home_dir() {
          locations.push(home.join(".npm/bin/codex"));
          locations.push(home.join(".local/bin/codex"));
      }
      locations.push(PathBuf::from("/usr/local/bin/codex"));
      locations
  }

  #[cfg(windows)]
  fn fallback_locations() -> Vec<PathBuf> {
      let mut locations = Vec::new();
      if let Some(home) = dirs::home_dir() {
          locations.push(home.join("AppData/Roaming/npm/codex.cmd"));
      }
      locations.push(PathBuf::from(r"C:\Program Files\nodejs\codex.cmd"));
      locations
  }
  ```

  **IMPORTANT:** The function signature changed from `discover_codex()` to `discover_codex(explicit_path: Option<PathBuf>)`. Update ALL callers of `discover_codex()` in the workspace. There is one caller in `rig-provider/src/mcp_agent.rs` (in the `run_codex` function). Change:
  ```rust
  let path = codex_adapter::discover_codex()
  ```
  To:
  ```rust
  let path = codex_adapter::discover_codex(None)
  ```
  Also check codex-adapter/src/lib.rs for any re-export that needs updating — if `discover_codex` is re-exported, the public API signature changes too. Grep the workspace for `discover_codex` to find all call sites.

  **Step 4: Rewrite opencode-adapter/src/discovery.rs**

  Same pattern as Codex:

  ```rust
  //! Locates the `OpenCode` binary on the system.

  use crate::error::OpenCodeError;
  use std::path::PathBuf;
  use which::which;

  /// Environment variable that overrides the default OpenCode CLI binary path.
  pub const OPENCODE_BIN_ENV_VAR: &str = "OPENCODE_ADAPTER_BIN";

  /// Locates the OpenCode CLI executable.
  ///
  /// Resolution order:
  /// 1. `explicit_path` if provided and the file exists.
  /// 2. The path in the `OPENCODE_ADAPTER_BIN` environment variable.
  /// 3. `opencode` resolved via `$PATH`.
  /// 4. Common install locations (platform-specific).
  /// 5. Helpful error with install instructions.
  ///
  /// # Errors
  ///
  /// Returns `OpenCodeError::ExecutableNotFound` when no valid executable can be
  /// located.
  pub fn discover_opencode(explicit_path: Option<PathBuf>) -> Result<PathBuf, OpenCodeError> {
      // 1. Explicit path
      if let Some(path) = explicit_path {
          if path.exists() {
              return Ok(path);
          }
          return Err(OpenCodeError::ExecutableNotFound(format!(
              "Explicit path does not exist: {}",
              path.display()
          )));
      }

      // 2. Environment variable
      if let Ok(path_str) = std::env::var(OPENCODE_BIN_ENV_VAR) {
          let path = PathBuf::from(path_str);
          if path.exists() {
              return Ok(path);
          }
      }

      // 3. PATH lookup
      if let Ok(path) = which("opencode") {
          return Ok(path);
      }

      // 4. Common install locations
      for location in fallback_locations() {
          if location.exists() {
              return Ok(location);
          }
      }

      // 5. Helpful error
      Err(OpenCodeError::ExecutableNotFound(
          "opencode not found. Install: go install github.com/opencode-ai/opencode@latest\n\
           Searched: PATH, common install locations.".to_string()
      ))
  }

  #[cfg(unix)]
  fn fallback_locations() -> Vec<PathBuf> {
      let mut locations = Vec::new();
      if let Some(home) = dirs::home_dir() {
          // Go binary install location
          locations.push(home.join("go/bin/opencode"));
          locations.push(home.join(".local/bin/opencode"));
      }
      locations.push(PathBuf::from("/usr/local/bin/opencode"));
      locations
  }

  #[cfg(windows)]
  fn fallback_locations() -> Vec<PathBuf> {
      let mut locations = Vec::new();
      if let Some(home) = dirs::home_dir() {
          // Go binary install location on Windows
          locations.push(home.join("go/bin/opencode.exe"));
      }
      locations.push(PathBuf::from(r"C:\Program Files\Go\bin\opencode.exe"));
      locations
  }
  ```

  **IMPORTANT:** Same signature change as Codex. Update ALL callers of `discover_opencode()`:
  - In `rig-provider/src/mcp_agent.rs` (in the `run_opencode` function), change:
    ```rust
    let path = opencode_adapter::discover_opencode()
    ```
    To:
    ```rust
    let path = opencode_adapter::discover_opencode(None)
    ```
  - Check opencode-adapter/src/lib.rs for re-exports.
  - Grep the workspace for `discover_opencode` and `discover_codex` to find ALL call sites.

  Note for OpenCode: it's a Go binary (not npm), so fallback locations are under `~/go/bin/` not `~/.npm/bin/`.
  </action>
  <verify>
  Run `cargo check --all-targets` to verify the entire workspace compiles (signature changes propagated).
  Run `cargo test --all-features` to verify all tests pass.
  Grep all three discovery.rs for `dirs::home_dir` — should find usage in fallback functions.
  Grep all three discovery.rs for `Install:` — should find install hints in error messages.
  Grep workspace for `discover_codex()` and `discover_opencode()` with no arguments — should find zero matches (all updated to pass `None` or explicit path).
  Verify codex-adapter and opencode-adapter Cargo.toml both have `dirs = "5.0"`.
  </verify>
  <done>
  All three adapters have standardized 5-step discovery (explicit path, env var, PATH, fallbacks, helpful error).
  Codex and OpenCode now accept `Option<PathBuf>` for explicit path override.
  All callers in rig-provider/src/mcp_agent.rs updated to pass `None`.
  Fallback locations are platform-specific via cfg(unix)/cfg(windows).
  dirs crate added to all three adapter Cargo.toml files.
  Install hints included in all three error messages.
  Entire workspace compiles and tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --all-targets` compiles the entire workspace cleanly
2. `cargo test --all-features` — all tests pass
3. `cargo clippy --all-targets --all-features` — no new warnings
4. All three discovery.rs files have 5-step resolution pattern
5. All three discovery.rs files have platform-specific fallback_locations()
6. All three discovery.rs files have install hints in error messages
7. Codex and OpenCode discovery now accept `Option<PathBuf>` explicit path
8. All callers updated (grep for no-arg `discover_codex()` or `discover_opencode()` returns zero matches)
9. `dirs = "5.0"` present in all three adapter Cargo.toml files
</verification>

<success_criteria>
- Standardized discovery pattern across all three adapters
- Install hints guide users when binaries are not found
- Platform-specific fallback locations for both Unix and Windows
- dirs crate replaces any need for direct HOME env var access in discovery
- No compilation errors, all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-platform-hardening/06-02-SUMMARY.md`
</output>
