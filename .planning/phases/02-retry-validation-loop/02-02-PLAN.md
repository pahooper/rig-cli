---
phase: 02-retry-validation-loop
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - mcp/src/extraction/orchestrator.rs
  - mcp/src/extraction/mod.rs
  - mcp/src/tools.rs
autonomous: true

must_haves:
  truths:
    - "When agent submits invalid JSON, validation errors are fed back with schema and the agent retries"
    - "Retry loop attempts up to configurable max (default 3) with immediate retry (no backoff delay)"
    - "All failure types (parse, schema validation, callback rejection) count against same retry budget"
    - "Successful extraction returns (T, ExtractionMetrics) with attempt count, wall time, token estimates"
    - "Failed extraction returns ExtractionError::MaxRetriesExceeded with full attempt history and metrics"
    - "ValidateJsonTool feedback includes schema, echoed submission, instance paths, and attempt guidance"
  artifacts:
    - path: "mcp/src/extraction/orchestrator.rs"
      provides: "ExtractionOrchestrator with async retry loop"
      exports: ["ExtractionOrchestrator"]
      min_lines: 80
    - path: "mcp/src/extraction/mod.rs"
      provides: "Updated module declarations including orchestrator"
      contains: "pub mod orchestrator"
    - path: "mcp/src/tools.rs"
      provides: "Enhanced ValidateJsonTool with richer feedback"
      contains: "instance_path"
  key_links:
    - from: "mcp/src/extraction/orchestrator.rs"
      to: "mcp/src/extraction/feedback.rs"
      via: "build_validation_feedback and collect_validation_errors called in retry loop"
      pattern: "build_validation_feedback|collect_validation_errors"
    - from: "mcp/src/extraction/orchestrator.rs"
      to: "mcp/src/extraction/error.rs"
      via: "Returns ExtractionError variants on failure"
      pattern: "ExtractionError::"
    - from: "mcp/src/extraction/orchestrator.rs"
      to: "mcp/src/extraction/metrics.rs"
      via: "Builds ExtractionMetrics with estimate_tokens on both success and failure paths"
      pattern: "estimate_tokens|ExtractionMetrics"
    - from: "mcp/src/tools.rs"
      to: "jsonschema::Validator::iter_errors"
      via: "Enhanced error collection with instance paths"
      pattern: "iter_errors.*instance_path"
---

<objective>
Build the extraction orchestrator -- the async retry loop that runs an agent, validates output against a JSON schema, feeds validation errors back with full context, and tracks metrics. Also enhance the existing ValidateJsonTool to produce richer feedback.

Purpose: This is the core value delivery of Phase 2. After this plan, the system can automatically retry when agents submit invalid JSON, feeding errors back until the agent produces conforming output or exhausts attempts. This directly implements requirements EXTR-01 (retry loop with validation feedback) and EXTR-04 (attempt/cost tracking).

Output: Working `ExtractionOrchestrator` in `mcp/src/extraction/orchestrator.rs` that compiles and is exported from the mcp crate. Enhanced `ValidateJsonTool` with instance paths and schema echo.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-retry-validation-loop/02-CONTEXT.md
@.planning/phases/02-retry-validation-loop/02-RESEARCH.md
@.planning/phases/02-retry-validation-loop/02-01-SUMMARY.md
@mcp/src/lib.rs
@mcp/src/tools.rs
@mcp/src/extraction/mod.rs
@mcp/src/extraction/error.rs
@mcp/src/extraction/metrics.rs
@mcp/src/extraction/feedback.rs
@mcp/src/extraction/config.rs
@mcp/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExtractionOrchestrator with async retry loop</name>
  <files>
    mcp/src/extraction/orchestrator.rs
    mcp/src/extraction/mod.rs
  </files>
  <action>
Create `mcp/src/extraction/orchestrator.rs` containing the `ExtractionOrchestrator` struct and its retry logic.

**ExtractionOrchestrator struct:**
```
pub struct ExtractionOrchestrator {
    schema: serde_json::Value,
    config: ExtractionConfig,
}
```

Note: NOT generic over T. The orchestrator works with serde_json::Value for validation and returns Value on success. The caller deserializes to T. This avoids complex generic bounds and PhantomData.

**Constructor and builder methods:**
- `pub fn new(schema: serde_json::Value) -> Self` -- creates with default ExtractionConfig
- `pub fn with_config(schema: serde_json::Value, config: ExtractionConfig) -> Self`
- `#[must_use] pub fn max_attempts(mut self, max: usize) -> Self` -- fluent builder

**Core method -- extract:**
```rust
pub async fn extract<F, Fut>(
    &self,
    agent_fn: F,
    initial_prompt: String,
) -> Result<(serde_json::Value, ExtractionMetrics), ExtractionError>
where
    F: Fn(String) -> Fut,
    Fut: std::future::Future<Output = Result<String, String>>,
```

The `agent_fn` closure takes a prompt string and returns the agent's text output (or error string). This abstraction lets any adapter be used.

**Retry loop logic (CRITICAL -- follow exactly):**

1. Create `jsonschema::Validator` from `self.schema`. Return `ExtractionError::SchemaError` if this fails.
2. Initialize: `let start = tokio::time::Instant::now();`, empty `attempt_history: Vec<AttemptRecord>`, `total_input_chars: usize = 0`, `total_output_chars: usize = 0`, `current_prompt = initial_prompt.clone()`.
3. Loop `for attempt in 1..=self.config.max_attempts`:
   a. Track input chars: `total_input_chars += current_prompt.chars().count();`
   b. Call `agent_fn(current_prompt.clone()).await`. On Err, return `ExtractionError::AgentError(e)`.
   c. Track output chars: `total_output_chars += agent_output.chars().count();`
   d. Try `serde_json::from_str::<serde_json::Value>(&agent_output)`. On parse failure:
      - Record attempt in history with empty submitted_json (Value::Null), validation_errors = vec![parse error message], raw_agent_output = agent_output.clone()
      - If this is NOT the last attempt, build parse error feedback using `build_parse_error_feedback` and set as current_prompt (conversation continuation strategy)
      - If this IS the last attempt, fall through to MaxRetriesExceeded
      - `continue` to next iteration (parse failures count against retry budget per CONTEXT.md)
   e. Validate parsed JSON: `let errors = collect_validation_errors(&self.schema, &parsed);`
   f. If errors is empty -- SUCCESS:
      - Build ExtractionMetrics with attempt count, wall_time, estimated tokens via `estimate_tokens`
      - Return `Ok((parsed, metrics))`
   g. If errors is not empty -- validation failed:
      - Record AttemptRecord with submitted_json, validation_errors, raw_agent_output, elapsed
      - Push to attempt_history
      - If NOT last attempt, build feedback: `let feedback = build_validation_feedback(&self.schema, &parsed, &errors, attempt, self.config.max_attempts);`
      - Conversation continuation: `current_prompt = format!("{}\n\n{}", current_prompt, feedback);`
      - Continue loop
4. After loop exhausted, return `ExtractionError::MaxRetriesExceeded` with:
   - attempts: self.config.max_attempts
   - max_attempts: self.config.max_attempts
   - history: attempt_history
   - raw_output: current_prompt (contains full conversation with feedback)
   - metrics: ExtractionMetrics with total_attempts, wall_time, estimated tokens from totals

**Also add `extract_typed` convenience method:**
```rust
pub async fn extract_typed<T, F, Fut>(
    &self,
    agent_fn: F,
    initial_prompt: String,
) -> Result<(T, ExtractionMetrics), ExtractionError>
where
    T: serde::de::DeserializeOwned,
    F: Fn(String) -> Fut,
    Fut: std::future::Future<Output = Result<String, String>>,
```
This calls `self.extract(agent_fn, initial_prompt).await?` then deserializes the Value to T via `serde_json::from_value`. On deserialization error, return `ExtractionError::ParseError` with the error message.

**Update mod.rs:**
- Add `pub mod orchestrator;` to mod.rs
- Add `pub use orchestrator::ExtractionOrchestrator;` to the re-exports

**Important implementation notes:**
- Do NOT use `.unwrap()` or `.expect()` anywhere -- clippy will flag these
- Use `serde_json::to_string_pretty(&value).unwrap_or_else(|_| value.to_string())` pattern for JSON formatting
- The loop should NOT have exponential backoff -- immediate retry per CONTEXT.md decision
- Parse failures and validation failures both count against the same retry budget (CONTEXT.md decision)
- Metrics must be built on BOTH success and failure paths (CONTEXT.md pitfall #4)
- Use conversation continuation strategy (append feedback to prompt), not fresh prompt
  </action>
  <verify>
Run `cargo check -p rig-mcp-server 2>&1` -- must compile with zero errors. Run `cargo clippy -p rig-mcp-server -- -W clippy::pedantic 2>&1` -- no new warnings beyond existing missing-docs.
  </verify>
  <done>
ExtractionOrchestrator compiles with extract() and extract_typed() methods. Retry loop validates JSON against schema, feeds back errors with full context, tracks metrics on both paths. All failure types count against same budget. No .unwrap()/.expect() in codebase.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance ValidateJsonTool with richer feedback and verify full compilation</name>
  <files>
    mcp/src/tools.rs
  </files>
  <action>
Enhance the existing `ValidateJsonTool::call()` method in `mcp/src/tools.rs` to produce richer validation feedback that matches the Phase 2 design:

**Current behavior (tools.rs line 309-324):**
- On valid: returns "JSON is valid. You may now call the submit tool."
- On invalid: returns "JSON is invalid. Please fix the following errors before submitting:\n{errors}" where errors are just `error.to_string()` without instance paths

**Enhanced behavior:**
- On valid: returns "JSON is valid. You may now call the submit tool." (unchanged)
- On invalid: returns a richer message that includes:
  1. Error list with instance paths: `format!("  - At path '{}': {}", error.instance_path, error)` for each error
  2. The full schema (pretty-printed) so the agent can compare
  3. The agent's submission (pretty-printed) echoed back

Format for invalid case:
```
JSON validation failed.

Errors:
  - At path '/field': error description
  - At path '/other': error description

Expected schema:
{pretty printed self.schema}

Your submission:
{pretty printed args.json}

Please fix all errors above and resubmit using the validate_json tool, then call submit.
```

Use `serde_json::to_string_pretty()` with `.unwrap_or_else(|_| value.to_string())` fallback pattern (no .unwrap()).

**Do NOT change:**
- The ValidateJsonTool struct definition or field types
- The ValidateJsonArgs struct
- The Tool trait implementation signature
- The SubmitTool or JsonExampleTool (those remain unchanged in this phase)

**After making changes, run full workspace compilation:**
Run `cargo check --workspace` to ensure the enhanced tool doesn't break any downstream crates (rig-provider, adapters).
Run `cargo clippy --workspace -- -W clippy::pedantic` to verify no new warnings.
  </action>
  <verify>
Run `cargo check --workspace 2>&1` -- zero errors across all crates. Run `cargo clippy -p rig-mcp-server -- -W clippy::pedantic 2>&1` -- no new warnings. Verify that the ValidateJsonTool output includes "At path" and "Expected schema:" in the invalid case by reading the modified tools.rs.
  </verify>
  <done>
ValidateJsonTool produces feedback with instance paths, full schema, and echoed submission. ExtractionOrchestrator is exported and accessible. Full workspace compiles cleanly. Phase 2 requirements EXTR-01 (retry with validation feedback) and EXTR-04 (attempt/cost tracking) are implemented at the library level.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` passes with zero errors
2. `cargo clippy --workspace -- -W clippy::pedantic` has no new warnings
3. `ExtractionOrchestrator::new(schema).extract(agent_fn, prompt).await` compiles
4. `ExtractionOrchestrator::new(schema).extract_typed::<T, _, _>(agent_fn, prompt).await` compiles
5. ValidateJsonTool error output includes instance paths ("At path '/...'") and schema echo
6. ExtractionError::MaxRetriesExceeded includes history, raw_output, and metrics
7. ExtractionMetrics is populated on both success and failure paths
8. No .unwrap() or .expect() in any new or modified code
</verification>

<success_criteria>
- ExtractionOrchestrator lives in mcp/src/extraction/orchestrator.rs and is exported from the crate
- extract() method runs bounded retry loop (1..=max_attempts) with immediate retry (no backoff)
- Parse failures and schema validation failures both count against the same retry budget
- Validation feedback includes full schema + echoed submission + all errors with instance paths + attempt counter
- extract_typed<T>() deserializes successful Value to T
- ExtractionMetrics populated with estimate_tokens on both success and failure paths
- ValidateJsonTool enhanced with instance paths and schema echo
- Full workspace compiles: `cargo check --workspace` passes
- No .unwrap() or .expect() in any new or modified code
</success_criteria>

<output>
After completion, create `.planning/phases/02-retry-validation-loop/02-02-SUMMARY.md`
</output>
