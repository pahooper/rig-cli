---
phase: 10-opencode-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - opencode-adapter/src/cmd.rs
  - opencode-adapter/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "cmd.rs has module-level documentation matching Claude/Codex pattern"
    - "lib.rs has comprehensive module-level documentation"
    - "Module docs include Flag Reference, Containment Strategy, Version Notes sections"
    - "Documentation explains OpenCode-specific containment (cwd + env vars, not CLI flags)"
    - "All clippy pedantic warnings are resolved"
    - "CLI flag combination tests exist in cmd.rs test module"
  artifacts:
    - path: "opencode-adapter/src/cmd.rs"
      provides: "CLI flag documentation, containment explanation, and flag combination tests"
      contains: "## Flag Reference"
    - path: "opencode-adapter/src/lib.rs"
      provides: "Module-level documentation with usage examples"
      contains: "## Quick Start"
  key_links:
    - from: "opencode-adapter/src/cmd.rs"
      to: "types.rs"
      via: "OpenCodeConfig import"
      pattern: "use crate::types::OpenCodeConfig"
---

<objective>
Add comprehensive module-level documentation to OpenCode adapter matching Claude Code and Codex adapter quality, and add CLI flag combination tests.

Purpose: Production parity requires same documentation depth and test coverage. OpenCode has different containment mechanisms (working directory + env vars instead of CLI flags), which must be clearly documented and tested.
Output: Module-level docs in cmd.rs and lib.rs, flag combination tests in cmd.rs test module, clippy pedantic clean.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-opencode-adapter/10-CONTEXT.md
@.planning/phases/10-opencode-adapter/10-RESEARCH.md
@claudecode-adapter/src/cmd.rs (reference for documentation structure and test patterns)
@claudecode-adapter/src/lib.rs (reference for module docs)
@opencode-adapter/src/cmd.rs
@opencode-adapter/src/lib.rs
@opencode-adapter/src/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add module-level documentation to cmd.rs</name>
  <files>opencode-adapter/src/cmd.rs</files>
  <action>
Replace the minimal doc comment with comprehensive module-level documentation matching Claude/Codex pattern.

**IMPORTANT:** Verify and preserve the existing `use crate::types::OpenCodeConfig` import at line 3 of cmd.rs (required by key_link). Do NOT modify any existing code â€” only replace the doc comment at the top.

```rust
//! Command-line argument builder for OpenCode CLI invocations.
//!
//! ## Flag Reference
//!
//! ### Model and Output Flags
//! - `--model <model>`: Model selection (e.g., opencode/big-pickle)
//! - `--print-logs`: Enable debug log output
//! - `--log-level <level>`: Log verbosity (debug, info, warn, error)
//!
//! ### Server Flags (for OpenCode server mode)
//! - `--port <port>`: Server port override
//! - `--hostname <host>`: Server hostname override
//!
//! ## Containment Strategy
//!
//! **IMPORTANT:** OpenCode has no CLI flags for sandbox, approval policy, or tool
//! restriction (unlike Claude Code and Codex). Containment is achieved through:
//!
//! 1. **Working Directory Isolation**: `Command::current_dir()` sets cwd, not a CLI arg
//! 2. **MCP Config via Environment**: `OPENCODE_CONFIG` env var points to config file
//! 3. **System Prompt Prepending**: No `--system-prompt` flag; prompt is prepended to message
//!
//! ### Containment Comparison
//! | Feature | Claude Code | Codex | OpenCode |
//! |---------|-------------|-------|----------|
//! | Sandbox | --tools "" | --sandbox | (none) |
//! | Tool restriction | --allowed-tools | (none) | (none) |
//! | Working dir | --cwd | --cd | Command::current_dir() |
//! | MCP config | --mcp-config | -c overrides | OPENCODE_CONFIG env |
//! | System prompt | --system-prompt | (prepend) | (prepend) |
//!
//! ## Version Notes
//! - `run` subcommand: Standard execution mode
//! - `--model`: Supports opencode/big-pickle and other available models
//! - No version-specific flags known; OpenCode CLI has minimal flag surface
//!
//! ## Known Limitations
//! - No filesystem sandbox mechanism (containment relies on process isolation)
//! - No tool restriction flags (all configured tools are available)
//! - System prompt must be prepended to user message (no dedicated flag)
//!
//! ## External References
//! - [OpenCode Documentation](https://opencode.ai/docs/)
//! - [OpenCode MCP Servers](https://opencode.ai/docs/mcp-servers/)
```

Keep all existing code unchanged, including the `use crate::types::OpenCodeConfig` import and all existing tests.
  </action>
  <verify>cargo doc -p opencode-adapter --no-deps (docs render without warnings) && grep -q "use crate::types::OpenCodeConfig" opencode-adapter/src/cmd.rs</verify>
  <done>cmd.rs has module-level documentation with Flag Reference, Containment Strategy, Containment Comparison table, Version Notes, Known Limitations, and External References sections. The OpenCodeConfig import is preserved.</done>
</task>

<task type="auto">
  <name>Task 2: Add module-level documentation to lib.rs</name>
  <files>opencode-adapter/src/lib.rs</files>
  <action>
Expand the minimal lib.rs documentation to match claudecode-adapter/src/lib.rs quality:

```rust
//! Adapter crate for running the OpenCode CLI as a subprocess.
//!
//! This crate provides a Rust interface for executing the OpenCode CLI tool,
//! with streaming output, timeout handling, and graceful shutdown support.
//!
//! ## Quick Start
//!
//! ```rust,ignore
//! use opencode_adapter::{discover_opencode, OpenCodeCli, OpenCodeConfig};
//! use std::time::Duration;
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     // Discover and validate CLI
//!     let path = discover_opencode(None)?;
//!     let cli = OpenCodeCli::new(path);
//!     cli.check_health().await?;
//!
//!     // Configure and run
//!     let config = OpenCodeConfig {
//!         model: Some("opencode/big-pickle".to_string()),
//!         timeout: Duration::from_secs(120),
//!         ..OpenCodeConfig::default()
//!     };
//!
//!     let result = cli.run("What is 2 + 2?", &config).await?;
//!     println!("Output: {}", result.stdout);
//!     Ok(())
//! }
//! ```
//!
//! ## Architecture
//!
//! The adapter follows the same structure as `claudecode-adapter` and `codex-adapter`:
//!
//! - **Discovery** ([`discover_opencode`]): Locates the CLI binary via PATH, env var, or fallbacks
//! - **Configuration** ([`OpenCodeConfig`]): Typed config for model, timeout, working directory
//! - **Execution** ([`run_opencode`]): Spawns subprocess with bounded output and timeout
//! - **Streaming** ([`OpenCodeCli::stream`]): Real-time event streaming via channels
//! - **Errors** ([`OpenCodeError`]): Rich error types with context (PID, elapsed time, partial output)
//!
//! ## Containment
//!
//! Unlike Claude Code and Codex, OpenCode has no CLI flags for sandboxing or tool restriction.
//! Containment is achieved through:
//!
//! - **Working directory**: Set via [`OpenCodeConfig::cwd`], passed to `Command::current_dir()`
//! - **MCP configuration**: Set via [`OpenCodeConfig::mcp_config_path`], passed as `OPENCODE_CONFIG` env var
//! - **System prompt**: Set via [`OpenCodeConfig::prompt`], prepended to the user message
//!
//! ## Process Lifecycle
//!
//! The adapter implements production-grade subprocess management:
//!
//! 1. **Bounded channels**: 100-message capacity prevents memory exhaustion
//! 2. **Output limits**: 10MB cap with [`OpenCodeError::OutputTruncated`] on overflow
//! 3. **Graceful shutdown**: SIGTERM with 5-second grace period, then SIGKILL
//! 4. **Task cleanup**: `JoinSet` ensures all async tasks complete or abort
//!
//! ## Feature Parity
//!
//! This adapter is production-hardened to the same standards as `claudecode-adapter`
//! and `codex-adapter`. All three adapters share:
//!
//! - Identical error handling patterns
//! - Same timeout and shutdown behavior
//! - Equivalent test coverage (unit + E2E)
//! - Zero clippy pedantic warnings
```

Keep all existing code (module declarations, imports, struct definitions, impl blocks) unchanged.
  </action>
  <verify>cargo doc -p opencode-adapter --no-deps (docs render, Quick Start example visible)</verify>
  <done>lib.rs has comprehensive module-level documentation with Quick Start, Architecture, Containment, Process Lifecycle, and Feature Parity sections</done>
</task>

<task type="auto">
  <name>Task 3: Add CLI flag combination tests to cmd.rs</name>
  <files>opencode-adapter/src/cmd.rs</files>
  <action>
Add flag combination tests to the existing test module in cmd.rs, matching the Claude Code adapter pattern. Since OpenCode has no containment CLI flags, these tests document the _absence_ of such flags and verify containment is achieved via other means.

Add the following tests to the existing `#[cfg(test)] mod tests` block:

```rust
    #[test]
    fn test_full_config_combination() {
        // Test all config options together
        let config = OpenCodeConfig {
            model: Some("opencode/big-pickle".to_string()),
            print_logs: true,
            log_level: Some("DEBUG".to_string()),
            port: Some(8080),
            hostname: Some("localhost".to_string()),
            prompt: Some("You are helpful.".to_string()),
            cwd: Some(std::path::PathBuf::from("/tmp/work")),
            mcp_config_path: Some(std::path::PathBuf::from("/tmp/mcp.json")),
            timeout: std::time::Duration::from_secs(60),
        };
        let args = build_args("test prompt", &config);
        let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

        // Verify CLI flags that DO appear
        assert!(args_str.windows(2).any(|w| w[0] == "--model" && w[1] == "opencode/big-pickle"));
        assert!(args_str.contains(&"--print-logs"));
        assert!(args_str.windows(2).any(|w| w[0] == "--log-level" && w[1] == "DEBUG"));
        assert!(args_str.windows(2).any(|w| w[0] == "--port" && w[1] == "8080"));
        assert!(args_str.windows(2).any(|w| w[0] == "--hostname" && w[1] == "localhost"));

        // Verify containment via NON-CLI mechanisms (these should NOT appear in args)
        assert!(!args_str.iter().any(|a| a.contains("/tmp/work")), "cwd should not appear in args");
        assert!(!args_str.iter().any(|a| a.contains("mcp.json")), "MCP config path should not appear in args");
    }

    #[test]
    fn test_server_flags_combination() {
        // Port + hostname together (server mode configuration)
        let config = OpenCodeConfig {
            port: Some(9000),
            hostname: Some("0.0.0.0".to_string()),
            ..OpenCodeConfig::default()
        };
        let args = build_args("test prompt", &config);
        let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

        assert!(args_str.windows(2).any(|w| w[0] == "--port" && w[1] == "9000"));
        assert!(args_str.windows(2).any(|w| w[0] == "--hostname" && w[1] == "0.0.0.0"));
    }

    #[test]
    fn test_logging_flags_combination() {
        // print_logs + log_level together
        let config = OpenCodeConfig {
            print_logs: true,
            log_level: Some("WARN".to_string()),
            ..OpenCodeConfig::default()
        };
        let args = build_args("test prompt", &config);
        let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

        assert!(args_str.contains(&"--print-logs"));
        assert!(args_str.windows(2).any(|w| w[0] == "--log-level" && w[1] == "WARN"));
    }

    #[test]
    fn test_containment_flags_absent() {
        // Verify NO containment flags exist (unlike Claude Code and Codex)
        // This documents OpenCode's containment model: process-level, not CLI flags
        let config = OpenCodeConfig {
            cwd: Some(std::path::PathBuf::from("/isolated")),
            mcp_config_path: Some(std::path::PathBuf::from("/config/mcp.json")),
            ..OpenCodeConfig::default()
        };
        let args = build_args("test prompt", &config);
        let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

        // Claude Code containment flags (must NOT appear)
        assert!(!args_str.contains(&"--tools"));
        assert!(!args_str.contains(&"--allowed-tools"));
        assert!(!args_str.contains(&"--disallowed-tools"));
        assert!(!args_str.contains(&"--strict-mcp-config"));

        // Codex containment flags (must NOT appear)
        assert!(!args_str.contains(&"--sandbox"));
        assert!(!args_str.contains(&"--ask-for-approval"));
        assert!(!args_str.contains(&"--full-auto"));

        // Generic containment flags (must NOT appear)
        assert!(!args_str.iter().any(|a| a.contains("--cd")));
        assert!(!args_str.iter().any(|a| a.contains("--cwd")));
        assert!(!args_str.iter().any(|a| a.contains("--mcp-config")));
    }

    #[test]
    fn test_prompt_with_model_combination() {
        // System prompt + model selection (common production config)
        let config = OpenCodeConfig {
            model: Some("opencode/fast".to_string()),
            prompt: Some("Extract JSON only.".to_string()),
            ..OpenCodeConfig::default()
        };
        let args = build_args("Parse this: {}", &config);
        let args_str: Vec<&str> = args.iter().filter_map(|s| s.to_str()).collect();

        assert!(args_str.windows(2).any(|w| w[0] == "--model" && w[1] == "opencode/fast"));
        // System prompt is prepended, so last arg should contain both
        let last = args_str.last().unwrap();
        assert!(last.contains("Extract JSON only."), "System prompt should be prepended");
        assert!(last.contains("Parse this: {}"), "User message should follow");
    }
```

These tests document:
1. Full config combination with all options
2. Server mode flag combinations
3. Logging flag combinations
4. Explicit verification that containment flags from other CLIs are NOT present
5. Common production config (prompt + model)
  </action>
  <verify>cargo test -p opencode-adapter cmd::tests (all new flag combination tests pass)</verify>
  <done>cmd.rs test module has flag combination tests matching Claude/Codex pattern, documenting OpenCode's containment model (no CLI flags, process-level isolation)</done>
</task>

<task type="auto">
  <name>Task 4: Run clippy pedantic pass and fix all warnings</name>
  <files>opencode-adapter/src/cmd.rs, opencode-adapter/src/lib.rs, opencode-adapter/src/types.rs, opencode-adapter/src/error.rs, opencode-adapter/src/process.rs, opencode-adapter/src/discovery.rs</files>
  <action>
Run `cargo clippy -p opencode-adapter -- -W clippy::pedantic` and resolve ALL warnings.

Common pedantic fixes to expect:
- Add `#[must_use]` attributes to public functions that return values
- Use `Self` instead of type name in impl blocks
- Add documentation to public items if missing
- Fix any needless borrows or clones
- Add `/// # Errors` sections to functions that return `Result`

Each fix should have an inline comment if the reason isn't obvious.

For any `#[allow(clippy::...)]` attributes that must remain, add a justification comment:
```rust
#[allow(clippy::module_name_repetitions)] // Type name is clearer with full prefix in public API
pub struct OpenCodeConfig { ... }
```

After fixing, verify with:
```bash
cargo clippy -p opencode-adapter -- -W clippy::pedantic 2>&1 | grep -c warning
# Should return 0
```
  </action>
  <verify>cargo clippy -p opencode-adapter -- -W clippy::pedantic (zero warnings)</verify>
  <done>All clippy pedantic warnings resolved, any necessary #[allow] attributes have justification comments</done>
</task>

</tasks>

<verification>
1. `cargo clippy -p opencode-adapter -- -W clippy::pedantic` - zero warnings
2. `cargo test -p opencode-adapter` - all tests pass (including new flag combination tests)
3. `cargo doc -p opencode-adapter --no-deps` - documentation renders without warnings
4. Review cmd.rs has containment comparison table
5. Review lib.rs has Quick Start example
6. Review cmd.rs test module has flag combination tests
7. Verify `use crate::types::OpenCodeConfig` import is preserved in cmd.rs
</verification>

<success_criteria>
- cmd.rs module documentation with Flag Reference, Containment Strategy, Containment Comparison table
- lib.rs module documentation with Quick Start, Architecture, Containment, Process Lifecycle sections
- cmd.rs test module has flag combination tests (test_full_config_combination, test_containment_flags_absent, etc.)
- All clippy pedantic warnings resolved (zero warnings from pedantic pass)
- All existing and new tests pass
- Documentation explains OpenCode-specific containment (cwd + env vars, not CLI flags)
- OpenCodeConfig import preserved in cmd.rs (key_link verified)
</success_criteria>

<output>
After completion, create `.planning/phases/10-opencode-adapter/10-01-SUMMARY.md`
</output>
