---
phase: 03-payload-instruction-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - rig-provider/examples/mcp_tool_agent_e2e.rs
  - rig-provider/examples/payload_extraction_e2e.rs
autonomous: true

must_haves:
  truths:
    - "A working example demonstrates .payload() injecting file/text content into extraction"
    - "The example uses McpToolAgent builder with payload + default workflow template"
    - "The example binary supports server mode (RIG_MCP_SERVER=1) and client mode"
    - "The three-tool workflow (example -> validate -> submit) is exercised end-to-end"
    - "Existing mcp_tool_agent_e2e example still works (not broken)"
  artifacts:
    - path: "rig-provider/examples/payload_extraction_e2e.rs"
      provides: "E2E example demonstrating payload injection with McpToolAgent"
      min_lines: 60
    - path: "rig-provider/examples/mcp_tool_agent_e2e.rs"
      provides: "Existing example, optionally updated to show payload usage in comment"
  key_links:
    - from: "payload_extraction_e2e.rs client mode"
      to: "McpToolAgent::builder().payload()"
      via: ".payload(SOURCE_TEXT) call in builder chain"
      pattern: "\\.payload\\("
    - from: "payload_extraction_e2e.rs server mode"
      to: "JsonSchemaToolkit / ToolSetExt"
      via: "build_toolset() -> serve_stdio()"
      pattern: "serve_stdio"
---

<objective>
Create a payload extraction E2E example and verify the full Phase 3 integration.

Purpose: Prove that the payload injection and workflow enforcement from Plan 01 work end-to-end
by creating a concrete example that passes context data to an agent via .payload() and demonstrates
the three-tool workflow enforcement. This also serves as living documentation for developers.

Output: A new `payload_extraction_e2e.rs` example demonstrating payload-driven extraction,
plus workspace-level compilation verification.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payload-instruction-system/03-RESEARCH.md
@.planning/phases/03-payload-instruction-system/03-01-SUMMARY.md
@rig-provider/src/mcp_agent.rs
@rig-provider/examples/mcp_tool_agent_e2e.rs
@mcp/src/tools.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payload_extraction_e2e example</name>
  <files>rig-provider/examples/payload_extraction_e2e.rs</files>
  <action>
Create a new example file `rig-provider/examples/payload_extraction_e2e.rs` that demonstrates
payload-driven structured extraction using McpToolAgent.

The example should follow the exact same dual-mode pattern as `mcp_tool_agent_e2e.rs`:
- Server mode via `RIG_MCP_SERVER=1` env var
- Client mode as default
- CLI arg for adapter selection (claude/codex/opencode)

Structure:

1. Define a target extraction type (e.g., `DocumentAnalysis` with fields like title, author,
   key_topics: Vec<String>, sentiment: String, summary: String, word_count: u32).

2. Define a SOURCE_TEXT constant containing a realistic text passage (like the one in
   extraction_summarize_e2e.rs, or similar prose about a technology topic).

3. `build_toolset()` function creates JsonSchemaToolkit<DocumentAnalysis> with a concrete example,
   adds submit/validate/example to a ToolSet.

4. Server mode: call `build_toolset().into_handler().await?.serve_stdio().await?`

5. Client mode:
   ```rust
   let result = McpToolAgent::builder()
       .toolset(build_toolset())
       .prompt("Analyze the provided document and extract structured metadata.")
       .payload(SOURCE_TEXT)  // <-- This is the key Phase 3 feature
       .adapter(adapter)
       .server_name("rig_extraction")
       .timeout(Duration::from_secs(120))
       .run()
       .await?;
   ```

6. Print exit code, duration, stdout, stderr.

Add a module-level doc comment explaining this example demonstrates Phase 3's payload injection.
Include a `Run with:` line in the doc comment.

IMPORTANT:
- Follow the exact pattern of mcp_tool_agent_e2e.rs for structure and style.
- Use `rig_provider::{CliAdapter, McpToolAgent}` imports (matching existing example).
- No .unwrap() or .expect() in new code.
- The example must compile: `cargo check --example payload_extraction_e2e -p rig-provider`
  </action>
  <verify>
Run `cargo check --example payload_extraction_e2e -p rig-provider` to confirm compilation.
Run `cargo clippy --example payload_extraction_e2e -p rig-provider -- -D warnings` for lint check.
  </verify>
  <done>
payload_extraction_e2e.rs exists, compiles, demonstrates .payload() usage with McpToolAgent builder.
  </done>
</task>

<task type="auto">
  <name>Task 2: Workspace-wide compilation and Phase 3 verification</name>
  <files>rig-provider/examples/mcp_tool_agent_e2e.rs</files>
  <action>
1. Run full workspace compilation: `cargo check --workspace`
2. Run full workspace clippy: `cargo clippy --workspace -- -D warnings`
3. Run doc generation for rig-provider: `cargo doc -p rig-provider --no-deps`
4. Verify all examples compile:
   - `cargo check --example mcp_tool_agent_e2e -p rig-provider`
   - `cargo check --example payload_extraction_e2e -p rig-provider`
   - `cargo check --example extraction_e2e -p rig-provider`
   - `cargo check --example extraction_retry_e2e -p rig-provider`
   - `cargo check --example extraction_summarize_e2e -p rig-provider`

5. Optionally, add a brief comment to the top of mcp_tool_agent_e2e.rs pointing to
   payload_extraction_e2e.rs for the payload demo:
   Add a line to the doc comment like:
   `//! See also `payload_extraction_e2e.rs` for payload injection demo.`

If any workspace warnings or errors are found, fix them. The goal is zero clippy warnings
across the workspace (or at least no NEW warnings introduced by Phase 3).

IMPORTANT: Do NOT attempt to run the E2E examples (they require real CLI agents). Only verify
compilation.
  </action>
  <verify>
`cargo check --workspace` succeeds with zero errors.
`cargo clippy --workspace -- -D warnings` passes (or pre-existing warnings only).
All 5 examples compile.
`cargo doc -p rig-provider --no-deps` succeeds.
  </verify>
  <done>
Full workspace compiles. All examples compile. No new clippy warnings. Docs generate. Phase 3 requirements verified at the compilation level: .payload() exists and is usable, .instruction_template() exists and is usable, DEFAULT_WORKFLOW_TEMPLATE enforces three-tool pattern.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` passes
2. `cargo clippy --workspace -- -D warnings` passes (no new warnings)
3. All examples compile successfully
4. `cargo doc -p rig-provider --no-deps` generates docs
5. `payload_extraction_e2e.rs` uses `.payload()` in builder chain
6. `payload_extraction_e2e.rs` follows dual-mode pattern (server/client)
7. Existing `mcp_tool_agent_e2e.rs` still compiles unchanged (or with minor doc comment)
</verification>

<success_criteria>
- New payload_extraction_e2e example exists and compiles
- Example demonstrates .payload(SOURCE_TEXT) with McpToolAgent builder
- Example follows established dual-mode (server/client) pattern
- All existing examples still compile (no regressions)
- Workspace compiles and passes clippy
- Phase 3 requirements are demonstrably met:
  - EXTR-02: .payload() allows attaching file contents/text blobs
  - EXTR-03: DEFAULT_WORKFLOW_TEMPLATE forces example->validate->submit
  - EXTR-05: Three-tool pattern is the enforced mechanism
</success_criteria>

<output>
After completion, create `.planning/phases/03-payload-instruction-system/03-02-SUMMARY.md`
</output>
