---
phase: 03-payload-instruction-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rig-provider/src/mcp_agent.rs
autonomous: true

must_haves:
  truths:
    - "Developer can call .payload(data) on McpToolAgentBuilder to attach context data"
    - "Developer can call .instruction_template(tmpl) on McpToolAgentBuilder for custom workflow instructions"
    - "When payload is provided, the user prompt is wrapped in 4-block XML structure (instructions/context/task/output_format)"
    - "When no payload is provided, prompt construction behaves identically to Phase 2.1 (backward compatible)"
    - "Default workflow template enforces example -> validate -> submit numbered steps"
    - "System prompt includes explicit workflow steps and constraint language"
  artifacts:
    - path: "rig-provider/src/mcp_agent.rs"
      provides: "Builder with payload and instruction_template fields, DEFAULT_WORKFLOW_TEMPLATE const, enhanced prompt construction"
      contains: "DEFAULT_WORKFLOW_TEMPLATE"
      exports: ["McpToolAgentBuilder"]
  key_links:
    - from: "McpToolAgentBuilder::payload()"
      to: "run() prompt construction"
      via: "self.payload field consumed in build_user_prompt()"
      pattern: "fn build_user_prompt"
    - from: "McpToolAgentBuilder::instruction_template()"
      to: "run() system prompt construction"
      via: "self.instruction_template or DEFAULT_WORKFLOW_TEMPLATE used in system prompt"
      pattern: "DEFAULT_WORKFLOW_TEMPLATE"
    - from: "DEFAULT_WORKFLOW_TEMPLATE"
      to: "full_system_prompt in run()"
      via: "Workflow template injected into system prompt alongside mcp_instruction"
      pattern: "workflow.*template"
---

<objective>
Add payload injection and instruction template enforcement to McpToolAgentBuilder.

Purpose: Enable developers to pass context data (file contents, text blobs) to agents and enforce
the three-tool workflow (example -> validate -> submit) via structured instruction templates.
This is the core implementation for Phase 3's requirements (EXTR-02, EXTR-03, EXTR-05).

Output: Enhanced McpToolAgentBuilder with .payload() and .instruction_template() methods,
DEFAULT_WORKFLOW_TEMPLATE constant, and refactored prompt/system_prompt construction using
4-block XML structure when payload is present.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payload-instruction-system/03-RESEARCH.md
@rig-provider/src/mcp_agent.rs
@rig-provider/src/lib.rs
@rig-provider/src/errors.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add builder fields, methods, and DEFAULT_WORKFLOW_TEMPLATE constant</name>
  <files>rig-provider/src/mcp_agent.rs</files>
  <action>
Add two new fields to McpToolAgentBuilder:
- `payload: Option<String>` - context data to inject into the prompt
- `instruction_template: Option<String>` - custom workflow instruction template

Add two new builder methods (following existing patterns with `#[must_use]` and `impl Into<String>`):

```rust
/// Sets context data (file contents, text blobs) to inject into the prompt.
///
/// When set, the user prompt is restructured into a 4-block XML format:
/// `<instructions>`, `<context>`, `<task>`, `<output_format>`.
/// The payload data is wrapped in `<context>` tags to clearly delimit it
/// from instructions, preventing instruction/context confusion.
///
/// When not set, the prompt is passed through unchanged (backward compatible).
#[must_use]
pub fn payload(mut self, data: impl Into<String>) -> Self {
    self.payload = Some(data.into());
    self
}

/// Sets a custom instruction template for tool workflow enforcement.
///
/// If not set, [`DEFAULT_WORKFLOW_TEMPLATE`] is used, which enforces the
/// example -> validate -> submit three-tool pattern.
#[must_use]
pub fn instruction_template(mut self, template: impl Into<String>) -> Self {
    self.instruction_template = Some(template.into());
    self
}
```

Add a module-level constant for the default workflow template:

```rust
/// Default instruction template enforcing the three-tool workflow.
///
/// This template requires agents to follow the example -> validate -> submit
/// sequence and forbids freeform text responses. The `{allowed_tools}` placeholder
/// is replaced at runtime with the computed MCP tool names.
pub const DEFAULT_WORKFLOW_TEMPLATE: &str = r#"You are a structured data extraction agent.

MANDATORY WORKFLOW:
1. Call the 'json_example' tool FIRST to see the expected output format
2. Draft your extraction based on the example and the provided context
3. Call 'validate_json' with your draft to check for errors
4. If validation fails, fix the errors and call 'validate_json' again
5. Once validation passes, call 'submit' with the validated data

RULES:
- You MUST complete all steps above in order
- Do NOT respond with freeform text as your final answer
- Do NOT output raw JSON in your response text
- ONLY the 'submit' tool call marks task completion
- The task is NOT complete until you call 'submit'"#;
```

Initialize the new fields to `None` in `McpToolAgentBuilder::new()`.

IMPORTANT: All public items need doc comments (deny(missing_docs) is active on rig-provider).
No .unwrap() or .expect() in new code.
  </action>
  <verify>
Run `cargo check -p rig-provider` to confirm compilation. Run `cargo clippy -p rig-provider -- -D warnings` to confirm no clippy warnings. Run `cargo doc -p rig-provider --no-deps` to confirm doc generation succeeds.
  </verify>
  <done>
McpToolAgentBuilder has payload and instruction_template fields and methods. DEFAULT_WORKFLOW_TEMPLATE constant exists. All compile, clippy clean, docs generate.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor prompt and system prompt construction in run()</name>
  <files>rig-provider/src/mcp_agent.rs</files>
  <action>
Refactor the `run()` method's prompt and system prompt construction. The current implementation (lines ~194-203) builds a simple `mcp_instruction` and `full_system_prompt`. Replace with enhanced construction:

**1. System prompt construction** - Replace the current mcp_instruction (line 194-199) with one that includes workflow steps:

```rust
// Build workflow template (custom or default)
let workflow_instructions = self.instruction_template.as_deref()
    .unwrap_or(DEFAULT_WORKFLOW_TEMPLATE);

// Build MCP instruction with workflow enforcement
let mcp_instruction = format!(
    "{workflow_instructions}\n\nAvailable MCP tools: {}\n\n\
     You MUST use ONLY these MCP tools. Do NOT output raw JSON text as your response.",
    allowed_tools.join(", ")
);
```

Then construct full_system_prompt by combining user's system_prompt (if any) with mcp_instruction:
```rust
let full_system_prompt = match &self.system_prompt {
    Some(sp) => format!("{sp}\n\n{mcp_instruction}"),
    None => mcp_instruction,
};
```

**2. User prompt construction** - Add a helper method or inline logic that restructures the prompt when payload is present:

When `self.payload` is `Some(data)`:
```rust
let final_prompt = format!(
    r#"<context>
{data}
</context>

<task>
{prompt}
</task>

<output_format>
Use ONLY the MCP tools listed in the system prompt. Final submission MUST be via the 'submit' tool.
</output_format>"#
);
```

When `self.payload` is `None`:
```rust
let final_prompt = prompt; // Unchanged, backward compatible
```

Use `final_prompt` instead of `prompt` when calling the per-adapter `run_*` functions.

**3. Move self.payload out before the adapter match** since self is consumed:
```rust
let payload = self.payload;
let instruction_template = self.instruction_template;
```

Then use these owned values for prompt construction.

IMPORTANT:
- The system_prompt field is already moved out as `self.system_prompt` on line 200. The instruction_template and payload must also be moved before the match block.
- Keep backward compatibility: when no payload and no instruction_template are set, the behavior should be nearly identical to Phase 2.1 (the only change being the enhanced mcp_instruction with workflow steps, which is an improvement not a regression).
- Do NOT change the signatures of run_claude_code, run_codex, run_opencode functions -- just change what `prompt` and `system_prompt` values are passed to them.
- No .unwrap() or .expect().
  </action>
  <verify>
Run `cargo check -p rig-provider` to confirm compilation. Run `cargo clippy -p rig-provider -- -D warnings` to confirm no clippy warnings. Run `cargo test -p rig-provider` to run any existing unit tests. Verify backward compatibility by inspecting that the existing `mcp_tool_agent_e2e` example still compiles: `cargo check --example mcp_tool_agent_e2e -p rig-provider`.
  </verify>
  <done>
The run() method uses enhanced system prompt with workflow steps and 4-block XML prompt structure when payload is present. Existing examples still compile (backward compatible). No .unwrap(), no .expect(), clippy clean.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p rig-provider` passes
2. `cargo clippy -p rig-provider -- -D warnings` has zero warnings
3. `cargo doc -p rig-provider --no-deps` generates docs successfully
4. `cargo check --example mcp_tool_agent_e2e -p rig-provider` still compiles (backward compat)
5. Inspect mcp_agent.rs to confirm:
   - DEFAULT_WORKFLOW_TEMPLATE constant exists with numbered workflow steps
   - .payload() and .instruction_template() methods exist with doc comments
   - When payload is None, prompt passes through unchanged
   - When payload is Some, prompt is wrapped in XML 4-block structure
   - System prompt always includes workflow steps (enhanced from Phase 2.1)
</verification>

<success_criteria>
- McpToolAgentBuilder has .payload() and .instruction_template() methods
- DEFAULT_WORKFLOW_TEMPLATE enforces example -> validate -> submit numbered steps
- Prompt construction uses 4-block XML structure when payload is present
- Prompt passes through unchanged when no payload (backward compatible)
- System prompt includes explicit workflow enforcement language
- All existing examples still compile
- Zero clippy warnings, docs generate
</success_criteria>

<output>
After completion, create `.planning/phases/03-payload-instruction-system/03-01-SUMMARY.md`
</output>
