---
phase: 07-rig-integration-polish
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - rig-provider/src/mcp_agent.rs
  - rig-provider/src/lib.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "McpToolAgent has a stream() method that returns tokio::sync::mpsc::Receiver<McpStreamEvent>"
    - "run_claude_code_stream(), run_codex_stream(), run_opencode_stream() helper functions exist"
    - "CliAgent struct exists with ToolSet, preamble, timeout, payload, and adapter fields"
    - "CliAgentBuilder provides fluent API: .toolset(), .preamble(), .payload(), .timeout(), .build()"
    - "CliAgent implements rig::completion::Prompt trait"
    - "CliAgent implements rig::completion::Chat trait"
  artifacts:
    - path: "rig-provider/src/mcp_agent.rs"
      provides: "McpToolAgent with stream() and CliAgent/CliAgentBuilder"
      contains: "pub async fn stream"
    - path: "rig-provider/src/lib.rs"
      provides: "Re-exports for CliAgent, CliAgentBuilder, McpStreamEvent"
      contains: "CliAgent"
  key_links:
    - from: "rig-provider/src/mcp_agent.rs"
      to: "claudecode_adapter::ClaudeCli::stream()"
      via: "run_claude_code_stream() calls cli.stream()"
      pattern: "cli.stream"
    - from: "rig-provider/src/mcp_agent.rs"
      to: "rig::completion::Prompt"
      via: "impl Prompt for CliAgent"
      pattern: "impl.*Prompt.*for CliAgent"
---

<objective>
Add streaming support to McpToolAgent and create the CliAgent abstraction that holds a ToolSet directly.

Purpose: The current McpToolAgent only has run() (synchronous). The user requires streaming parity on the MCP-enforced path. CliAgent is a new type that holds ToolSet directly (unlike CompletionModel which only receives ToolDefinitions), enabling true MCP enforcement with streaming.

Output: McpToolAgent with stream() method, three per-adapter streaming helpers, and CliAgent/CliAgentBuilder types implementing Prompt and Chat traits.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rig-integration-polish/07-VERIFICATION.md

Key existing code to reference:
@rig-provider/src/mcp_agent.rs (current McpToolAgent with run() only)
@claudecode-adapter/src/process.rs (ClaudeCli::stream() signature)
@codex-adapter/src/process.rs (CodexCli::stream() signature)
@opencode-adapter/src/process.rs (OpenCodeCli::stream() signature)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add streaming infrastructure to McpToolAgent</name>
  <files>rig-provider/src/mcp_agent.rs</files>
  <action>
Extend McpToolAgent with streaming support by adding:

**1. McpStreamEvent enum:**
```rust
/// Stream event from MCP-enforced CLI execution.
#[derive(Debug, Clone)]
pub enum McpStreamEvent {
    /// Text content from the agent.
    Text(String),
    /// Tool call initiated by the agent.
    ToolCall { name: String, input: String },
    /// Result from a tool execution.
    ToolResult { tool_use_id: String, content: String },
    /// Error during execution.
    Error(String),
}
```

**2. Add stream() method to McpToolAgentBuilder:**
```rust
/// Executes the MCP tool agent with streaming output.
///
/// Similar to run(), but returns a receiver that yields McpStreamEvent
/// as the CLI produces output. The agent spawns in a background task.
///
/// # Errors
/// Returns error if validation fails before spawning.
pub async fn stream(self) -> Result<tokio::sync::mpsc::Receiver<McpStreamEvent>, ProviderError>
```

The stream() method should:
- Validate required fields (toolset, prompt, adapter) - same as run()
- Build MCP config and compute allowed tools - same as run()
- Build the final prompt with payload XML if present - same as run()
- Create a channel (capacity 100)
- Match on adapter and call the appropriate streaming helper
- Return the receiver immediately

**3. Create streaming helper functions (parallel to existing run_ functions):**

```rust
async fn run_claude_code_stream(
    prompt: &str,
    mcp_config: &rig_mcp_server::server::McpConfig,
    allowed_tools: &[String],
    system_prompt: &str,
    timeout: Duration,
    builtin_tools: &Option<Vec<String>>,
    cwd: &std::path::Path,
    tx: tokio::sync::mpsc::Sender<McpStreamEvent>,
) -> Result<(), ProviderError>
```

The streaming helpers should:
- Set up MCP config file (same as run_ versions)
- Discover and init the CLI (same as run_ versions)
- Configure with StreamJson output format
- Create an internal adapter channel for the CLI's native StreamEvent
- Spawn tokio task that:
  - Calls cli.stream() with internal tx
  - Converts adapter StreamEvent to McpStreamEvent
  - Sends converted events to outer tx
- Return Ok(()) after spawning (errors come through channel)

**4. Conversion logic for each adapter:**

For Claude (has ToolCall/ToolResult variants):
```rust
match event {
    claudecode_adapter::StreamEvent::Text { text } => McpStreamEvent::Text(text),
    claudecode_adapter::StreamEvent::ToolCall { name, input } => McpStreamEvent::ToolCall { name, input },
    claudecode_adapter::StreamEvent::ToolResult { tool_use_id, content } => McpStreamEvent::ToolResult { tool_use_id, content },
    claudecode_adapter::StreamEvent::Error { message } => McpStreamEvent::Error(message),
    claudecode_adapter::StreamEvent::Unknown(_) => continue, // skip unknowns
}
```

For Codex and OpenCode (simpler - Text/Error/Unknown only):
```rust
match event {
    StreamEvent::Text { text } => McpStreamEvent::Text(text),
    StreamEvent::Error { message } => McpStreamEvent::Error(message),
    StreamEvent::Unknown(_) => continue,
}
```

**What NOT to do:**
- Do NOT change the existing run() method or run_* helper functions
- Do NOT change McpToolAgentBuilder fields or existing methods
- Do NOT add async streaming to the synchronous McpToolAgentResult type
  </action>
  <verify>
Run `cargo check -p rig-provider 2>&1 | grep -E "^error"` - should return no errors.
Run `grep -n "pub async fn stream" rig-provider/src/mcp_agent.rs` - should match the new method.
Run `grep -n "McpStreamEvent" rig-provider/src/mcp_agent.rs` - should show the enum definition.
Run `grep -n "run_claude_code_stream\|run_codex_stream\|run_opencode_stream" rig-provider/src/mcp_agent.rs` - should show all three helpers.
  </verify>
  <done>
McpToolAgentBuilder has stream() method that spawns CLI with streaming output. Three adapter-specific streaming helpers convert native StreamEvent to unified McpStreamEvent. Channel-based architecture matches existing adapter patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CliAgent and CliAgentBuilder types</name>
  <files>rig-provider/src/mcp_agent.rs, rig-provider/src/lib.rs</files>
  <action>
Add CliAgent and CliAgentBuilder types that provide Rig-idiomatic API for MCP-enforced execution.

**1. Add CliAgent struct after McpToolAgentBuilder:**

```rust
/// MCP-enforced CLI agent that implements Rig's Prompt and Chat traits.
///
/// Unlike CompletionModel (which receives ToolDefinitions), CliAgent holds
/// a concrete ToolSet, enabling true MCP enforcement where all agent
/// interactions must go through MCP tool calls.
///
/// # Example
///
/// ```no_run
/// use rig_provider::mcp_agent::{CliAgent, CliAdapter};
/// use rig::completion::Prompt;
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// let agent = CliAgent::builder()
///     .adapter(CliAdapter::ClaudeCode)
///     .toolset(my_toolset)
///     .preamble("You are a data extraction agent")
///     .build()?;
///
/// let response = agent.prompt("Extract the user data").await?;
/// # Ok(())
/// # }
/// ```
pub struct CliAgent {
    toolset: rig::tool::ToolSet,
    adapter: CliAdapter,
    preamble: Option<String>,
    timeout: Duration,
    payload: Option<String>,
    instruction_template: Option<String>,
    builtin_tools: Option<Vec<String>>,
    sandbox_mode: Option<codex_adapter::SandboxMode>,
    working_dir: Option<std::path::PathBuf>,
    server_name: String,
}
```

**2. Add CliAgentBuilder:**

```rust
/// Builder for CliAgent.
pub struct CliAgentBuilder {
    toolset: Option<rig::tool::ToolSet>,
    adapter: Option<CliAdapter>,
    preamble: Option<String>,
    timeout: Duration,
    payload: Option<String>,
    instruction_template: Option<String>,
    builtin_tools: Option<Vec<String>>,
    sandbox_mode: Option<codex_adapter::SandboxMode>,
    working_dir: Option<std::path::PathBuf>,
    server_name: String,
}

impl CliAgentBuilder {
    fn new() -> Self { /* same defaults as McpToolAgentBuilder */ }

    pub fn toolset(mut self, toolset: rig::tool::ToolSet) -> Self { ... }
    pub fn adapter(mut self, adapter: CliAdapter) -> Self { ... }
    pub fn preamble(mut self, preamble: impl Into<String>) -> Self { ... }
    pub fn timeout(mut self, timeout: Duration) -> Self { ... }
    pub fn payload(mut self, data: impl Into<String>) -> Self { ... }
    pub fn instruction_template(mut self, template: impl Into<String>) -> Self { ... }
    pub fn allow_builtins(mut self, tools: Vec<String>) -> Self { ... }
    pub fn sandbox_mode(mut self, mode: codex_adapter::SandboxMode) -> Self { ... }
    pub fn working_dir(mut self, path: impl Into<std::path::PathBuf>) -> Self { ... }
    pub fn server_name(mut self, name: impl Into<String>) -> Self { ... }

    /// Builds the CliAgent.
    ///
    /// # Errors
    /// Returns error if required fields (toolset, adapter) are not set.
    pub fn build(self) -> Result<CliAgent, ProviderError> { ... }
}

impl CliAgent {
    pub fn builder() -> CliAgentBuilder { CliAgentBuilder::new() }
}
```

**3. Implement Prompt trait for CliAgent:**

```rust
impl rig::completion::Prompt for CliAgent {
    async fn prompt(&self, prompt: &str) -> Result<String, rig::completion::PromptError> {
        // Build McpToolAgent from our fields and run
        let result = McpToolAgent::builder()
            .toolset(self.toolset.clone())
            .adapter(self.adapter)
            .prompt(prompt)
            .timeout(self.timeout)
            .server_name(&self.server_name)
            // ... apply all optional fields if Some
            .run()
            .await
            .map_err(|e| rig::completion::PromptError::ProviderError(e.to_string()))?;

        Ok(result.stdout)
    }
}
```

**4. Implement Chat trait for CliAgent:**

```rust
impl rig::completion::Chat for CliAgent {
    async fn chat(
        &self,
        prompt: &str,
        chat_history: Vec<rig::completion::message::Message>,
    ) -> Result<String, rig::completion::PromptError> {
        // Format chat history into prompt
        let full_prompt = if chat_history.is_empty() {
            prompt.to_string()
        } else {
            // Format: previous messages + current prompt
            let history = chat_history
                .iter()
                .map(|m| format!("{}: {}", m.role, /* extract text content */))
                .collect::<Vec<_>>()
                .join("\n");
            format!("{history}\n\nuser: {prompt}")
        };

        self.prompt(&full_prompt).await
    }
}
```

**5. Update rig-provider/src/lib.rs to re-export:**

Add to the pub use statements:
```rust
pub use mcp_agent::{CliAgent, CliAgentBuilder, McpStreamEvent};
```

**What NOT to do:**
- Do NOT make CliAgent generic over adapter - it holds the enum directly
- Do NOT implement CompletionModel for CliAgent - that's the wrong abstraction level
- Do NOT duplicate McpToolAgentBuilder logic - delegate to it via composition
  </action>
  <verify>
Run `cargo check -p rig-provider 2>&1 | grep -E "^error"` - should return no errors.
Run `grep -n "impl.*Prompt.*for CliAgent" rig-provider/src/mcp_agent.rs` - should match.
Run `grep -n "impl.*Chat.*for CliAgent" rig-provider/src/mcp_agent.rs` - should match.
Run `grep -n "pub struct CliAgent" rig-provider/src/mcp_agent.rs` - should match.
Run `grep -n "pub struct CliAgentBuilder" rig-provider/src/mcp_agent.rs` - should match.
Run `grep -n "CliAgent" rig-provider/src/lib.rs` - should show re-export.
  </verify>
  <done>
CliAgent and CliAgentBuilder exist with fluent builder API. CliAgent implements Prompt and Chat traits by delegating to McpToolAgent internally. Re-exports added to lib.rs.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo check -p rig-provider` - compiles without errors
2. `cargo test -p rig-provider` - all tests pass
3. `grep -c "pub async fn stream" rig-provider/src/mcp_agent.rs` - returns 1 (stream method exists)
4. `grep -c "McpStreamEvent" rig-provider/src/mcp_agent.rs` - returns multiple (enum + usages)
5. `grep -c "impl.*Prompt.*for CliAgent" rig-provider/src/mcp_agent.rs` - returns 1
6. `grep -c "impl.*Chat.*for CliAgent" rig-provider/src/mcp_agent.rs` - returns 1
</verification>

<success_criteria>
- McpToolAgentBuilder.stream() returns Receiver<McpStreamEvent>
- Three streaming helper functions (run_claude_code_stream, run_codex_stream, run_opencode_stream) exist
- CliAgent struct holds ToolSet directly with adapter, preamble, timeout, payload fields
- CliAgentBuilder provides fluent configuration API with build() returning Result<CliAgent, ProviderError>
- CliAgent implements rig::completion::Prompt trait
- CliAgent implements rig::completion::Chat trait
- rig-provider/src/lib.rs re-exports CliAgent, CliAgentBuilder, McpStreamEvent
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-rig-integration-polish/07-05-SUMMARY.md`
</output>
