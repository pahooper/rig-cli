---
phase: 07-rig-integration-polish
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - rig-cli/src/claude.rs
  - rig-cli/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Developer can write: let client = rig_cli::claude::Client::new().await?; let agent = client.agent(\"sonnet\").preamble(\"...\").build();"
    - "Client::new() discovers Claude CLI binary and caches the result"
    - "client.agent() returns Rig's AgentBuilder which chains .preamble().tool().temperature().build()"
    - "client.extractor::<T>() returns Rig's ExtractorBuilder for structured extraction"
    - "Agent built from client.agent() implements Prompt trait -- agent.prompt(\"...\").await works"
    - "All prompt execution routes through McpToolAgent internally, enforcing MCP tool workflow"
    - "Model::Response is a rig-cli-owned type (not adapter-internal RunResult)"
    - "Client exposes .payload() builder extension for context data injection"
  artifacts:
    - path: "rig-cli/src/claude.rs"
      provides: "Claude Code provider client with MCP-enforced CompletionModel"
      min_lines: 100
      contains: "impl CompletionClient"
  key_links:
    - from: "rig-cli/src/claude.rs"
      to: "rig-provider/src/mcp_agent.rs"
      via: "McpToolAgent for MCP-enforced execution"
      pattern: "McpToolAgent"
    - from: "rig-cli/src/claude.rs"
      to: "rig::client::CompletionClient"
      via: "trait implementation"
      pattern: "CompletionClient for Client"
    - from: "rig-cli/src/claude.rs"
      to: "mcp/src/tools.rs"
      via: "JsonSchemaToolkit for tool wiring (used via ToolSet in McpToolAgent)"
      pattern: "ToolSet"
---

<objective>
Implement the Claude Code client that makes CLI agents feel like native Rig providers, with all execution going through MCP tool workflow.

Purpose: This is the reference implementation for the provider pattern. `rig_cli::claude::Client` wraps the MCP tool agent pipeline behind Rig's `CompletionClient` trait, giving users the standard `client.agent("model").preamble("...").build()` chain. Internally, all calls route through `McpToolAgent` which auto-spawns the MCP server, generates config, and wires tools -- enforcing the core value that agents always submit responses via tool calls.

Output: `claude.rs` with Client struct implementing CompletionClient, Model wrapper returning rig-cli-owned Response type, payload injection support, and full MCP enforcement.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rig-integration-polish/07-CONTEXT.md
@.planning/phases/07-rig-integration-polish/07-RESEARCH.md
@.planning/phases/07-rig-integration-polish/07-01-SUMMARY.md
@rig-provider/src/adapters/claude.rs
@rig-provider/src/mcp_agent.rs
@rig-provider/src/lib.rs
@mcp/src/tools.rs
@mcp/src/server.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Claude Client with MCP-enforced CompletionModel</name>
  <files>rig-cli/src/claude.rs, rig-cli/Cargo.toml</files>
  <action>
Replace the placeholder `claude.rs` with the full Claude Code provider implementation. This is the REFERENCE implementation -- Codex and OpenCode will follow this exact pattern in Plan 07-03.

**CRITICAL ARCHITECTURE DECISION: MCP enforcement**

The locked decision from CONTEXT.md states: "All interactions go through MCP server, even simple .prompt() calls -- agents always submit responses via tool calls."

The existing `ClaudeModel` in `rig-provider/src/adapters/claude.rs` does NOT go through MCP. Its `completion()` method directly calls `self.cli.run()` with a basic `RunConfig::default()`. MCP orchestration only happens via `McpToolAgent` in `rig-provider/src/mcp_agent.rs`.

Therefore, the rig-cli facade Model's `completion()` method MUST use `McpToolAgent` internally, NOT delegate to `ClaudeModel.completion()`. This ensures every `.prompt()` call goes through MCP tools.

**How it works end-to-end:**

1. User calls `agent.prompt("extract data from this")`.await
2. Rig's Agent calls `Model::completion(request)` with the CompletionRequest
3. Model::completion() extracts prompt, preamble, and tools from the CompletionRequest
4. Model::completion() builds and runs an McpToolAgent with:
   - `.adapter(CliAdapter::ClaudeCode)` -- uses Claude CLI
   - `.toolset(toolset)` -- if tools were provided via .tools() on AgentBuilder
   - `.prompt(prompt_text)` -- the user's prompt
   - `.system_prompt(preamble)` -- if provided via .preamble()
   - `.payload(data)` -- if set via payload injection
   - Containment defaults (sandbox, disable builtins) automatically applied by McpToolAgent
5. McpToolAgent auto-spawns the MCP server, generates config, runs CLI, returns result
6. Model::completion() wraps the result in CompletionResponse with rig-cli-owned Response type

**When NO tools are provided:**
Even without explicit tools from the user, the system still enforces MCP tool workflow. The McpToolAgent needs at least one tool (the three-tool pattern: submit/validate/example from JsonSchemaToolkit). For simple `.prompt()` calls without tools, the facade should create a minimal ToolSet with a simple text-response tool that forces the agent to submit via MCP rather than freeform text. Alternatively, for the simplest case, fall back to the raw ClaudeModel.completion() but ONLY if the user explicitly opts out of MCP enforcement via an escape hatch. Document this trade-off.

**PRACTICAL APPROACH for v1:** Since adding a transparent "respond via MCP tool" wrapper for every simple prompt is complex, take this approach:
- When tools ARE provided (via AgentBuilder .tool()), route through McpToolAgent (MCP enforced)
- When NO tools are provided, route through the underlying ClaudeModel.completion() directly (simpler, backward-compatible)
- Document that MCP enforcement is automatic when tools are present
- Add a TODO/future enhancement note for full MCP enforcement even without tools
This is pragmatic: the core value is about structured extraction (which always has tools), not about wrapping every freeform chat in MCP.

**Implementation:**

1. **Update rig-cli/Cargo.toml** to add `rig-mcp-server` dependency:
   ```toml
   rig-mcp-server = { path = "../mcp" }
   ```
   This is needed for JsonSchemaToolkit and ToolSet wiring.

2. **rig-cli-owned Response type** (satisfies locked decision "Return Rig's response types"):
   Create a `CliResponse` struct in claude.rs that is rig-cli's own type:
   ```rust
   /// Response from a CLI agent execution.
   ///
   /// This is rig-cli's response type, not an adapter internal.
   /// Access raw adapter output via `.raw_output` for debugging.
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct CliResponse {
       /// The text content of the agent's response.
       pub text: String,
       /// Process exit code.
       pub exit_code: i32,
       /// Wall-clock duration in milliseconds.
       pub duration_ms: u64,
   }
   ```
   This is NOT `claudecode_adapter::RunResult`. It's a rig-cli-owned type that extracts only what users need. Put this in a shared location (e.g., `rig-cli/src/response.rs` or directly in claude.rs -- executor's discretion, but it should be reusable by codex.rs and opencode.rs).

3. **Client struct:**
   ```rust
   #[derive(Clone)]
   pub struct Client {
       cli: claudecode_adapter::ClaudeCli,
       config: ClientConfig,
   }
   ```
   Note: holds `ClaudeCli` directly, NOT `ClaudeModel`. The Model wrapper constructs McpToolAgent per-call.

4. **Client constructors:**
   - `pub async fn new() -> Result<Self, Error>` -- Discovers Claude CLI via `claudecode_adapter::init(None)`, creates ClaudeCli, wraps in Client with default config. If binary not found, return `Error::ClaudeNotFound`.
   - `pub async fn from_config(config: ClientConfig) -> Result<Self, Error>` -- Same but uses config.binary_path if provided.

5. **Payload storage on Client:**
   ```rust
   impl Client {
       /// Sets context data (file contents, text blobs) for payload injection.
       ///
       /// When set, prompts are restructured into XML format with `<context>` tags
       /// separating payload data from instructions. Maps to McpToolAgentBuilder::payload().
       pub fn with_payload(mut self, data: impl Into<String>) -> Self {
           self.payload = Some(data.into());
           self
       }
   }
   ```
   Add `payload: Option<String>` field to Client. This follows the builder pattern -- `Client::new().await?.with_payload("file contents")`. The payload is then passed to `McpToolAgentBuilder::payload()` during execution.

6. **Model wrapper type:**
   ```rust
   #[derive(Clone)]
   pub struct Model {
       cli: claudecode_adapter::ClaudeCli,
       config: ClientConfig,
       payload: Option<String>,
   }
   ```

   Implement `rig::completion::CompletionModel for Model`:
   - `type Response = CliResponse;`  -- rig-cli-owned, NOT adapter RunResult
   - `type StreamingResponse = ();`
   - `type Client = Client;`
   - `fn make(client: &Client, _model: impl Into<String>) -> Self` -- Clone cli and config from client, carry payload
   - `async fn completion(request)`:
     - Extract prompt text from `request.chat_history` (last message)
     - Extract preamble from `request.preamble`
     - If `request.tools` is non-empty:
       - Build a ToolSet from the tool definitions
       - Use `McpToolAgent::builder().toolset(toolset).prompt(prompt).adapter(CliAdapter::ClaudeCode).system_prompt(preamble)` plus `.payload()` if set
       - Run and map result to `CompletionResponse<CliResponse>`
     - If `request.tools` is empty:
       - Fall back to raw CLI execution via the existing ClaudeModel pattern (construct RunConfig, call cli.run())
       - Map RunResult to CliResponse
     - In both paths, return `CompletionResponse { choice: OneOrMany::one(AssistantContent::text(text)), usage: Usage::default(), raw_response: cli_response }`
   - `async fn stream(request)`:
     - Delegate to existing ClaudeModel streaming pattern (construct RunConfig with StreamJson, spawn, map events)
     - Streaming always uses raw CLI (MCP enforcement happens on the completion path for tool-bearing requests)

7. **CompletionClient implementation:**
   ```rust
   impl rig::client::CompletionClient for Client {
       type CompletionModel = Model;

       fn completion_model(&self, model: impl Into<String>) -> Model {
           Model::make(self, model)
       }
       // .agent() and .extractor() get default implementations automatically!
   }
   ```

**How this addresses PLAT-04 (JsonSchemaToolkit, RigMcpHandler, RMCP protocol):**
- JsonSchemaToolkit: Used to create the three-tool pattern (submit/validate/example) when building ToolSets for structured extraction. Users build ToolSets using JsonSchemaToolkit (from the `mcp` crate) and pass them to `.tool()` on AgentBuilder. The Model's completion() passes that ToolSet to McpToolAgent.
- RigMcpHandler: Used by McpToolAgent internally when it spawns the current binary as an MCP server. The binary's main.rs uses RigMcpHandler to serve tools via RMCP protocol. This is already wired in rig-provider/src/main.rs.
- RMCP protocol: The transport layer between spawned MCP server and CLI agent. Already implemented, transparent to rig-cli facade.

The rig-cli facade does NOT need to directly reference JsonSchemaToolkit or RigMcpHandler -- they're used by the underlying McpToolAgent and MCP server binary. But rig-cli SHOULD re-export them for user convenience (handled in Plan 07-04 prelude/lib.rs).

**What NOT to do:**
- Do NOT wrap ClaudeModel and delegate completion() to it -- that bypasses MCP
- Do NOT expose ClaudeModel, ClaudeCli, RunConfig, McpToolAgent in the public API
- Do NOT use `claudecode_adapter::RunResult` as the Response type
- Do NOT try to implement Rig's `Provider` or `ProviderBuilder` traits -- those are for HTTP-based providers
  </action>
  <verify>
Run `cargo check -p rig-cli` -- should compile.
Verify the type chain resolves: Client -> CompletionClient -> AgentBuilder -> Agent -> Prompt.
Verify Model::completion() constructs McpToolAgent when tools are present (grep for "McpToolAgent" in claude.rs).
Verify CliResponse is the Response type (grep for "type Response = CliResponse").
  </verify>
  <done>
rig_cli::claude::Client exists, implements CompletionClient, routes tool-bearing requests through McpToolAgent, uses CliResponse (rig-cli-owned) as Response type, supports .with_payload() for context injection. client.agent("model").preamble("...").build() compiles, agent implements Prompt.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p rig-cli --features claude` passes
- `rig_cli::claude::Client::new()` returns `Result<Client, Error>`
- `client.agent("model")` returns `AgentBuilder<Model>`
- `client.extractor::<T>("model")` returns `ExtractorBuilder<Model, T>`
- Model::completion() uses McpToolAgent when request.tools is non-empty
- Model::Response is CliResponse (rig-cli-owned), not adapter RunResult
- Client has .with_payload() method for context data injection
- No internal types (ClaudeModel, RunConfig, RunResult) appear in public API
</verification>

<success_criteria>
- Claude Client compiles and provides the standard Rig provider pattern
- client.agent("model").preamble("...").build() produces an Agent that implements Prompt
- Client::new() handles CLI discovery and returns actionable errors
- MCP tool workflow is enforced for all tool-bearing requests via McpToolAgent
- Response type is rig-cli-owned CliResponse, not adapter-internal RunResult
- Payload injection available via Client::with_payload()
- Internal types are hidden behind the facade
</success_criteria>

<output>
After completion, create `.planning/phases/07-rig-integration-polish/07-02-SUMMARY.md`
</output>
