---
phase: 07-rig-integration-polish
plan: 07
type: execute
wave: 3
depends_on: ["07-06"]
files_modified:
  - rig-cli/src/claude.rs
  - rig-cli/src/codex.rs
  - rig-cli/src/opencode.rs
  - rig-cli/src/response.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When payload is set via .with_payload() on Client, prompts in completion() are restructured with XML <context>/<task> tags"
    - "cargo check -p rig-cli produces zero warnings (no dead_code warnings)"
    - "All three clients (Claude, Codex, OpenCode) wire preamble and timeout into their adapter configs"
    - "claude.rs uses shared CliResponse from response.rs (no local definition)"
    - "Streaming works for both paths: agent().stream() and mcp_agent().prompt()"
  artifacts:
    - path: "rig-cli/src/claude.rs"
      provides: "Claude provider with payload wiring and no dead code"
      contains: "<context>"
    - path: "rig-cli/src/codex.rs"
      provides: "Codex provider with payload wiring, preamble/timeout in config"
      contains: "<context>"
    - path: "rig-cli/src/opencode.rs"
      provides: "OpenCode provider with payload wiring, preamble/timeout in config"
      contains: "<context>"
    - path: "rig-cli/src/response.rs"
      provides: "Shared CliResponse type used by all providers"
  key_links:
    - from: "rig-cli/src/claude.rs"
      to: "crate::response::CliResponse"
      via: "use crate::response::CliResponse"
      pattern: "use crate::response::CliResponse"
    - from: "rig-cli/src/codex.rs"
      to: "codex_adapter::CodexConfig"
      via: "config.system_prompt = request.preamble"
      pattern: "system_prompt.*preamble"
    - from: "rig-cli/src/opencode.rs"
      to: "opencode_adapter::OpenCodeConfig"
      via: "config.prompt = request.preamble"
      pattern: "prompt.*preamble"
---

<objective>
Wire payload injection into completion() for all providers, fix dead code warnings, and verify streaming parity across both execution paths.

Purpose: The verification report found that payload fields are stored but unused, creating dead_code warnings. This plan wires payload into the direct CLI path (as XML context wrapping), ensures preamble/timeout are properly passed to adapter configs, and removes duplicate type definitions.

Output: All three providers with working payload injection via XML restructuring, zero compilation warnings, and preamble/timeout properly wired. Claude uses shared CliResponse.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rig-integration-polish/07-05-PLAN.md
@.planning/phases/07-rig-integration-polish/07-06-PLAN.md

Key existing code to reference:
@rig-cli/src/claude.rs (after 07-06 changes)
@rig-cli/src/codex.rs (after 07-06 changes)
@rig-cli/src/opencode.rs (after 07-06 changes)
@rig-cli/src/response.rs (shared CliResponse definition)
@rig-provider/src/mcp_agent.rs (lines 452-469 for payload XML format reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire payload into Claude completion() and fix CliResponse duplication</name>
  <files>rig-cli/src/claude.rs</files>
  <action>
Wire payload injection into the direct CLI completion path and remove duplicate CliResponse definition.

**1. Remove the local CliResponse definition (lines 44-57).**

The claude.rs file currently defines its own CliResponse struct:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CliResponse {
    pub text: String,
    pub exit_code: i32,
    pub duration_ms: u64,
}
```

This duplicates response.rs. Remove this definition and add the import:
```rust
use crate::response::CliResponse;
```

**2. Wire payload into completion():**

The completion() method should restructure the prompt when payload is set. After extracting prompt_text, add:

```rust
// If payload is set, wrap prompt in XML context structure
let final_prompt = if let Some(ref payload) = self.payload {
    format!(
        r#"<context>
{payload}
</context>

<task>
{prompt_text}
</task>"#
    )
} else {
    prompt_text
};
```

Then use `final_prompt` instead of `prompt_text` in the cli.run() call.

**3. Ensure preamble is wired to config:**

The completion() method should set system_prompt on RunConfig when preamble is present:
```rust
if let Some(ref preamble) = request.preamble {
    config.system_prompt = claudecode_adapter::SystemPromptMode::Append(preamble.clone());
}
```
(This may already exist - verify and keep if so.)

**4. Ensure timeout is wired to config:**

The completion() method should use self.config.timeout:
```rust
let config = claudecode_adapter::RunConfig {
    timeout: self.config.timeout,
    ..claudecode_adapter::RunConfig::default()
};
```

**5. Fix model_name dead_code warning:**

The Model struct has an unused `model_name` field. Add:
```rust
/// Model identifier (stored for API consistency, CLI agents don't use per-request model selection).
#[allow(dead_code)]
model_name: String,
```

**6. Verify streaming also respects payload (if applicable):**

The stream() method should also apply payload wrapping if set. Check if it currently does; if not, add the same XML wrapping logic.

**What NOT to do:**
- Do NOT remove the payload field from Client or Model
- Do NOT change the streaming implementation beyond adding payload support
- Do NOT modify the CompletionClient trait implementation
  </action>
  <verify>
Run `cargo check -p rig-cli 2>&1 | grep "warning.*claude.rs"` - should return no warnings for claude.rs.
Run `grep -n "pub struct CliResponse" rig-cli/src/claude.rs` - should return no matches (removed).
Run `grep -n "use crate::response::CliResponse" rig-cli/src/claude.rs` - should match (import added).
Run `grep -n "<context>" rig-cli/src/claude.rs` - should match (payload XML restructuring).
Run `grep -n "self.config.timeout" rig-cli/src/claude.rs` - should match in completion().
  </verify>
  <done>
Claude completion() wires payload into prompt via XML <context>/<task> tags. Uses shared CliResponse from response.rs. Preamble and timeout properly wired to RunConfig. No dead_code warnings from claude.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire payload, preamble, timeout into Codex and OpenCode completion()</name>
  <files>rig-cli/src/codex.rs, rig-cli/src/opencode.rs</files>
  <action>
Apply the same payload wiring pattern to Codex and OpenCode providers, and properly wire preamble/timeout to their adapter configs.

**For rig-cli/src/codex.rs:**

1. **Wire payload into completion():**

After extracting prompt_text, add XML wrapping:
```rust
let final_prompt = if let Some(ref payload) = self.payload {
    format!(
        r#"<context>
{payload}
</context>

<task>
{prompt_text}
</task>"#
    )
} else {
    prompt_text
};
```

2. **Wire preamble into CodexConfig:**

Currently completion() uses `CodexConfig::default()` which ignores preamble. Change to:
```rust
let mut config = CodexConfig {
    timeout: self.config.timeout,
    ..CodexConfig::default()
};

if let Some(ref preamble) = request.preamble {
    config.system_prompt = Some(preamble.clone());
}
```

3. **Use final_prompt in cli.run():**
```rust
let result = self.cli.run(&final_prompt, &config).await...
```

4. **Apply same changes to stream() method if needed:**

Check if stream() uses payload - if not, add the same XML wrapping.

**For rig-cli/src/opencode.rs:**

Apply identical changes, but note that OpenCodeConfig uses `prompt` field instead of `system_prompt`:

```rust
let mut config = OpenCodeConfig {
    timeout: self.config.timeout,
    ..OpenCodeConfig::default()
};

if let Some(ref preamble) = request.preamble {
    config.prompt = Some(preamble.clone());
}
```

**Dead code check:**

Verify that after these changes, the `payload` field on Model is actually used in completion(). If there are still dead_code warnings, they should be from genuinely unused fields that can get #[allow(dead_code)] with justification.

**What NOT to do:**
- Do NOT change the CliResponse imports (already correct in codex.rs and opencode.rs)
- Do NOT modify the CompletionClient trait implementations
- Do NOT remove any existing functionality
  </action>
  <verify>
Run `cargo check -p rig-cli 2>&1 | grep "warning"` - should return zero warnings from rig-cli.
Run `grep -n "<context>" rig-cli/src/codex.rs rig-cli/src/opencode.rs` - should match both files.
Run `grep -n "system_prompt.*preamble\|prompt.*preamble" rig-cli/src/codex.rs rig-cli/src/opencode.rs` - should match both files.
Run `grep -n "self.config.timeout" rig-cli/src/codex.rs rig-cli/src/opencode.rs` - should match in completion() for both.
Run `cargo test -p rig-cli` - all tests pass.
  </verify>
  <done>
Codex and OpenCode completion() methods wire payload into prompt via XML tags. Preamble wired to system_prompt (Codex) or prompt (OpenCode) on adapter config. Timeout wired from client config. Zero compilation warnings from rig-cli.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full gap closure:

1. `cargo check -p rig-cli 2>&1 | grep -c "warning"` - outputs 0 (zero warnings)
2. `cargo test -p rig-cli` - all tests pass
3. `grep -rn "<context>" rig-cli/src/claude.rs rig-cli/src/codex.rs rig-cli/src/opencode.rs` - matches in all three
4. `grep -n "pub struct CliResponse" rig-cli/src/claude.rs` - no matches (uses shared)
5. `grep -rn "self.config.timeout" rig-cli/src/claude.rs rig-cli/src/codex.rs rig-cli/src/opencode.rs` - matches in completion() for all
6. `cargo doc -p rig-cli --no-deps 2>&1` - no doc warnings

Streaming verification (manual test if time permits):
- `client.agent("model").prompt("test").await` works (direct CLI path)
- `client.mcp_agent("model").toolset(tools).build()?.prompt("test").await` works (MCP path)
</verification>

<success_criteria>
- Zero compilation warnings from `cargo check -p rig-cli`
- All three providers wire payload into prompt via XML `<context>`/`<task>` restructuring
- All three providers wire preamble to their adapter's system prompt config
- All three providers wire timeout from client config to adapter config
- claude.rs uses shared CliResponse from response.rs (no local definition)
- All existing tests pass
- Documentation builds without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/07-rig-integration-polish/07-07-SUMMARY.md`
</output>
