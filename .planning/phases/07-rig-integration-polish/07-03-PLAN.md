---
phase: 07-rig-integration-polish
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - rig-cli/src/codex.rs
  - rig-cli/src/opencode.rs
autonomous: true

must_haves:
  truths:
    - "Developer can write: let client = rig_cli::codex::Client::new().await?; let agent = client.agent(\"model\").build();"
    - "Developer can write: let client = rig_cli::opencode::Client::new().await?; let agent = client.agent(\"model\").build();"
    - "Both clients follow identical pattern to Claude client"
    - "All three clients use the same ClientConfig type"
  artifacts:
    - path: "rig-cli/src/codex.rs"
      provides: "Codex CLI provider client"
      min_lines: 60
      contains: "impl CompletionClient"
    - path: "rig-cli/src/opencode.rs"
      provides: "OpenCode CLI provider client"
      min_lines: 60
      contains: "impl CompletionClient"
  key_links:
    - from: "rig-cli/src/codex.rs"
      to: "rig-provider/src/adapters/codex.rs"
      via: "wraps CodexModel"
      pattern: "CodexModel"
    - from: "rig-cli/src/opencode.rs"
      to: "rig-provider/src/adapters/opencode.rs"
      via: "wraps OpenCodeModel"
      pattern: "OpenCodeModel"
---

<objective>
Implement Codex and OpenCode clients following the exact same pattern as Claude.

Purpose: Complete the set of CLI provider clients. All three follow the same pattern — Client wraps internal Model, implements CompletionClient, provides .agent() and .extractor().
Output: codex.rs and opencode.rs with Client structs implementing CompletionClient.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rig-integration-polish/07-CONTEXT.md
@.planning/phases/07-rig-integration-polish/07-RESEARCH.md
@.planning/phases/07-rig-integration-polish/07-01-SUMMARY.md
@rig-provider/src/adapters/codex.rs
@rig-provider/src/adapters/opencode.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Codex Client</name>
  <files>rig-cli/src/codex.rs</files>
  <action>
Replace the placeholder `codex.rs` with the full Codex provider implementation. Follow the EXACT same pattern as `claude.rs` (from Plan 07-02).

1. **Client struct:**
   ```rust
   #[derive(Clone)]
   pub struct Client {
       inner: rig_provider::CodexModel,
       config: ClientConfig,
   }
   ```

2. **Client constructors:**
   - `pub async fn new() -> Result<Self, Error>` — Discovers Codex CLI via `codex_adapter::discover_codex(None)`, creates CodexCli, health checks, wraps in CodexModel, wraps in Client. If not found, return `Error::CodexNotFound`.
   - `pub async fn from_config(config: ClientConfig) -> Result<Self, Error>` — Same but uses config.binary_path.

3. **Model wrapper:**
   ```rust
   #[derive(Clone)]
   pub struct Model {
       inner: rig_provider::CodexModel,
   }
   ```
   Implement `CompletionModel for Model`:
   - `type Response = codex_adapter::RunResult;`
   - `type StreamingResponse = ();`
   - `type Client = Client;`
   - `fn make(client: &Client, _model: impl Into<String>) -> Self` — wraps client.inner
   - Delegate `completion()` and `stream()` to inner

4. **CompletionClient implementation:**
   ```rust
   impl CompletionClient for Client {
       type CompletionModel = Model;
       fn completion_model(&self, model: impl Into<String>) -> Model {
           Model::make(self, model)
       }
   }
   ```

5. **Doc comments:**
   - Module-level doc comment with example showing `codex::Client::new().await?`
   - Note that model parameter is accepted for compatibility but Codex CLI uses its own model selection
  </action>
  <verify>Run `cargo check -p rig-cli --features codex` — passes.</verify>
  <done>rig_cli::codex::Client exists, implements CompletionClient, client.agent().build() chain works.</done>
</task>

<task type="auto">
  <name>Task 2: Implement OpenCode Client</name>
  <files>rig-cli/src/opencode.rs</files>
  <action>
Replace the placeholder `opencode.rs` with the full OpenCode provider implementation. Identical pattern to Codex.

1. **Client struct:**
   ```rust
   #[derive(Clone)]
   pub struct Client {
       inner: rig_provider::OpenCodeModel,
       config: ClientConfig,
   }
   ```

2. **Client constructors:**
   - `pub async fn new() -> Result<Self, Error>` — Discovers via `opencode_adapter::discover_opencode(None)`, creates OpenCodeCli, health checks, wraps. If not found, return `Error::OpenCodeNotFound`.
   - `pub async fn from_config(config: ClientConfig) -> Result<Self, Error>`

3. **Model wrapper:**
   ```rust
   #[derive(Clone)]
   pub struct Model {
       inner: rig_provider::OpenCodeModel,
   }
   ```
   Same CompletionModel implementation pattern.

4. **CompletionClient implementation** — same pattern.

5. **Doc comments** — same pattern with opencode example.
  </action>
  <verify>Run `cargo check -p rig-cli --features opencode` — passes.</verify>
  <done>rig_cli::opencode::Client exists, implements CompletionClient, client.agent().build() chain works.</done>
</task>

</tasks>

<verification>
- `cargo check -p rig-cli` passes with all features
- `cargo check -p rig-cli --features codex` passes
- `cargo check -p rig-cli --features opencode` passes
- Both clients follow identical API shape to Claude client
</verification>

<success_criteria>
- Codex and OpenCode clients compile and implement CompletionClient
- All three providers (claude, codex, opencode) follow identical pattern
- ClientConfig is shared across all three
- Error types correctly map to each adapter's discovery failure
</success_criteria>

<output>
After completion, create `.planning/phases/07-rig-integration-polish/07-03-SUMMARY.md`
</output>
