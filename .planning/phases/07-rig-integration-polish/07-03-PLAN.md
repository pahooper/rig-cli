---
phase: 07-rig-integration-polish
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - rig-cli/src/codex.rs
  - rig-cli/src/opencode.rs
autonomous: true

must_haves:
  truths:
    - "Developer can write: let client = rig_cli::codex::Client::new().await?; let agent = client.agent(\"model\").build();"
    - "Developer can write: let client = rig_cli::opencode::Client::new().await?; let agent = client.agent(\"model\").build();"
    - "Both clients follow identical pattern to Claude client"
    - "All three clients use the same ClientConfig and CliResponse types"
    - "Tool-bearing requests route through McpToolAgent with correct CliAdapter variant"
    - "Both clients support .with_payload() for context data injection"
  artifacts:
    - path: "rig-cli/src/codex.rs"
      provides: "Codex CLI provider client with MCP-enforced CompletionModel"
      min_lines: 80
      contains: "impl CompletionClient"
    - path: "rig-cli/src/opencode.rs"
      provides: "OpenCode CLI provider client with MCP-enforced CompletionModel"
      min_lines: 80
      contains: "impl CompletionClient"
  key_links:
    - from: "rig-cli/src/codex.rs"
      to: "rig-provider/src/mcp_agent.rs"
      via: "McpToolAgent with CliAdapter::Codex"
      pattern: "CliAdapter::Codex"
    - from: "rig-cli/src/opencode.rs"
      to: "rig-provider/src/mcp_agent.rs"
      via: "McpToolAgent with CliAdapter::OpenCode"
      pattern: "CliAdapter::OpenCode"
---

<objective>
Implement Codex and OpenCode clients following the exact same MCP-enforced pattern as Claude.

Purpose: Complete the set of CLI provider clients. All three follow the same pattern -- Client holds CLI handle, Model routes tool-bearing requests through McpToolAgent (with adapter-specific CliAdapter variant), uses shared CliResponse type, implements CompletionClient.
Output: codex.rs and opencode.rs with Client structs implementing CompletionClient, MCP-enforced execution.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rig-integration-polish/07-CONTEXT.md
@.planning/phases/07-rig-integration-polish/07-RESEARCH.md
@.planning/phases/07-rig-integration-polish/07-01-SUMMARY.md
@.planning/phases/07-rig-integration-polish/07-02-SUMMARY.md
@rig-provider/src/adapters/codex.rs
@rig-provider/src/adapters/opencode.rs
@rig-provider/src/mcp_agent.rs
@rig-cli/src/claude.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Codex Client</name>
  <files>rig-cli/src/codex.rs</files>
  <action>
Replace the placeholder `codex.rs` with the full Codex provider implementation. Follow the EXACT same pattern as `claude.rs` (from Plan 07-02), with these Codex-specific differences:

1. **Client struct:**
   ```rust
   #[derive(Clone)]
   pub struct Client {
       cli: codex_adapter::CodexCli,
       config: ClientConfig,
       payload: Option<String>,
   }
   ```

2. **Client constructors:**
   - `pub async fn new() -> Result<Self, Error>` -- Discovers Codex CLI via `codex_adapter::discover_codex(None)`, creates CodexCli, health checks via `cli.check_health().await`, wraps in Client. If not found, return `Error::CodexNotFound`.
   - `pub async fn from_config(config: ClientConfig) -> Result<Self, Error>` -- Same but uses config.binary_path.
   - `pub fn with_payload(mut self, data: impl Into<String>) -> Self` -- Same pattern as Claude.

3. **Model wrapper:**
   ```rust
   #[derive(Clone)]
   pub struct Model {
       cli: codex_adapter::CodexCli,
       config: ClientConfig,
       payload: Option<String>,
   }
   ```
   Implement `CompletionModel for Model`:
   - `type Response = CliResponse;` -- SAME CliResponse type as Claude (shared across all adapters)
   - `type StreamingResponse = ();`
   - `type Client = Client;`
   - `fn make(client: &Client, _model: impl Into<String>) -> Self`
   - `async fn completion(request)`:
     - If tools present: use `McpToolAgent::builder().adapter(CliAdapter::Codex)` -- DIFFERENT from Claude
     - If no tools: fall back to raw `cli.run()` with `CodexConfig::default()`
     - Map result to `CompletionResponse<CliResponse>`
   - `async fn stream(request)`: delegate to CodexCli streaming pattern

4. **CompletionClient implementation** -- identical pattern to Claude.

5. **Doc comments:**
   - Module-level doc comment with example showing `codex::Client::new().await?`
   - Note that model parameter is accepted for compatibility but Codex CLI uses its own model selection
  </action>
  <verify>Run `cargo check -p rig-cli --features codex` -- passes.</verify>
  <done>rig_cli::codex::Client exists, implements CompletionClient, routes tool-bearing requests through McpToolAgent with CliAdapter::Codex, uses CliResponse, supports .with_payload().</done>
</task>

<task type="auto">
  <name>Task 2: Implement OpenCode Client</name>
  <files>rig-cli/src/opencode.rs</files>
  <action>
Replace the placeholder `opencode.rs` with the full OpenCode provider implementation. Identical pattern to Codex, with OpenCode-specific differences:

1. **Client struct:**
   ```rust
   #[derive(Clone)]
   pub struct Client {
       cli: opencode_adapter::OpenCodeCli,
       config: ClientConfig,
       payload: Option<String>,
   }
   ```

2. **Client constructors:**
   - `pub async fn new() -> Result<Self, Error>` -- Discovers via `opencode_adapter::discover_opencode(None)`, creates OpenCodeCli, health checks, wraps. If not found, return `Error::OpenCodeNotFound`.
   - `pub async fn from_config(config: ClientConfig) -> Result<Self, Error>`
   - `pub fn with_payload(mut self, data: impl Into<String>) -> Self`

3. **Model wrapper:**
   Same pattern but with:
   - `type Response = CliResponse;` -- SAME shared type
   - When tools present: `McpToolAgent::builder().adapter(CliAdapter::OpenCode)` -- DIFFERENT adapter
   - When no tools: fall back to raw `cli.run()` with `OpenCodeConfig::default()`

4. **CompletionClient implementation** -- same pattern.

5. **Doc comments** -- same pattern with opencode example.
  </action>
  <verify>Run `cargo check -p rig-cli --features opencode` -- passes.</verify>
  <done>rig_cli::opencode::Client exists, implements CompletionClient, routes tool-bearing requests through McpToolAgent with CliAdapter::OpenCode, uses CliResponse, supports .with_payload().</done>
</task>

</tasks>

<verification>
- `cargo check -p rig-cli` passes with all features
- `cargo check -p rig-cli --features codex` passes
- `cargo check -p rig-cli --features opencode` passes
- Both clients follow identical API shape to Claude client
- Both use McpToolAgent with correct CliAdapter variant for tool-bearing requests
- Both use CliResponse (shared with Claude), not adapter-specific RunResult
- Both support .with_payload() for context data injection
</verification>

<success_criteria>
- Codex and OpenCode clients compile and implement CompletionClient
- All three providers (claude, codex, opencode) follow identical pattern
- ClientConfig and CliResponse are shared across all three
- MCP enforcement via McpToolAgent with adapter-specific CliAdapter variant
- Error types correctly map to each adapter's discovery failure
- Payload injection supported on all three clients
</success_criteria>

<output>
After completion, create `.planning/phases/07-rig-integration-polish/07-03-SUMMARY.md`
</output>
