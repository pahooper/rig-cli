---
phase: 07-rig-integration-polish
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - rig-cli/src/prelude.rs
  - rig-cli/src/claude.rs
  - rig-cli/src/codex.rs
  - rig-cli/src/opencode.rs
  - rig-cli/src/lib.rs
  - rig-cli/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "use rig_cli::prelude::* imports the most common types needed for typical usage"
    - "Each Client has .inner() or .raw() method for advanced users to access underlying types"
    - "features = [\"debug-output\"] enables raw CLI output in error messages"
    - "cargo check -p rig-cli passes with all feature combinations"
    - "cargo doc -p rig-cli --no-deps generates clean documentation"
  artifacts:
    - path: "rig-cli/src/prelude.rs"
      provides: "Common re-exports for ergonomic imports"
      min_lines: 10
      contains: "pub use"
    - path: "rig-cli/src/lib.rs"
      provides: "Crate root with re-exports"
      contains: "pub use rig"
  key_links:
    - from: "rig-cli/src/prelude.rs"
      to: "rig-cli/src/claude.rs"
      via: "re-export Client type"
      pattern: "claude::Client"
    - from: "rig-cli/src/lib.rs"
      to: "rig"
      via: "re-export rig crate for convenience"
      pattern: "pub use rig"
---

<objective>
Add prelude, escape hatches, debug-output feature flag, and verify the complete API surface.

Purpose: Polish the public API with ergonomic imports (prelude), escape hatches for advanced users (.inner()), debug-output feature for production safety, and verify the entire crate compiles correctly across all feature combinations.
Output: Complete, polished rig-cli crate ready for use.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rig-integration-polish/07-CONTEXT.md
@.planning/phases/07-rig-integration-polish/07-RESEARCH.md
@.planning/phases/07-rig-integration-polish/07-01-SUMMARY.md
@.planning/phases/07-rig-integration-polish/07-02-SUMMARY.md
@.planning/phases/07-rig-integration-polish/07-03-SUMMARY.md
@rig-cli/src/lib.rs
@rig-cli/src/claude.rs
@rig-cli/src/codex.rs
@rig-cli/src/opencode.rs
@rig-cli/src/errors.rs
@rig-cli/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prelude module and add re-exports</name>
  <files>rig-cli/src/prelude.rs, rig-cli/src/lib.rs</files>
  <action>
1. **Populate `rig-cli/src/prelude.rs`:**
   Only export types used in 90%+ of interactions. Keep it minimal per Research pitfall #2.
   ```rust
   //! Common imports for rig-cli usage.
   //!
   //! ```
   //! use rig_cli::prelude::*;
   //! ```

   // Client types (feature-gated)
   #[cfg(feature = "claude")]
   pub use crate::claude::Client as ClaudeClient;
   #[cfg(feature = "codex")]
   pub use crate::codex::Client as CodexClient;
   #[cfg(feature = "opencode")]
   pub use crate::opencode::Client as OpenCodeClient;

   // Error type (always available)
   pub use crate::errors::Error;

   // Re-export key Rig traits so users don't need separate rig import
   pub use rig::completion::Prompt;
   pub use rig::completion::Chat;
   ```

   Do NOT export: AgentBuilder (accessed via client.agent()), Model types (internal), ClientConfig (used in advanced cases only), ToolSet (import from rig directly).

2. **Update `rig-cli/src/lib.rs`:**
   - Add `pub use rig;` at crate root so users can access Rig types via `rig_cli::rig::...` as a convenience (this is what other Rig provider crates do)
   - Add crate-level doc example showing the full usage pattern:
     ```rust
     //! # Example
     //! ```no_run
     //! use rig_cli::prelude::*;
     //!
     //! # async fn example() -> Result<(), Box<dyn std::error::Error>> {
     //! let client = ClaudeClient::new().await?;
     //! let agent = client.agent("sonnet")
     //!     .preamble("You are a helpful assistant")
     //!     .build();
     //! let response = agent.prompt("Hello!").await?;
     //! println!("{response}");
     //! # Ok(())
     //! # }
     //! ```
  </action>
  <verify>
Run `cargo check -p rig-cli` — passes.
Run `cargo doc -p rig-cli --no-deps` — generates clean docs with the example visible.
  </verify>
  <done>Prelude exports minimal set of types, lib.rs re-exports rig crate, crate-level docs show full usage pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Add escape hatches and debug-output feature</name>
  <files>rig-cli/src/claude.rs, rig-cli/src/codex.rs, rig-cli/src/opencode.rs, rig-cli/Cargo.toml, rig-cli/src/errors.rs</files>
  <action>
1. **Add escape hatch methods to each Client (claude.rs, codex.rs, opencode.rs):**
   On each Client, add:
   ```rust
   /// Access the underlying CompletionModel for advanced use cases.
   ///
   /// This is an escape hatch for developers who need access to adapter-specific
   /// functionality not exposed through the standard Rig provider interface.
   #[must_use]
   pub fn inner(&self) -> &rig_provider::{ClaudeModel|CodexModel|OpenCodeModel} {
       &self.inner
   }

   /// Access the client configuration.
   #[must_use]
   pub fn config(&self) -> &ClientConfig {
       &self.config
   }
   ```

2. **Add debug-output feature to Cargo.toml:**
   In `rig-cli/Cargo.toml` [features] section, add:
   ```toml
   debug-output = []
   ```
   This is NOT in default features. It is opt-in only.

3. **Conditionally include raw CLI output in errors:**
   In `rig-cli/src/errors.rs`, add a variant or modify `ExecutionFailed`:
   ```rust
   /// CLI execution failed.
   #[error("CLI execution failed: {message}")]
   ExecutionFailed {
       /// Human-readable error description.
       message: String,
       /// Raw CLI stdout (only populated with `debug-output` feature).
       #[cfg(feature = "debug-output")]
       stdout: String,
       /// Raw CLI stderr (only populated with `debug-output` feature).
       #[cfg(feature = "debug-output")]
       stderr: String,
   },
   ```

   Actually, using cfg on struct fields inside an enum variant is fragile. Better approach:
   - Keep `ExecutionFailed(String)` simple
   - Add a separate `ExecutionFailedDebug` variant that's only available with the feature:

   NO — even better, use the simplest approach: `ExecutionFailed` always has just a message. When `debug-output` is enabled, the message INCLUDES raw output. When disabled, it doesn't. This is purely a formatting decision in the code that constructs the error, not a struct layout change.

   So the error enum stays the same. Document in errors.rs that `debug-output` feature controls whether raw CLI output is included in error messages. The actual conditioning happens in the Client code where errors are created from adapter results.

   In each client's `new()` or wherever CLI errors are mapped, include raw output only under cfg:
   ```rust
   #[cfg(feature = "debug-output")]
   let detail = format!("{err}\n--- stdout ---\n{stdout}\n--- stderr ---\n{stderr}");
   #[cfg(not(feature = "debug-output"))]
   let detail = err.to_string();
   return Err(Error::ExecutionFailed(detail));
   ```

4. **Verify all feature combinations compile:**
   Run `cargo check -p rig-cli --no-default-features` (just errors/config)
   Run `cargo check -p rig-cli` (all features)
   Run `cargo check -p rig-cli --features debug-output` (debug mode)
   Run `cargo check -p rig-cli --features "claude,debug-output"` (single adapter + debug)
  </action>
  <verify>
Run `cargo check -p rig-cli --all-features` — passes.
Run `cargo check -p rig-cli --no-default-features` — passes.
Run `cargo check -p rig-cli --features "claude,debug-output"` — passes.
Run `cargo doc -p rig-cli --no-deps` — clean docs, escape hatch methods visible.
Run `cargo test -p rig-cli` — any unit tests pass (may be zero tests at this point, but no compilation errors).
  </verify>
  <done>Each Client has .inner() and .config() escape hatches. debug-output feature flag controls raw CLI output in errors. All feature combinations compile cleanly.</done>
</task>

</tasks>

<verification>
- `cargo check -p rig-cli --all-features` passes
- `cargo check -p rig-cli --no-default-features` passes
- `cargo check -p rig-cli --features "claude"` passes
- `cargo check -p rig-cli --features "codex"` passes
- `cargo check -p rig-cli --features "opencode"` passes
- `cargo check -p rig-cli --features "debug-output"` passes (with default features)
- `cargo doc -p rig-cli --no-deps` generates docs without warnings
- Prelude exports exactly: ClaudeClient, CodexClient, OpenCodeClient (feature-gated), Error, Prompt, Chat
- Each Client has .inner() returning reference to underlying model
- No internal types leak through the public API surface
</verification>

<success_criteria>
- Prelude provides ergonomic imports matching Rig convention
- Escape hatches available for advanced users
- debug-output feature flag works and is opt-in only
- All feature flag combinations compile
- Documentation is clean and shows usage examples
- The complete API chain works: `use rig_cli::prelude::*; ClaudeClient::new().await?.agent("model").preamble("...").build().prompt("...").await?`
</success_criteria>

<output>
After completion, create `.planning/phases/07-rig-integration-polish/07-04-SUMMARY.md`
</output>
