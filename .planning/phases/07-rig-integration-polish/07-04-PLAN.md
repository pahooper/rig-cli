---
phase: 07-rig-integration-polish
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - rig-cli/src/prelude.rs
  - rig-cli/src/claude.rs
  - rig-cli/src/codex.rs
  - rig-cli/src/opencode.rs
  - rig-cli/src/lib.rs
  - rig-cli/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "use rig_cli::prelude::* imports the most common types needed for typical usage"
    - "Each Client has .inner() or .raw() method for advanced users to access underlying CLI handle"
    - "features = [\"debug-output\"] enables raw CLI output in error messages"
    - "cargo check -p rig-cli passes with all feature combinations"
    - "cargo doc -p rig-cli --no-deps generates clean documentation"
    - "rig-cli re-exports JsonSchemaToolkit, ExtractionOrchestrator, and key MCP types for user convenience"
  artifacts:
    - path: "rig-cli/src/prelude.rs"
      provides: "Common re-exports for ergonomic imports"
      min_lines: 15
      contains: "pub use"
    - path: "rig-cli/src/lib.rs"
      provides: "Crate root with re-exports including MCP types"
      contains: "pub use rig"
  key_links:
    - from: "rig-cli/src/prelude.rs"
      to: "rig-cli/src/claude.rs"
      via: "re-export Client type"
      pattern: "claude::Client"
    - from: "rig-cli/src/lib.rs"
      to: "mcp/src/tools.rs"
      via: "re-export JsonSchemaToolkit for user convenience"
      pattern: "JsonSchemaToolkit"
    - from: "rig-cli/src/lib.rs"
      to: "mcp/src/extraction/orchestrator.rs"
      via: "re-export ExtractionOrchestrator"
      pattern: "ExtractionOrchestrator"
---

<objective>
Add prelude, escape hatches, debug-output feature flag, MCP type re-exports, and verify the complete API surface.

Purpose: Polish the public API with ergonomic imports (prelude), escape hatches for advanced users (.inner()), debug-output feature for production safety, re-export key MCP types (JsonSchemaToolkit, ExtractionOrchestrator, ExtractionConfig) so users don't need to depend on `rig-mcp-server` directly, and verify the entire crate compiles correctly across all feature combinations.
Output: Complete, polished rig-cli crate ready for use.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rig-integration-polish/07-CONTEXT.md
@.planning/phases/07-rig-integration-polish/07-RESEARCH.md
@.planning/phases/07-rig-integration-polish/07-01-SUMMARY.md
@.planning/phases/07-rig-integration-polish/07-02-SUMMARY.md
@.planning/phases/07-rig-integration-polish/07-03-SUMMARY.md
@rig-cli/src/lib.rs
@rig-cli/src/claude.rs
@rig-cli/src/codex.rs
@rig-cli/src/opencode.rs
@rig-cli/src/errors.rs
@rig-cli/Cargo.toml
@mcp/src/lib.rs
@mcp/src/tools.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prelude, add re-exports, and wire MCP types</name>
  <files>rig-cli/src/prelude.rs, rig-cli/src/lib.rs</files>
  <action>
1. **Populate `rig-cli/src/prelude.rs`:**
   Only export types used in 90%+ of interactions. Keep it minimal per Research pitfall #2.
   ```rust
   //! Common imports for rig-cli usage.
   //!
   //! ```
   //! use rig_cli::prelude::*;
   //! ```

   // Client types (feature-gated)
   #[cfg(feature = "claude")]
   pub use crate::claude::Client as ClaudeClient;
   #[cfg(feature = "codex")]
   pub use crate::codex::Client as CodexClient;
   #[cfg(feature = "opencode")]
   pub use crate::opencode::Client as OpenCodeClient;

   // Error type (always available)
   pub use crate::errors::Error;

   // Re-export key Rig traits so users don't need separate rig import
   pub use rig::completion::Prompt;
   pub use rig::completion::Chat;

   // Re-export key MCP types for structured extraction workflows
   // These are the types users need to build ToolSets for extraction
   pub use rig_mcp_server::tools::JsonSchemaToolkit;
   pub use rig_mcp_server::extraction::ExtractionOrchestrator;
   ```

   Do NOT export: AgentBuilder (accessed via client.agent()), Model types (internal), ClientConfig (used in advanced cases only), ToolSet (import from rig directly).

2. **Update `rig-cli/src/lib.rs`:**
   - Add `pub use rig;` at crate root so users can access Rig types via `rig_cli::rig::...`
   - Add re-export of key MCP types at crate root for discoverability:
     ```rust
     /// Re-export of MCP extraction types for structured data extraction workflows.
     ///
     /// These types come from the `rig-mcp-server` crate and are re-exported here
     /// so users don't need a direct dependency on it.
     pub mod extraction {
         pub use rig_mcp_server::extraction::{
             ExtractionConfig, ExtractionError, ExtractionMetrics,
             ExtractionOrchestrator,
         };
     }

     /// Re-export of MCP tool types for building tool-based extraction workflows.
     pub mod tools {
         pub use rig_mcp_server::tools::JsonSchemaToolkit;
         pub use rig_mcp_server::server::{RigMcpHandler, McpConfig, ToolSetExt};
     }
     ```
   - Add crate-level doc example showing the full usage pattern:
     ```rust
     //! # Example
     //! ```no_run
     //! use rig_cli::prelude::*;
     //!
     //! # async fn example() -> Result<(), Box<dyn std::error::Error>> {
     //! let client = ClaudeClient::new().await?;
     //! let agent = client.agent("sonnet")
     //!     .preamble("You are a helpful assistant")
     //!     .build();
     //! let response = agent.prompt("Hello!").await?;
     //! println!("{response}");
     //! # Ok(())
     //! # }
     //! ```
  </action>
  <verify>
Run `cargo check -p rig-cli` -- passes.
Run `cargo doc -p rig-cli --no-deps` -- generates clean docs with the example visible.
Verify `rig_cli::tools::JsonSchemaToolkit` is accessible.
Verify `rig_cli::extraction::ExtractionOrchestrator` is accessible.
  </verify>
  <done>Prelude exports minimal set of types including MCP types, lib.rs re-exports rig crate and MCP types, crate-level docs show full usage pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Add escape hatches and debug-output feature</name>
  <files>rig-cli/src/claude.rs, rig-cli/src/codex.rs, rig-cli/src/opencode.rs, rig-cli/Cargo.toml, rig-cli/src/errors.rs</files>
  <action>
1. **Add escape hatch methods to each Client (claude.rs, codex.rs, opencode.rs):**
   On each Client, add methods to access the underlying CLI handle for advanced use cases:
   ```rust
   /// Access the underlying CLI handle for advanced use cases.
   ///
   /// This is an escape hatch for developers who need access to adapter-specific
   /// functionality not exposed through the standard Rig provider interface.
   /// For example, to use McpToolAgent directly with custom configuration.
   #[must_use]
   pub fn cli(&self) -> &{ClaudeCli|CodexCli|OpenCodeCli} {
       &self.cli
   }

   /// Access the client configuration.
   #[must_use]
   pub fn config(&self) -> &ClientConfig {
       &self.config
   }
   ```

   NOTE: The escape hatch returns the CLI handle, NOT the old ClaudeModel. Users who need full control can use the CLI handle with McpToolAgent::builder() directly. This preserves the MCP enforcement philosophy -- even advanced users are guided toward the MCP path.

2. **Add debug-output feature to Cargo.toml:**
   In `rig-cli/Cargo.toml` [features] section, add:
   ```toml
   debug-output = []
   ```
   This is NOT in default features. It is opt-in only.

3. **Conditionally include raw CLI output in errors:**
   Keep `ExecutionFailed(String)` simple. When `debug-output` is enabled, the message INCLUDES raw output. When disabled, it doesn't. This is purely a formatting decision in the code that constructs the error, not a struct layout change.

   In each client's Model::completion() where CLI errors are mapped, include raw output only under cfg:
   ```rust
   #[cfg(feature = "debug-output")]
   let detail = format!("{err}\n--- stdout ---\n{stdout}\n--- stderr ---\n{stderr}");
   #[cfg(not(feature = "debug-output"))]
   let detail = err.to_string();
   return Err(Error::ExecutionFailed(detail));
   ```

4. **Verify all feature combinations compile:**
   Run `cargo check -p rig-cli --no-default-features` (just errors/config)
   Run `cargo check -p rig-cli` (all features)
   Run `cargo check -p rig-cli --features debug-output` (debug mode)
   Run `cargo check -p rig-cli --features "claude,debug-output"` (single adapter + debug)
  </action>
  <verify>
Run `cargo check -p rig-cli --all-features` -- passes.
Run `cargo check -p rig-cli --no-default-features` -- passes.
Run `cargo check -p rig-cli --features "claude,debug-output"` -- passes.
Run `cargo doc -p rig-cli --no-deps` -- clean docs, escape hatch methods visible.
Run `cargo test -p rig-cli` -- any unit tests pass.
  </verify>
  <done>Each Client has .cli() and .config() escape hatches. debug-output feature flag controls raw CLI output in errors. All feature combinations compile cleanly. MCP types re-exported for user convenience.</done>
</task>

</tasks>

<verification>
- `cargo check -p rig-cli --all-features` passes
- `cargo check -p rig-cli --no-default-features` passes
- `cargo check -p rig-cli --features "claude"` passes
- `cargo check -p rig-cli --features "codex"` passes
- `cargo check -p rig-cli --features "opencode"` passes
- `cargo check -p rig-cli --features "debug-output"` passes (with default features)
- `cargo doc -p rig-cli --no-deps` generates docs without warnings
- Prelude exports: ClaudeClient, CodexClient, OpenCodeClient (feature-gated), Error, Prompt, Chat, JsonSchemaToolkit, ExtractionOrchestrator
- `rig_cli::tools::JsonSchemaToolkit` is accessible
- `rig_cli::tools::RigMcpHandler` is accessible
- `rig_cli::extraction::ExtractionOrchestrator` is accessible
- Each Client has .cli() returning reference to underlying CLI handle
- No internal types leak through the public API surface beyond escape hatches
</verification>

<success_criteria>
- Prelude provides ergonomic imports matching Rig convention, including MCP types
- Escape hatches available for advanced users (returns CLI handle, not internal model)
- debug-output feature flag works and is opt-in only
- JsonSchemaToolkit, RigMcpHandler, ExtractionOrchestrator re-exported through rig-cli
- All feature flag combinations compile
- Documentation is clean and shows usage examples
- The complete API chain works: `use rig_cli::prelude::*; ClaudeClient::new().await?.agent("model").preamble("...").build().prompt("...").await?`
</success_criteria>

<output>
After completion, create `.planning/phases/07-rig-integration-polish/07-04-SUMMARY.md`
</output>
