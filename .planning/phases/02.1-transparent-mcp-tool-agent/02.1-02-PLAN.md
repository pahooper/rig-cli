---
phase: 02.1-transparent-mcp-tool-agent
plan: 02
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - rig-provider/src/mcp_agent.rs
  - rig-provider/src/lib.rs
  - rig-provider/src/errors.rs
autonomous: true

must_haves:
  truths:
    - "McpToolAgent::builder().toolset(ts).prompt(p).adapter(CliAdapter::ClaudeCode).run().await compiles"
    - "McpToolAgent::builder().toolset(ts).prompt(p).adapter(CliAdapter::Codex).run().await compiles"
    - "McpToolAgent::builder().toolset(ts).prompt(p).adapter(CliAdapter::OpenCode).run().await compiles"
    - "MCP config is auto-generated in correct format per adapter via McpConfig methods"
    - "Tool names auto-computed as mcp__<server>__<tool> from ToolSet definitions"
    - "Temp files cleaned via tempfile::NamedTempFile RAII"
    - "CLI binary is discovered automatically per adapter"
  artifacts:
    - path: "rig-provider/src/mcp_agent.rs"
      provides: "CliAdapter enum, McpToolAgentBuilder, McpToolAgentResult, run() execution"
      exports: ["CliAdapter", "McpToolAgentBuilder", "McpToolAgentResult"]
      min_lines: 150
    - path: "rig-provider/src/lib.rs"
      provides: "Module declaration and re-exports for mcp_agent"
      contains: "pub mod mcp_agent"
    - path: "rig-provider/src/errors.rs"
      provides: "McpToolAgent error variant in ProviderError"
      contains: "McpToolAgent"
  key_links:
    - from: "rig-provider/src/mcp_agent.rs"
      to: "mcp/src/server.rs"
      via: "Uses McpConfig to generate per-adapter config files"
      pattern: "to_claude_json|to_codex_toml|to_opencode_json"
    - from: "rig-provider/src/mcp_agent.rs"
      to: "claudecode-adapter"
      via: "Uses init() and ClaudeCli for Claude Code path"
      pattern: "claudecode_adapter::init|ClaudeCli"
    - from: "rig-provider/src/mcp_agent.rs"
      to: "codex-adapter"
      via: "Uses discover_codex() and CodexCli for Codex path"
      pattern: "codex_adapter::discover_codex|CodexCli"
    - from: "rig-provider/src/mcp_agent.rs"
      to: "opencode-adapter"
      via: "Uses discover_opencode() and OpenCodeCli for OpenCode path"
      pattern: "opencode_adapter::discover_opencode|OpenCodeCli"
---

<objective>
Create the McpToolAgent builder in rig-provider that transparently handles MCP server config generation, CLI discovery, and execution across all three supported CLIs. This is the core deliverable of Phase 2.1.

Purpose: Eliminates ~250 lines of MCP boilerplate. Instead of manually writing config files, discovering CLIs, computing tool names, and constructing RunConfigs, the developer calls McpToolAgent::builder().toolset(ts).prompt(p).adapter(CliAdapter::ClaudeCode).run().await.

Output: Working McpToolAgentBuilder with run() method in rig-provider/src/mcp_agent.rs, exported from the crate. All three CLI adapters supported. Temp file cleanup via RAII.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-transparent-mcp-tool-agent/02.1-RESEARCH.md
@.planning/phases/02.1-transparent-mcp-tool-agent/02.1-01-SUMMARY.md

@rig-provider/src/lib.rs
@rig-provider/src/errors.rs
@rig-provider/src/adapters/claude.rs
@rig-provider/src/adapters/codex.rs
@rig-provider/src/adapters/opencode.rs
@rig-provider/Cargo.toml
@mcp/src/server.rs
@claudecode-adapter/src/types.rs
@claudecode-adapter/src/lib.rs
@codex-adapter/src/types.rs
@codex-adapter/src/lib.rs
@opencode-adapter/src/types.rs
@opencode-adapter/src/lib.rs
@rig-provider/examples/mcp_extraction_e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CliAdapter enum, McpToolAgentBuilder, and config generation</name>
  <files>
    rig-provider/src/mcp_agent.rs
    rig-provider/src/lib.rs
    rig-provider/src/errors.rs
  </files>
  <action>
**1. Add error variant to errors.rs:**

Add a new variant to ProviderError:
```rust
/// Error from the MCP tool agent builder.
#[error("MCP tool agent error: {0}")]
McpToolAgent(String),
```

**2. Create rig-provider/src/mcp_agent.rs:**

This file contains the CliAdapter enum, McpToolAgentBuilder, McpToolAgentResult, and all execution logic.

**CliAdapter enum:**
```rust
/// Which CLI adapter to use for MCP tool agent execution.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CliAdapter {
    /// Use the Claude Code CLI (`claude --print`).
    ClaudeCode,
    /// Use the Codex CLI (`codex exec`).
    Codex,
    /// Use the OpenCode CLI (`opencode run`).
    OpenCode,
}
```

**McpToolAgentResult:**
```rust
/// Result of an McpToolAgent execution.
#[derive(Debug)]
pub struct McpToolAgentResult {
    /// The raw stdout output from the CLI.
    pub stdout: String,
    /// The raw stderr output from the CLI.
    pub stderr: String,
    /// Process exit code.
    pub exit_code: i32,
    /// Wall-clock duration in milliseconds.
    pub duration_ms: u64,
}
```

**McpToolAgentBuilder:**
```rust
/// Builder for configuring and running an MCP-backed CLI agent.
///
/// Accepts a Rig `ToolSet`, a prompt, and a CLI adapter choice. Handles
/// all MCP plumbing transparently: config generation, temp file management,
/// CLI discovery, tool name computation, and execution.
pub struct McpToolAgentBuilder {
    toolset: Option<rig::tool::ToolSet>,
    prompt: Option<String>,
    adapter: Option<CliAdapter>,
    server_name: String,
    system_prompt: Option<String>,
    timeout: std::time::Duration,
}
```

impl McpToolAgentBuilder:
- `fn new() -> Self` with defaults: server_name = "rig_mcp".to_string(), timeout = Duration::from_secs(300)
- `pub fn toolset(mut self, toolset: rig::tool::ToolSet) -> Self`
- `pub fn prompt(mut self, prompt: impl Into<String>) -> Self`
- `pub fn adapter(mut self, adapter: CliAdapter) -> Self`
- `pub fn server_name(mut self, name: impl Into<String>) -> Self`
- `pub fn system_prompt(mut self, prompt: impl Into<String>) -> Self`
- `pub fn timeout(mut self, timeout: std::time::Duration) -> Self`

**McpToolAgent namespace struct:**
```rust
/// MCP-backed CLI agent that transparently handles MCP config generation,
/// CLI discovery, and tool name computation.
pub struct McpToolAgent;

impl McpToolAgent {
    /// Returns a new builder for configuring the agent.
    #[must_use]
    pub fn builder() -> McpToolAgentBuilder {
        McpToolAgentBuilder::new()
    }
}
```

**Core run() method on McpToolAgentBuilder:**
```rust
pub async fn run(self) -> Result<McpToolAgentResult, crate::errors::ProviderError>
```

The run() method must:

1. Validate required fields: toolset, prompt, adapter. Return ProviderError::McpToolAgent if missing.

2. Get tool definitions from toolset:
   ```rust
   let definitions = toolset.get_tool_definitions().await
       .map_err(|e| ProviderError::McpToolAgent(format!("Failed to get tool definitions: {e}")))?;
   ```
   NOTE: ToolSetError in rig 0.29 does NOT impl std::error::Error, so use .map_err() not ?.

3. Build McpConfig:
   ```rust
   let exe = std::env::current_exe()
       .map_err(|e| ProviderError::McpToolAgent(format!("Failed to get current exe: {e}")))?;
   let mcp_config = rig_mcp_server::McpConfig {
       name: self.server_name.clone(),
       command: exe.to_string_lossy().to_string(),
       args: vec![],
       env: {
           let mut env = std::collections::HashMap::new();
           env.insert("RIG_MCP_SERVER".to_string(), "1".to_string());
           env
       },
   };
   ```

4. Compute allowed tool names:
   ```rust
   let allowed_tools: Vec<String> = definitions.iter()
       .map(|def| format!("mcp__{}__{}",  self.server_name, def.name))
       .collect();
   ```

5. Write MCP config to temp file (adapter-specific format):
   ```rust
   let config_file = tempfile::NamedTempFile::new()
       .map_err(|e| ProviderError::McpToolAgent(format!("Failed to create temp file: {e}")))?;
   ```
   Per adapter:
   - ClaudeCode: write mcp_config.to_claude_json() as JSON
   - Codex: write mcp_config.to_codex_toml() as TOML
   - OpenCode: write mcp_config.to_opencode_json() as JSON

   Convert to TempPath to keep alive: `let _config_guard = config_file.into_temp_path();`
   Get path before converting.

6. Build system prompt (combine user system_prompt with MCP instruction):
   ```rust
   let mcp_instruction = format!(
       "You MUST use the MCP tools to complete this task. \
        Available tools: {}. \
        Do NOT output raw JSON text as your response -- use the tools.",
       allowed_tools.join(", ")
   );
   let full_system_prompt = match self.system_prompt {
       Some(sp) => format!("{sp}\n\n{mcp_instruction}"),
       None => mcp_instruction,
   };
   ```

7. Execute per adapter (match on self.adapter):

   **CliAdapter::ClaudeCode:**
   ```rust
   let report = claudecode_adapter::init(None).await
       .map_err(|e| ProviderError::McpToolAgent(format!("Claude init failed: {e}")))?;
   let cli = claudecode_adapter::ClaudeCli::new(report.claude_path, report.capabilities);
   let config = claudecode_adapter::RunConfig {
       output_format: Some(claudecode_adapter::OutputFormat::Text),
       system_prompt: claudecode_adapter::SystemPromptMode::Append(full_system_prompt),
       mcp: Some(claudecode_adapter::McpPolicy {
           configs: vec![config_path.to_string_lossy().to_string()],
           strict: false,
       }),
       tools: claudecode_adapter::ToolPolicy {
           builtin: claudecode_adapter::BuiltinToolSet::Default,
           allowed: Some(allowed_tools),
           disallowed: None,
           disable_slash_commands: true,
       },
       timeout: self.timeout,
       ..claudecode_adapter::RunConfig::default()
   };
   let result = cli.run(&self_prompt, &config).await
       .map_err(|e| ProviderError::Claude(e))?;
   Ok(McpToolAgentResult {
       stdout: result.stdout,
       stderr: result.stderr,
       exit_code: result.exit_code,
       duration_ms: result.duration_ms,
   })
   ```

   **CliAdapter::Codex:**
   ```rust
   let path = codex_adapter::discover_codex()
       .map_err(|e| ProviderError::McpToolAgent(format!("Codex discovery failed: {e}")))?;
   let cli = codex_adapter::CodexCli::new(path);
   let config = codex_adapter::CodexConfig {
       full_auto: true,
       system_prompt: Some(full_system_prompt),
       mcp_config_path: Some(config_path.to_path_buf()),
       timeout: self.timeout,
       ..codex_adapter::CodexConfig::default()
   };
   let result = cli.run(&self_prompt, &config).await
       .map_err(|e| ProviderError::Codex(e))?;
   Ok(McpToolAgentResult {
       stdout: result.stdout,
       stderr: result.stderr,
       exit_code: result.exit_code,
       duration_ms: result.duration_ms,
   })
   ```

   **CliAdapter::OpenCode:**
   ```rust
   let path = opencode_adapter::discover_opencode()
       .map_err(|e| ProviderError::McpToolAgent(format!("OpenCode discovery failed: {e}")))?;
   let cli = opencode_adapter::OpenCodeCli::new(path);
   let config = opencode_adapter::OpenCodeConfig {
       prompt: Some(full_system_prompt),
       mcp_config_path: Some(config_path.to_path_buf()),
       timeout: self.timeout,
       ..opencode_adapter::OpenCodeConfig::default()
   };
   let result = cli.run(&self_prompt, &config).await
       .map_err(|e| ProviderError::OpenCode(e))?;
   Ok(McpToolAgentResult {
       stdout: result.stdout,
       stderr: result.stderr,
       exit_code: result.exit_code,
       duration_ms: result.duration_ms,
   })
   ```

**CRITICAL implementation notes:**
- Do NOT use .unwrap() or .expect() anywhere. Use .map_err() for all fallible operations.
- ToolSetError does NOT impl std::error::Error in rig 0.29. Use `.map_err(|e| ProviderError::McpToolAgent(format!("...")))` not `?`.
- The `#![deny(missing_docs)]` lint is active on rig-provider. ALL public items need `///` doc comments.
- Use `std::io::Write` trait for writing to NamedTempFile (import it).
- The _config_guard must stay alive until after the CLI run completes (RAII cleanup). Keep it in scope.
- Do NOT set env vars on the current process (std::env::set_var) -- only pass them via adapter configs.

**3. Update lib.rs:**
Add after `pub mod utils;`:
```rust
/// MCP tool agent builder for transparent CLI orchestration.
pub mod mcp_agent;
```

Add re-exports:
```rust
pub use mcp_agent::{CliAdapter, McpToolAgent, McpToolAgentBuilder, McpToolAgentResult};
```
  </action>
  <verify>
Run `cargo check -p rig-provider 2>&1` -- must compile with zero errors. Run `cargo clippy -p rig-provider 2>&1` -- no new warnings. Verify that McpToolAgent::builder() is accessible from the crate root.
  </verify>
  <done>
McpToolAgent::builder().toolset(ts).prompt(p).adapter(CliAdapter::ClaudeCode).run().await compiles. Same for Codex and OpenCode. MCP config auto-generated per adapter format. Tool names auto-computed. Temp files use RAII cleanup. All public items have doc comments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add helper method for allowed_tools and verify workspace compilation</name>
  <files>
    rig-provider/src/mcp_agent.rs
  </files>
  <action>
Add a public helper method to McpToolAgentBuilder that returns the computed tool names without running the agent. This is useful for callers who need the tool name list for other purposes:

```rust
/// Computes the MCP tool names that will be passed to the CLI's allowed-tools list.
///
/// Tool names follow the pattern `mcp__<server_name>__<tool_name>`.
///
/// # Errors
/// Returns an error if the toolset is not set or if fetching tool definitions fails.
pub async fn compute_tool_names(&self) -> Result<Vec<String>, crate::errors::ProviderError> {
    let toolset = self.toolset.as_ref()
        .ok_or_else(|| ProviderError::McpToolAgent("toolset is required".to_string()))?;
    let definitions = toolset.get_tool_definitions().await
        .map_err(|e| ProviderError::McpToolAgent(format!("Failed to get tool definitions: {e}")))?;
    Ok(definitions.iter()
        .map(|def| format!("mcp__{}__{}",  self.server_name, def.name))
        .collect())
}
```

WAIT -- ToolSet doesn't implement Clone, and the builder takes ownership in run(). The compute_tool_names method needs a reference to the toolset. But run() takes self by value. This means compute_tool_names must take &self and toolset must be borrowed.

Actually, looking at the builder more carefully: the toolset field is Option<ToolSet>, and run() takes self (moves). compute_tool_names() should take &self and reference the toolset. This works fine since get_tool_definitions takes &self on ToolSet.

Now run the full workspace compilation:
```
cargo check --workspace
cargo clippy --workspace
```

Fix any compilation errors. Common issues to watch for:
- Missing imports (use std::io::Write for writing to NamedTempFile)
- Missing doc comments on public items
- Type mismatches between adapter RunResult fields and McpToolAgentResult fields
- ToolSet lifetime issues

If codex_adapter::CodexConfig or opencode_adapter::OpenCodeConfig don't have the new fields (Plan 01 not applied yet), this won't compile. The plan depends_on 02.1-01 for this reason.
  </action>
  <verify>
Run `cargo check --workspace 2>&1` -- zero errors across all crates. Run `cargo clippy --workspace 2>&1` -- no new warnings from rig-provider. Verify McpToolAgent, CliAdapter, McpToolAgentResult are all re-exported from rig-provider crate root.
  </verify>
  <done>
Full workspace compiles. McpToolAgent builder has run() for execution and compute_tool_names() for introspection. All three CliAdapter variants produce correct MCP config formats. rig-provider exports McpToolAgent, CliAdapter, McpToolAgentBuilder, McpToolAgentResult.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` passes with zero errors
2. `cargo clippy --workspace` has no new warnings
3. McpToolAgent::builder().toolset(ts).prompt("test").adapter(CliAdapter::ClaudeCode).run() compiles
4. McpToolAgent::builder().toolset(ts).prompt("test").adapter(CliAdapter::Codex).run() compiles
5. McpToolAgent::builder().toolset(ts).prompt("test").adapter(CliAdapter::OpenCode).run() compiles
6. Tool names follow mcp__<server>__<tool> pattern
7. Temp config files use NamedTempFile RAII cleanup
8. No .unwrap() or .expect() in any new code
9. All public items have doc comments
</verification>

<success_criteria>
- McpToolAgent builder API is ergonomic: toolset + prompt + adapter = run
- All three adapters supported with correct MCP config format per CLI
- Claude Code: JSON via --mcp-config flag, --allowed-tools
- Codex: TOML config, --system-prompt, full_auto mode
- OpenCode: JSON via OPENCODE_CONFIG env var, --system-prompt
- Tool names auto-computed from ToolSet definitions
- Temp files auto-cleaned via RAII
- Full workspace compiles
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-transparent-mcp-tool-agent/02.1-02-SUMMARY.md`
</output>
