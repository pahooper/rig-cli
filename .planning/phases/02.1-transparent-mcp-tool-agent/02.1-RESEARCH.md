# Phase 2.1: Transparent MCP Tool Agent - Research

**Researched:** 2026-02-01
**Domain:** Rust builder pattern API design for MCP tool agent automation
**Confidence:** HIGH

## Summary

This phase aims to eliminate ~250 lines of boilerplate from the current mcp_extraction_e2e.rs example by creating an McpToolAgent builder that transparently handles MCP server spawning, config generation, and CLI orchestration. The research reveals that the key technical components are well-established Rust patterns:

1. **RAII guard pattern** with Drop trait for automatic temp file cleanup
2. **Environment variable mode detection** using std::env::var() for server vs client mode
3. **Builder pattern** with fluent interface for ergonomic configuration
4. **Process self-spawning** using Command::new(current_exe()) with env vars

The standard approach is to create a builder that accepts a ToolSet and prompt, auto-generates MCP config JSON with computed tool names (mcp__<server>__<tool>), spawns the current binary as an MCP server via environment variable, and uses RAII guards to ensure temp file cleanup even on panic.

**Primary recommendation:** Build McpToolAgent in rig-provider/ crate (already depends on both mcp/ and claudecode-adapter/), use tempfile crate's NamedTempFile for RAII cleanup, and implement env var-based mode detection to replace the current --server flag pattern.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| tempfile | 3.10+ | Temporary file management with RAII | Already in Cargo.toml, provides automatic cleanup via Drop trait, handles edge cases like signal interrupts |
| std::process::Command | stdlib | Process spawning and management | Standard library support for spawning child processes with full control over stdio, args, and env |
| std::env | stdlib | Environment variable access | Standard pattern for mode detection and configuration passing |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| serde_json | 1.0 | MCP config JSON generation | Already in use, for building Claude Code JSON config format |
| which | 6.0 | Executable path resolution | Already in claudecode-adapter for Claude CLI discovery |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| tempfile | Manual file cleanup | No RAII guarantees, error-prone, must handle all failure modes manually |
| Environment variables | CLI flags (--server) | Current approach, requires boilerplate in user code, less transparent |
| rig-provider/ location | New crate | Additional dependency management complexity, overkill for single-purpose builder |

**Installation:**
No new dependencies needed - all required crates are already in Cargo.toml files.

## Architecture Patterns

### Recommended Project Structure
```
rig-provider/src/
├── adapters/
│   └── claude.rs        # Existing ClaudeModel
├── lib.rs               # Re-export McpToolAgent
└── mcp_agent.rs         # NEW: McpToolAgent builder
```

### Pattern 1: RAII Guard for Cleanup
**What:** Use RAII (Resource Acquisition Is Initialization) with Drop trait to guarantee cleanup of temp files
**When to use:** Any resource that must be cleaned up (temp files, file locks, network connections)
**Example:**
```rust
// Source: https://docs.rs/tempfile/latest/tempfile/struct.NamedTempFile.html
use tempfile::NamedTempFile;

// TempFile implements Drop - cleanup is automatic
let config_file = NamedTempFile::new()?;
let config_path = config_file.path().to_path_buf();

// Write config
fs::write(&config_path, json_content)?;

// File persists while NamedTempFile is alive
// Automatic cleanup when config_file goes out of scope
// Even on panic or early return
```

### Pattern 2: Environment Variable Mode Detection
**What:** Binary checks environment variable to determine server vs client mode
**When to use:** When binary needs dual-mode behavior without CLI flag boilerplate
**Example:**
```rust
// Source: https://doc.rust-lang.org/std/env/fn.var.html
use std::env;

const MCP_SERVER_MODE: &str = "RIG_MCP_SERVER";

fn main() -> Result<()> {
    // Check if running as MCP server
    if env::var(MCP_SERVER_MODE).is_ok() {
        // Server mode: serve tools over stdio
        return run_mcp_server().await;
    }

    // Client mode: spawn server and orchestrate CLI
    run_client().await
}
```

### Pattern 3: Builder Pattern with Fluent Interface
**What:** Builder pattern with methods returning Self for method chaining
**When to use:** Complex object construction with many optional parameters
**Example:**
```rust
// Source: https://rust-unofficial.github.io/patterns/patterns/creational/builder.html
pub struct McpToolAgent {
    toolset: ToolSet,
    prompt: String,
    server_name: String,
    config: RunConfig,
}

impl McpToolAgent {
    pub fn builder() -> McpToolAgentBuilder {
        McpToolAgentBuilder::default()
    }
}

pub struct McpToolAgentBuilder {
    toolset: Option<ToolSet>,
    prompt: Option<String>,
    server_name: String,
    config: RunConfig,
}

impl McpToolAgentBuilder {
    pub fn toolset(mut self, toolset: ToolSet) -> Self {
        self.toolset = Some(toolset);
        self
    }

    pub fn prompt(mut self, prompt: impl Into<String>) -> Self {
        self.prompt = Some(prompt.into());
        self
    }

    pub fn server_name(mut self, name: impl Into<String>) -> Self {
        self.server_name = name.into();
        self
    }

    pub async fn run(self) -> Result<RunResult> {
        let toolset = self.toolset.ok_or("toolset required")?;
        let prompt = self.prompt.ok_or("prompt required")?;

        // Auto-spawn server, generate config, run CLI
        self.execute_with_mcp_server(toolset, prompt).await
    }
}
```

### Pattern 4: Process Self-Spawning
**What:** Binary spawns itself as child process with different mode via environment variable
**When to use:** When binary needs to act as both client and server
**Example:**
```rust
// Source: https://doc.rust-lang.org/std/process/struct.Command.html
use std::process::Command;
use std::env;

// Get current executable path
let exe = env::current_exe()?;

// Spawn self as MCP server with env var set
let mut child = Command::new(exe)
    .env("RIG_MCP_SERVER", "1")
    .arg("--output-path")
    .arg(result_path)
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

// Child process will detect RIG_MCP_SERVER=1 and run in server mode
```

### Pattern 5: Auto-Computed Tool Names
**What:** Compute MCP tool names as `mcp__<server_name>__<tool_name>` from ToolSet definitions
**When to use:** When building allowed-tools list for Claude Code --allowed-tools flag
**Example:**
```rust
// Get tool definitions from ToolSet
let definitions = toolset.get_tool_definitions().await?;

// Compute full MCP tool names as Claude Code sees them
let tool_names: Vec<String> = definitions
    .into_iter()
    .map(|def| format!("mcp__{server_name}__{}", def.name))
    .collect();

// Pass to Claude Code via --allowed-tools
config.tools.allowed = Some(tool_names);
```

### Anti-Patterns to Avoid

- **Manual cleanup in Drop**: Don't try to implement cleanup yourself - use tempfile crate which handles edge cases like signal interrupts
- **Blocking in async context**: Command::spawn() is fine, but use tokio::process::Command for async spawning if needed for timeout handling
- **Global static temp files**: TempDir and NamedTempFile fail to clean up if declared as static (with lazy_static) - keep them as local variables
- **Ignoring Child::drop**: std::process::Child doesn't implement Drop - child processes continue running if not explicitly waited on or killed

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Temp file cleanup | Manual Delete in Drop impl | tempfile::NamedTempFile | Handles signal interrupts, process exits, panic unwinding, proper cleanup ordering |
| Process spawning | Raw fork/exec | std::process::Command | Cross-platform, handles stdio redirection, environment variables, proper error handling |
| JSON config generation | String concatenation | serde_json::json! macro | Type-safe, handles escaping, validates structure at compile time |
| MCP config structure | Custom struct | Existing McpConfig in server.rs | Already has to_claude_json(), to_codex_toml(), to_opencode_json() methods |

**Key insight:** Temp file cleanup has many edge cases (SIGINT, panic, static lifetime, nested cleanup order). The tempfile crate handles all of these correctly. Manual cleanup will miss edge cases and lead to temp file leaks.

## Common Pitfalls

### Pitfall 1: TempFile Cleanup Failure
**What goes wrong:** Temp files are not deleted if the process exits abnormally (SIGINT, segfault) or if the TempFile is declared static
**Why it happens:** Drop destructors may not run in certain exit scenarios
**How to avoid:** Use local variables for TempFile/TempDir, not static. Document that cleanup is best-effort and may fail on abnormal termination.
**Warning signs:** Temp files accumulating in /tmp after repeated runs

### Pitfall 2: Tool Name Mismatch
**What goes wrong:** Claude Code can't find MCP tools because tool names don't match the `mcp__<server>__<tool>` pattern
**Why it happens:** Server name or tool names computed incorrectly, or mismatch between MCP config and --allowed-tools list
**How to avoid:** Use consistent server_name throughout. Compute tool names from ToolSet definitions, not hardcoded strings. Use same logic for MCP config args field and --allowed-tools list.
**Warning signs:** Claude Code reports "tool not found" or doesn't call any MCP tools

### Pitfall 3: Server Hangs on Startup
**What goes wrong:** MCP server process starts but never completes handshake, client times out
**Why it happens:** Server writes to stdout (which is the MCP transport), breaking protocol. Or server panics during initialization before serving.
**How to avoid:** Use serve_stdio() not run_stdio() (run_stdio prints config banners to stderr). Ensure ToolSet is valid before spawning server. Log server errors to stderr or file, never stdout.
**Warning signs:** Client timeout, no MCP communication, server process remains alive

### Pitfall 4: Child Process Zombies
**What goes wrong:** MCP server process becomes a zombie after CLI completes
**Why it happens:** Child::drop() doesn't wait on child process - process continues running
**How to avoid:** Explicitly wait on or kill child process. Use tokio::process::Child::wait() or kill() with timeout. Don't rely on Drop for cleanup.
**Warning signs:** Multiple server processes accumulating, zombie processes in `ps aux`

### Pitfall 5: Environment Variable Leakage
**What goes wrong:** Setting RIG_MCP_SERVER=1 globally affects subsequent commands
**Why it happens:** std::env::set_var() modifies process-global state
**How to avoid:** Only set env vars on Command before spawn, never call std::env::set_var(). Pass env vars via Command.env() which only affects child.
**Warning signs:** Non-server code unexpectedly running in server mode

## Code Examples

Verified patterns from official sources:

### Temp File with RAII Cleanup
```rust
// Source: https://docs.rs/tempfile/latest/tempfile/
use tempfile::NamedTempFile;
use std::io::Write;

// Create temp file - cleanup happens automatically on drop
let mut config_file = NamedTempFile::new()?;

// Write MCP config JSON
let json = serde_json::json!({
    "mcpServers": {
        "rig_extraction": {
            "command": exe_path,
            "args": ["--output-path", result_path],
            "env": {"RIG_MCP_SERVER": "1"}
        }
    }
});
write!(config_file, "{}", serde_json::to_string_pretty(&json)?)?;

// Get path before moving
let config_path = config_file.path().to_path_buf();

// Keep alive with into_temp_path() if needed beyond scope
let _guard = config_file.into_temp_path();
```

### Environment Variable Mode Detection
```rust
// Source: https://doc.rust-lang.org/std/env/fn.var.html
use std::env;

const RIG_MCP_SERVER: &str = "RIG_MCP_SERVER";

#[tokio::main]
async fn main() -> Result<()> {
    // Server mode detection
    if env::var(RIG_MCP_SERVER).is_ok() {
        // Running as MCP server
        let toolset = build_toolset()?;
        toolset.into_handler().await?
            .serve_stdio()  // NOT run_stdio - no banners to stdout
            .await?;
        return Ok(());
    }

    // Client mode - spawn server and run CLI
    McpToolAgent::builder()
        .toolset(build_toolset()?)
        .prompt("Extract data...")
        .run()
        .await
}
```

### Tool Name Computation
```rust
// Source: Existing mcp_extraction_e2e.rs example
const SERVER_NAME: &str = "rig_extraction";

// Get tool definitions from ToolSet
let definitions = toolset.get_tool_definitions().await?;

// Compute MCP tool names as Claude Code sees them
let allowed_tools: Vec<String> = definitions
    .into_iter()
    .map(|def| format!("mcp__{SERVER_NAME}__{}", def.name))
    .collect();

// Use in RunConfig
let config = RunConfig {
    mcp: Some(McpPolicy {
        configs: vec![config_path.to_string_lossy().to_string()],
        strict: false,
    }),
    tools: ToolPolicy {
        builtin: BuiltinToolSet::Default,
        allowed: Some(allowed_tools),
        disallowed: None,
        disable_slash_commands: true,
    },
    ..RunConfig::default()
};
```

### Self-Spawn with Environment Variable
```rust
// Source: https://doc.rust-lang.org/std/process/struct.Command.html
use std::process::{Command, Stdio};
use std::env;

// Get current executable
let exe = env::current_exe()?;

// Spawn self as MCP server
let mut server_cmd = Command::new(&exe);
server_cmd
    .env("RIG_MCP_SERVER", "1")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .stderr(Stdio::inherit());  // Log server errors to parent stderr

let server_process = server_cmd.spawn()?;

// Server will detect RIG_MCP_SERVER and run in server mode
// Client continues to spawn Claude CLI...
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| CLI flags for mode (--server) | Environment variable detection | Phase 2.1 (this phase) | Eliminates user-visible flag, reduces boilerplate |
| Manual temp file cleanup | tempfile crate RAII | Already standard | Automatic cleanup with panic safety |
| Manual MCP config JSON | McpConfig.to_claude_json() | Already in server.rs | Type-safe config generation |
| Hardcoded tool names | Computed from ToolSet definitions | Phase 2.1 (this phase) | Dynamic tool discovery, no name mismatches |

**Deprecated/outdated:**
- **Manual --server flag parsing**: Replaced by RIG_MCP_SERVER env var for transparent mode detection
- **Manual RunConfig construction**: Will be replaced by McpToolAgent builder with sensible defaults

## Open Questions

Things that couldn't be fully resolved:

1. **Where should McpToolAgent live?**
   - What we know: rig-provider/ already depends on both mcp/ and claudecode-adapter/
   - What's unclear: Is this the right architectural boundary? Should it be in mcp/ instead?
   - Recommendation: rig-provider/src/mcp_agent.rs - it's the integration layer between mcp/ and adapters/

2. **Should McpToolAgent support multiple CLI adapters or just Claude Code?**
   - What we know: Codex and OpenCode exist with similar RunConfig APIs
   - What's unclear: Is multi-CLI support a goal for this phase?
   - Recommendation: Start with Claude Code only (success criteria mentions Claude CLI specifically), add adapter abstraction in later phase if needed

3. **How should server process lifecycle be managed?**
   - What we know: Child::drop() doesn't wait on process, can create zombies
   - What's unclear: Should we spawn with tokio::process for async wait? Use scoped threads?
   - Recommendation: Use std::process::Command for now (simpler), but explicitly kill and wait on server process in Drop or after CLI completes. Document that zombies may occur on panic.

4. **Should temp files use named or unnamed tempfiles?**
   - What we know: MCP config needs a path to pass to --mcp-config. Result file needs a path for server --output-path.
   - What's unclear: Are there security benefits to unnamed tempfiles?
   - Recommendation: Use NamedTempFile for both - paths are required by the architecture

5. **How should server startup errors be surfaced?**
   - What we know: Server may fail to start (ToolSet invalid, port conflict, etc.)
   - What's unclear: How to detect server startup failure vs server running but Claude CLI failing?
   - Recommendation: Add timeout for first MCP handshake, read server stderr for errors. This may need improvement in later phases.

## Sources

### Primary (HIGH confidence)
- [tempfile crate documentation](https://docs.rs/tempfile/latest/tempfile/) - RAII temp file management
- [std::process::Command documentation](https://doc.rust-lang.org/std/process/struct.Command.html) - Process spawning
- [std::env module documentation](https://doc.rust-lang.org/std/env/index.html) - Environment variable access
- [Rust RAII Design Pattern](https://rust-unofficial.github.io/patterns/patterns/behavioural/RAII.html) - RAII guard pattern
- [Builder Pattern - Rust Design Patterns](https://rust-unofficial.github.io/patterns/patterns/creational/builder.html) - Builder pattern best practices
- [Effective Rust - Item 11: Implement the Drop trait for RAII patterns](https://effective-rust.com/raii.html) - Drop trait usage

### Secondary (MEDIUM confidence)
- [MCP Server Naming Conventions](https://zazencodes.com/blog/mcp-server-naming-conventions) - MCP tool naming patterns verified against spec
- [Tool Naming Convention - ShotGrid MCP Server](https://pipeline-f26f1c83.mintlify.app/guides/tool-naming-convention) - Real-world MCP naming examples
- [How to build a Rust API with the builder pattern - LogRocket](https://blog.logrocket.com/build-rust-api-builder-pattern/) - Modern builder pattern techniques
- [Working with Environment Variables - The Rust Programming Language](https://doc.rust-lang.org/book/ch12-05-working-with-environment-variables.html) - Official book guidance on env vars

### Tertiary (LOW confidence)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/about.html) - General API design recommendations (not specific to this problem)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All crates are already in use, well-documented, and stable
- Architecture: HIGH - RAII, builder, env var patterns are well-established and documented in official sources
- Pitfalls: MEDIUM - Derived from WebSearch and existing example code, not all verified in production

**Research date:** 2026-02-01
**Valid until:** 2026-03-01 (30 days - stable technologies, unlikely to change)
