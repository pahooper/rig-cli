---
phase: 02.1-transparent-mcp-tool-agent
plan: 03
type: execute
wave: 3
depends_on: ["02.1-02"]
files_modified:
  - rig-provider/examples/mcp_tool_agent_e2e.rs
autonomous: true

must_haves:
  truths:
    - "New mcp_tool_agent_e2e example compiles and is under 80 lines"
    - "Example demonstrates McpToolAgent builder API with env var server mode detection"
    - "Example shows the full pattern: define type, build toolset, detect mode, run agent"
    - "Full workspace compiles with cargo check --workspace"
    - "Old mcp_extraction_e2e.rs still compiles (not removed, just supplemented)"
  artifacts:
    - path: "rig-provider/examples/mcp_tool_agent_e2e.rs"
      provides: "Simplified example demonstrating McpToolAgent API"
      min_lines: 30
      contains: "McpToolAgent::builder"
  key_links:
    - from: "rig-provider/examples/mcp_tool_agent_e2e.rs"
      to: "rig-provider/src/mcp_agent.rs"
      via: "Uses McpToolAgent::builder(), CliAdapter"
      pattern: "McpToolAgent::builder|CliAdapter"
    - from: "rig-provider/examples/mcp_tool_agent_e2e.rs"
      to: "mcp/src/server.rs"
      via: "Uses ToolSetExt::serve_stdio() in server mode"
      pattern: "serve_stdio|into_handler"
---

<objective>
Create a new simplified example demonstrating the McpToolAgent API that collapses the ~300-line mcp_extraction_e2e.rs pattern into ~50 lines. This proves the API works and serves as documentation.

Purpose: The McpToolAgent was designed to eliminate MCP boilerplate. This example proves the promise: same functionality in a fraction of the code. It also serves as the primary code example for documentation.

Output: New `mcp_tool_agent_e2e.rs` example file. Old example preserved for reference.
</objective>

<execution_context>
@/home/pnod/.claude/get-shit-done/workflows/execute-plan.md
@/home/pnod/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-transparent-mcp-tool-agent/02.1-01-SUMMARY.md
@.planning/phases/02.1-transparent-mcp-tool-agent/02.1-02-SUMMARY.md

@rig-provider/src/mcp_agent.rs
@rig-provider/src/lib.rs
@rig-provider/examples/mcp_extraction_e2e.rs
@mcp/src/server.rs
@mcp/src/tools.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create simplified mcp_tool_agent_e2e example</name>
  <files>
    rig-provider/examples/mcp_tool_agent_e2e.rs
  </files>
  <action>
Create a new example file that demonstrates the McpToolAgent API. The example should:

1. Define a target struct (reuse TextSummary or similar -- simple, 4-5 fields, derives Deserialize, Serialize, JsonSchema)
2. Use env var detection for server mode (RIG_MCP_SERVER)
3. In server mode: build ToolSet with JsonSchemaToolkit, serve over stdio
4. In client mode: use McpToolAgent::builder() to run with Claude Code

Structure (target ~50-60 lines):
```rust
//! Simplified MCP extraction using McpToolAgent.
//!
//! This example shows how McpToolAgent eliminates MCP boilerplate.
//! Compare with mcp_extraction_e2e.rs (~300 lines) for the manual approach.
//!
//! The binary runs in two modes via environment variable detection:
//! - Server mode (RIG_MCP_SERVER=1): Serves MCP tools over stdio
//! - Client mode (default): Uses McpToolAgent to orchestrate the CLI
//!
//! Run with: `cargo run --example mcp_tool_agent_e2e`

use rig::tool::ToolSet;
use rig_mcp_server::prelude::ToolSetExt;
use rig_mcp_server::tools::JsonSchemaToolkit;
use rig_provider::{CliAdapter, McpToolAgent};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct MovieReview {
    /// Title of the movie.
    title: String,
    /// Rating from 1 to 10.
    rating: u8,
    /// Brief summary in 1-2 sentences.
    summary: String,
    /// List of genres.
    genres: Vec<String>,
}

fn build_toolset() -> ToolSet {
    let mut toolset = ToolSet::default();
    let (submit, validate, example) = JsonSchemaToolkit::<MovieReview>::builder()
        .example(MovieReview {
            title: "The Matrix".to_string(),
            rating: 9,
            summary: "A hacker discovers reality is a simulation.".to_string(),
            genres: vec!["Sci-Fi".to_string(), "Action".to_string()],
        })
        .build()
        .build_tools();
    toolset.add_tool(submit);
    toolset.add_tool(validate);
    toolset.add_tool(example);
    toolset
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Server mode: MCP tools over stdio
    if std::env::var("RIG_MCP_SERVER").is_ok() {
        return Ok(build_toolset().into_handler().await?.serve_stdio().await?);
    }

    // Client mode: McpToolAgent handles everything
    let result = McpToolAgent::builder()
        .toolset(build_toolset())
        .prompt("Create a movie review for Inception (2010) by Christopher Nolan. \
                 Use the json_example tool to see the format, validate_json to check, \
                 then submit your review.")
        .adapter(CliAdapter::ClaudeCode)
        .server_name("rig_extraction")
        .run()
        .await?;

    println!("Exit code: {}", result.exit_code);
    println!("Output:\n{}", result.stdout);

    Ok(())
}
```

Key differences from old example:
- No manual CLI discovery (init() + ClaudeCli::new)
- No manual MCP config JSON construction
- No manual temp file management
- No manual tool name computation
- No manual RunConfig construction
- No --server flag parsing (uses env var instead)

The build_toolset() function is shared between server and client modes. The on_submit callback is intentionally omitted to keep the example simple (the default submit tool just returns the validated JSON as confirmation text).

NOTE: The example will NOT work at runtime without Claude Code CLI installed, but it MUST compile. This is an e2e example, not a unit test.

NOTE: If JsonSchemaToolkit::builder().build() requires an on_submit callback, add a simple one: `.on_submit(|review: MovieReview| format!("Submitted: {}", review.title))`
  </action>
  <verify>
Run `cargo check --example mcp_tool_agent_e2e -p rig-provider 2>&1` -- must compile with zero errors. Count lines: `wc -l rig-provider/examples/mcp_tool_agent_e2e.rs` -- should be under 80 lines. Verify the example contains "McpToolAgent::builder".
  </verify>
  <done>
New mcp_tool_agent_e2e.rs example compiles and is ~50-60 lines. Demonstrates the complete McpToolAgent pattern: define struct, build toolset, detect server mode via env var, run with builder API. Massive reduction from the ~300-line manual approach.
  </done>
</task>

<task type="auto">
  <name>Task 2: Final workspace verification and cleanup</name>
  <files>
    rig-provider/examples/mcp_tool_agent_e2e.rs
  </files>
  <action>
Run comprehensive verification across the entire workspace:

1. `cargo check --workspace` -- all crates compile
2. `cargo clippy --workspace` -- no new warnings
3. `cargo doc --workspace --no-deps` -- documentation builds (checks doc comment validity)

If any issues found, fix them. Common issues:
- Missing doc comments on public items (deny(missing_docs) is active)
- Unused imports
- Dead code warnings from new types
- Type mismatches in example

Also verify that the OLD mcp_extraction_e2e.rs still compiles:
`cargo check --example mcp_extraction_e2e -p rig-provider`

This example uses claudecode-adapter directly and should be unaffected by our changes (we only added new Optional fields with defaults to CodexConfig/OpenCodeConfig, and Claude's RunConfig was not modified).

If there are any compilation issues in existing examples due to the new adapter fields, fix them by ensuring all new fields have proper Default implementations (they should -- Vec::new() and None are defaults).
  </action>
  <verify>
Run `cargo check --workspace 2>&1` -- zero errors. Run `cargo clippy --workspace 2>&1` -- zero new warnings from modified crates. Run `cargo check --example mcp_extraction_e2e -p rig-provider 2>&1` -- old example still compiles. Run `cargo check --example mcp_tool_agent_e2e -p rig-provider 2>&1` -- new example compiles.
  </verify>
  <done>
Full workspace compiles. Both old and new examples compile. No clippy warnings from modified crates. Documentation builds. Phase 2.1 is code-complete: McpToolAgent builder works with all three CLI adapters, MCP config generated per-adapter, temp files cleaned via RAII, example proves the API.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` passes with zero errors
2. `cargo clippy --workspace` has no new warnings
3. New example compiles: `cargo check --example mcp_tool_agent_e2e -p rig-provider`
4. Old example still compiles: `cargo check --example mcp_extraction_e2e -p rig-provider`
5. New example is under 80 lines
6. New example uses McpToolAgent::builder() API
7. New example uses env var mode detection (RIG_MCP_SERVER), not CLI flags
8. Documentation builds: `cargo doc --workspace --no-deps`
</verification>

<success_criteria>
- mcp_tool_agent_e2e.rs demonstrates the full McpToolAgent pattern in ~50 lines
- The example is self-documenting: defines struct, builds toolset, detects mode, runs agent
- Both old and new examples compile
- Full workspace is clean (no errors, no new warnings)
- Phase 2.1 success criteria met: McpToolAgent builder accepts ToolSet + prompt + adapter, auto-generates config, auto-discovers CLI, auto-computes tool names, auto-cleans temp files
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-transparent-mcp-tool-agent/02.1-03-SUMMARY.md`
</output>
